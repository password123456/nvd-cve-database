{
  "totalResults": 11,
  "datePublished": "2024-07-17T17:00:04.796350Z",
  "vulnerabilities": [
    {
      "cve": {
        "id": "CVE-2024-41009",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-07-17T07:15:01.973",
        "lastModified": "2024-07-17T13:34:20.520",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbpf: Fix overrunning reservations in ringbuf\nThe BPF ring buffer internally is implemented as a power-of-2 sized circular\nbuffer, with two logical and ever-increasing counters: consumer_pos is the\nconsumer counter to show which logical position the consumer consumed the\ndata, and producer_pos which is the producer counter denoting the amount of\ndata reserved by all producers.\nEach time a record is reserved, the producer that \"owns\" the record will\nsuccessfully advance producer counter. In user space each time a record is\nread, the consumer of the data advanced the consumer counter once it finished\nprocessing. Both counters are stored in separate pages so that from user\nspace, the producer counter is read-only and the consumer counter is read-write.\nOne aspect that simplifies and thus speeds up the implementation of both\nproducers and consumers is how the data area is mapped twice contiguously\nback-to-back in the virtual memory, allowing to not take any special measures\nfor samples that have to wrap around at the end of the circular buffer data\narea, because the next page after the last data page would be first data page\nagain, and thus the sample will still appear completely contiguous in virtual\nmemory.\nEach record has a struct bpf_ringbuf_hdr { u32 len; u32 pg_off; } header for\nbook-keeping the length and offset, and is inaccessible to the BPF program.\nHelpers like bpf_ringbuf_reserve() return `(void *)hdr + BPF_RINGBUF_HDR_SZ`\nfor the BPF program to use. Bing-Jhong and Muhammad reported that it is however\npossible to make a second allocated memory chunk overlapping with the first\nchunk and as a result, the BPF program is now able to edit first chunk's\nheader.\nFor example, consider the creation of a BPF_MAP_TYPE_RINGBUF map with size\nof 0x4000. Next, the consumer_pos is modified to 0x3000 /before/ a call to\nbpf_ringbuf_reserve() is made. This will allocate a chunk A, which is in\n[0x0,0x3008], and the BPF program is able to edit [0x8,0x3008]. Now, lets\nallocate a chunk B with size 0x3000. This will succeed because consumer_pos\nwas edited ahead of time to pass the `new_prod_pos - cons_pos > rb->mask`\ncheck. Chunk B will be in range [0x3008,0x6010], and the BPF program is able\nto edit [0x3010,0x6010]. Due to the ring buffer memory layout mentioned\nearlier, the ranges [0x0,0x4000] and [0x4000,0x8000] point to the same data\npages. This means that chunk B at [0x4000,0x4008] is chunk A's header.\nbpf_ringbuf_submit() / bpf_ringbuf_discard() use the header's pg_off to then\nlocate the bpf_ringbuf itself via bpf_ringbuf_restore_from_rec(). Once chunk\nB modified chunk A's header, then bpf_ringbuf_commit() refers to the wrong\npage and could cause a crash.\nFix it by calculating the oldest pending_pos and check whether the range\nfrom the oldest outstanding record to the newest would span beyond the ring\nbuffer size. If that is the case, then reject the request. We've tested with\nthe ring buffer benchmark in BPF selftests (./benchs/run_bench_ringbufs.sh)\nbefore/after the fix and while it seems a bit slower on some benchmarks, it\nis still not significantly enough to matter.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/47416c852f2a04d348ea66ee451cbdcf8119f225"
          },
          {
            "url": "https://git.kernel.org/stable/c/511804ab701c0503b72eac08217eabfd366ba069"
          },
          {
            "url": "https://git.kernel.org/stable/c/cfa1a2329a691ffd991fcf7248a57d752e712881"
          },
          {
            "url": "https://git.kernel.org/stable/c/d1b9df0435bc61e0b44f578846516df8ef476686"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-41010",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-07-17T07:15:02.183",
        "lastModified": "2024-07-17T13:34:20.520",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbpf: Fix too early release of tcx_entry\nPedro Pinto and later independently also Hyunwoo Kim and Wongi Lee reported\nan issue that the tcx_entry can be released too early leading to a use\nafter free (UAF) when an active old-style ingress or clsact qdisc with a\nshared tc block is later replaced by another ingress or clsact instance.\nEssentially, the sequence to trigger the UAF (one example) can be as follows:\n  1. A network namespace is created\n  2. An ingress qdisc is created. This allocates a tcx_entry, and\n     &tcx_entry->miniq is stored in the qdisc's miniqp->p_miniq. At the\n     same time, a tcf block with index 1 is created.\n  3. chain0 is attached to the tcf block. chain0 must be connected to\n     the block linked to the ingress qdisc to later reach the function\n     tcf_chain0_head_change_cb_del() which triggers the UAF.\n  4. Create and graft a clsact qdisc. This causes the ingress qdisc\n     created in step 1 to be removed, thus freeing the previously linked\n     tcx_entry:\n     rtnetlink_rcv_msg()\n       => tc_modify_qdisc()\n         => qdisc_create()\n           => clsact_init() [a]\n         => qdisc_graft()\n           => qdisc_destroy()\n             => __qdisc_destroy()\n               => ingress_destroy() [b]\n                 => tcx_entry_free()\n                   => kfree_rcu() // tcx_entry freed\n  5. Finally, the network namespace is closed. This registers the\n     cleanup_net worker, and during the process of releasing the\n     remaining clsact qdisc, it accesses the tcx_entry that was\n     already freed in step 4, causing the UAF to occur:\n     cleanup_net()\n       => ops_exit_list()\n         => default_device_exit_batch()\n           => unregister_netdevice_many()\n             => unregister_netdevice_many_notify()\n               => dev_shutdown()\n                 => qdisc_put()\n                   => clsact_destroy() [c]\n                     => tcf_block_put_ext()\n                       => tcf_chain0_head_change_cb_del()\n                         => tcf_chain_head_change_item()\n                           => clsact_chain_head_change()\n                             => mini_qdisc_pair_swap() // UAF\nThere are also other variants, the gist is to add an ingress (or clsact)\nqdisc with a specific shared block, then to replace that qdisc, waiting\nfor the tcx_entry kfree_rcu() to be executed and subsequently accessing\nthe current active qdisc's miniq one way or another.\nThe correct fix is to turn the miniq_active boolean into a counter. What\ncan be observed, at step 2 above, the counter transitions from 0->1, at\nstep [a] from 1->2 (in order for the miniq object to remain active during\nthe replacement), then in [b] from 2->1 and finally [c] 1->0 with the\neventual release. The reference counter in general ranges from [0,2] and\nit does not need to be atomic since all access to the counter is protected\nby the rtnl mutex. With this in place, there is no longer a UAF happening\nand the tcx_entry is freed at the correct time.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1cb6f0bae50441f4b4b32a28315853b279c7404e"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-5251",
        "sourceIdentifier": "security@wordfence.com",
        "published": "2024-07-17T07:15:02.260",
        "lastModified": "2024-07-17T13:34:20.520",
        "baseScore": 6.4,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 3.1,
        "impactScore": 2.7,
        "description": "The Ultimate Addons for WPBakery plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's ultimate_pricing  shortcode in all versions up to, and including, 3.19.20 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.",
        "cweIds": null,
        "references": [
          {
            "url": "https://ultimate.brainstormforce.com/changelog/?utm_source=codecanyon-item-page&utm_campaign=uavc-changelog&utm_medium=changelog"
          },
          {
            "url": "https://www.wordfence.com/threat-intel/vulnerabilities/id/e637044d-9b49-4de5-b8b8-d48a0e5e1afc?source=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-5252",
        "sourceIdentifier": "security@wordfence.com",
        "published": "2024-07-17T07:15:02.483",
        "lastModified": "2024-07-17T13:34:20.520",
        "baseScore": 6.4,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 3.1,
        "impactScore": 2.7,
        "description": "The Ultimate Addons for WPBakery plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's ultimate_info_table shortcode in all versions up to, and including, 3.19.20 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.",
        "cweIds": null,
        "references": [
          {
            "url": "https://ultimate.brainstormforce.com/changelog/?utm_source=codecanyon-item-page&utm_campaign=uavc-changelog&utm_medium=changelog"
          },
          {
            "url": "https://www.wordfence.com/threat-intel/vulnerabilities/id/675937dc-a032-4bc4-a449-c815fcb12db6?source=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-5253",
        "sourceIdentifier": "security@wordfence.com",
        "published": "2024-07-17T07:15:02.690",
        "lastModified": "2024-07-17T13:34:20.520",
        "baseScore": 6.4,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 3.1,
        "impactScore": 2.7,
        "description": "The Ultimate Addons for WPBakery plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's ult_team shortcode in all versions up to, and including, 3.19.20 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.",
        "cweIds": null,
        "references": [
          {
            "url": "https://ultimate.brainstormforce.com/changelog/?utm_source=codecanyon-item-page&utm_campaign=uavc-changelog&utm_medium=changelog"
          },
          {
            "url": "https://www.wordfence.com/threat-intel/vulnerabilities/id/97666e54-8e86-4f18-ae32-ad8ca607aeff?source=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-5254",
        "sourceIdentifier": "security@wordfence.com",
        "published": "2024-07-17T07:15:02.883",
        "lastModified": "2024-07-17T13:34:20.520",
        "baseScore": 6.4,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 3.1,
        "impactScore": 2.7,
        "description": "The Ultimate Addons for WPBakery plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's ultimate_info_banner shortcode in all versions up to, and including, 3.19.20 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.",
        "cweIds": null,
        "references": [
          {
            "url": "https://ultimate.brainstormforce.com/changelog/?utm_source=codecanyon-item-page&utm_campaign=uavc-changelog&utm_medium=changelog"
          },
          {
            "url": "https://www.wordfence.com/threat-intel/vulnerabilities/id/4c8971e0-befd-47ac-8cb5-064f9cd757d7?source=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-5255",
        "sourceIdentifier": "security@wordfence.com",
        "published": "2024-07-17T07:15:03.073",
        "lastModified": "2024-07-17T13:34:20.520",
        "baseScore": 6.4,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 3.1,
        "impactScore": 2.7,
        "description": "The Ultimate Addons for WPBakery plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's ultimate_dual_color shortcode in all versions up to, and including, 3.19.20 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.",
        "cweIds": null,
        "references": [
          {
            "url": "https://ultimate.brainstormforce.com/changelog/?utm_source=codecanyon-item-page&utm_campaign=uavc-changelog&utm_medium=changelog"
          },
          {
            "url": "https://www.wordfence.com/threat-intel/vulnerabilities/id/66d77518-a258-4e79-b483-275855c0a416?source=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-6033",
        "sourceIdentifier": "security@wordfence.com",
        "published": "2024-07-17T07:15:03.263",
        "lastModified": "2024-07-17T13:34:20.520",
        "baseScore": 4.3,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 2.8,
        "impactScore": 1.4,
        "description": "The Event Manager, Events Calendar, Tickets, Registrations – Eventin plugin for WordPress is vulnerable to unauthorized data importation due to a missing capability check on the 'import_file' function in all versions up to, and including, 4.0.4. This makes it possible for authenticated attackers, with Contributor-level access and above, to import events, speakers, schedules and attendee data.",
        "cweIds": null,
        "references": [
          {
            "url": "https://plugins.trac.wordpress.org/browser/wp-event-solution/trunk/core/admin/hooks.php#L135"
          },
          {
            "url": "https://plugins.trac.wordpress.org/changeset/3117477/"
          },
          {
            "url": "https://www.wordfence.com/threat-intel/vulnerabilities/id/1725c7f3-2fac-4714-a63e-6c43694483fc?source=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-6467",
        "sourceIdentifier": "security@wordfence.com",
        "published": "2024-07-17T07:15:03.493",
        "lastModified": "2024-07-17T13:34:20.520",
        "baseScore": 8.8,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 2.8,
        "impactScore": 5.9,
        "description": "The BookingPress – Appointment Booking Calendar Plugin and Online Scheduling Plugin plugin for WordPress is vulnerable to Arbitrary File Read to Arbitrary File Creation in all versions up to, and including, 1.1.5 via the 'bookingpress_save_lite_wizard_settings_func' function. This makes it possible for authenticated attackers, with Subscriber-level access and above, to create arbitrary files that contain the content of files on the server, allowing the execution of any PHP code in those files or the exposure of sensitive information.",
        "cweIds": null,
        "references": [
          {
            "url": "https://plugins.trac.wordpress.org/changeset/3116857/bookingpress-appointment-booking/trunk/core/classes/class.bookingpress.php"
          },
          {
            "url": "https://www.wordfence.com/threat-intel/vulnerabilities/id/d0177510-cd7d-4cc5-96c3-78433aa0e3f6?source=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-6660",
        "sourceIdentifier": "security@wordfence.com",
        "published": "2024-07-17T07:15:03.683",
        "lastModified": "2024-07-17T13:34:20.520",
        "baseScore": 8.8,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 2.8,
        "impactScore": 5.9,
        "description": "The BookingPress – Appointment Booking Calendar Plugin and Online Scheduling Plugin plugin for WordPress is vulnerable to unauthorized modification of data that can lead to privilege escalation due to a missing capability check on the bookingpress_import_data_continue_process_func function in all versions up to, and including, 1.1.5. This makes it possible for authenticated attackers, with Subscriber-level access and above, to update arbitrary options on the WordPress site and upload arbitrary files. This can be leveraged to update the default role for registration to administrator and enable user registration for attackers to gain administrative user access to a vulnerable site.",
        "cweIds": null,
        "references": [
          {
            "url": "https://plugins.trac.wordpress.org/browser/bookingpress-appointment-booking/trunk/core/classes/class.bookingpress_import_export.php#L1491"
          },
          {
            "url": "https://plugins.trac.wordpress.org/browser/bookingpress-appointment-booking/trunk/core/classes/class.bookingpress_import_export.php#L410"
          },
          {
            "url": "https://plugins.trac.wordpress.org/browser/bookingpress-appointment-booking/trunk/core/classes/class.bookingpress_import_export.php#L476"
          },
          {
            "url": "https://plugins.trac.wordpress.org/changeset/3116857/bookingpress-appointment-booking/trunk/core/classes/class.bookingpress_import_export.php?contextall=1"
          },
          {
            "url": "https://www.wordfence.com/threat-intel/vulnerabilities/id/851ff861-474e-4063-88ff-d8d35b10e9a0?source=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-6669",
        "sourceIdentifier": "security@wordfence.com",
        "published": "2024-07-17T07:15:03.873",
        "lastModified": "2024-07-17T13:34:20.520",
        "baseScore": 5.5,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 2.3,
        "impactScore": 2.7,
        "description": "The AI ChatBot for WordPress – WPBot plugin for WordPress is vulnerable to Stored Cross-Site Scripting via admin settings in all versions up to, and including, 5.5.7 due to insufficient input sanitization and output escaping. This makes it possible for authenticated attackers, with administrator-level permissions and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page. This only affects multi-site installations and installations where unfiltered_html has been disabled.",
        "cweIds": null,
        "references": [
          {
            "url": "https://plugins.trac.wordpress.org/browser/chatbot/trunk/admin_ui.php#L2211"
          },
          {
            "url": "https://plugins.trac.wordpress.org/browser/chatbot/trunk/admin_ui.php#L755"
          },
          {
            "url": "https://plugins.trac.wordpress.org/changeset/3119022/"
          },
          {
            "url": "https://wordpress.org/plugins/chatbot/#developers"
          },
          {
            "url": "https://www.wordfence.com/threat-intel/vulnerabilities/id/ce23efed-fe21-486a-ab3b-9ed0dd26a971?source=cve"
          }
        ]
      }
    }
  ]
}