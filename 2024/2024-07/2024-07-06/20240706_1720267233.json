{
  "totalResults": 4,
  "datePublished": "2024-07-06T21:00:33.111329Z",
  "vulnerabilities": [
    {
      "cve": {
        "id": "CVE-2024-37208",
        "sourceIdentifier": "audit@patchstack.com",
        "published": "2024-07-06T10:15:01.907",
        "lastModified": "2024-07-06T10:15:01.907",
        "baseScore": 4.9,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 1.8,
        "impactScore": 2.7,
        "description": "Server-Side Request Forgery (SSRF) vulnerability in Robert Macchi WP Scraper.This issue affects WP Scraper: from n/a through 5.7.",
        "cweIds": [
          {
            "id": "CWE-918",
            "description": "Server-Side Request Forgery (SSRF)"
          }
        ],
        "references": [
          {
            "url": "https://patchstack.com/database/vulnerability/wp-scraper/wordpress-wp-scraper-plugin-5-7-server-side-request-forgery-ssrf-vulnerability?_s_id=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-37234",
        "sourceIdentifier": "audit@patchstack.com",
        "published": "2024-07-06T10:15:02.913",
        "lastModified": "2024-07-06T10:15:02.913",
        "baseScore": 3.5,
        "baseSeverity": "LOW",
        "exploitabilityScore": 2.1,
        "impactScore": 1.4,
        "description": "URL Redirection to Untrusted Site ('Open Redirect') vulnerability in Kodezen Limited Academy LMS.This issue affects Academy LMS: from n/a through 2.0.4.",
        "cweIds": [
          {
            "id": "CWE-601",
            "description": "URL Redirection to Untrusted Site ('Open Redirect')"
          }
        ],
        "references": [
          {
            "url": "https://patchstack.com/database/vulnerability/academy/wordpress-academy-lms-plugin-2-0-2-open-redirection-vulnerability?_s_id=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-37260",
        "sourceIdentifier": "audit@patchstack.com",
        "published": "2024-07-06T10:15:03.190",
        "lastModified": "2024-07-06T10:15:03.190",
        "baseScore": 7.2,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 3.9,
        "impactScore": 2.7,
        "description": "Server-Side Request Forgery (SSRF) vulnerability in Theme-Ruby Foxiz.This issue affects Foxiz: from n/a through 2.3.5.",
        "cweIds": [
          {
            "id": "CWE-918",
            "description": "Server-Side Request Forgery (SSRF)"
          }
        ],
        "references": [
          {
            "url": "https://patchstack.com/database/vulnerability/foxiz/wordpress-foxiz-theme-theme-2-3-5-server-side-request-forgery-ssrf-vulnerability?_s_id=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-39486",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-07-06T10:15:03.393",
        "lastModified": "2024-07-06T10:15:03.393",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/drm_file: Fix pid refcounting race\nfilp->pid is supposed to be a refcounted pointer; however, before this\npatch, drm_file_update_pid() only increments the refcount of a struct\npid after storing a pointer to it in filp->pid and dropping the\ndev->filelist_mutex, making the following race possible:\nprocess A               process B\n=========               =========\n                        begin drm_file_update_pid\n                        mutex_lock(&dev->filelist_mutex)\n                        rcu_replace_pointer(filp->pid, <pid B>, 1)\n                        mutex_unlock(&dev->filelist_mutex)\nbegin drm_file_update_pid\nmutex_lock(&dev->filelist_mutex)\nrcu_replace_pointer(filp->pid, <pid A>, 1)\nmutex_unlock(&dev->filelist_mutex)\nget_pid(<pid A>)\nsynchronize_rcu()\nput_pid(<pid B>)   *** pid B reaches refcount 0 and is freed here ***\n                        get_pid(<pid B>)   *** UAF ***\n                        synchronize_rcu()\n                        put_pid(<pid A>)\nAs far as I know, this race can only occur with CONFIG_PREEMPT_RCU=y\nbecause it requires RCU to detect a quiescent state in code that is not\nexplicitly calling into the scheduler.\nThis race leads to use-after-free of a \"struct pid\".\nIt is probably somewhat hard to hit because process A has to pass\nthrough a synchronize_rcu() operation while process B is between\nmutex_unlock() and get_pid().\nFix it by ensuring that by the time a pointer to the current task's pid\nis stored in the file, an extra reference to the pid has been taken.\nThis fix also removes the condition for synchronize_rcu(); I think\nthat optimization is unnecessary complexity, since in that case we\nwould usually have bailed out on the lockless check above.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0acce2a5c619ef1abdee783d7fea5eac78ce4844"
          },
          {
            "url": "https://git.kernel.org/stable/c/16682588ead4a593cf1aebb33b36df4d1e9e4ffa"
          },
          {
            "url": "https://git.kernel.org/stable/c/4f2a129b33a2054e62273edd5a051c34c08d96e9"
          }
        ]
      }
    }
  ]
}