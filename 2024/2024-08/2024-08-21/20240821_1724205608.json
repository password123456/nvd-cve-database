{
  "totalResults": 23,
  "datePublished": "2024-08-21T11:00:08.104386Z",
  "vulnerabilities": [
    {
      "cve": {
        "id": "CVE-2024-43862",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-21T00:15:04.773",
        "lastModified": "2024-08-21T00:15:04.773",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: wan: fsl_qmc_hdlc: Convert carrier_lock spinlock to a mutex\nThe carrier_lock spinlock protects the carrier detection. While it is\nheld, framer_get_status() is called which in turn takes a mutex.\nThis is not correct and can lead to a deadlock.\nA run with PROVE_LOCKING enabled detected the issue:\n  [ BUG: Invalid wait context ]\n  ...\n  c204ddbc (&framer->mutex){+.+.}-{3:3}, at: framer_get_status+0x40/0x78\n  other info that might help us debug this:\n  context-{4:4}\n  2 locks held by ifconfig/146:\n  #0: c0926a38 (rtnl_mutex){+.+.}-{3:3}, at: devinet_ioctl+0x12c/0x664\n  #1: c2006a40 (&qmc_hdlc->carrier_lock){....}-{2:2}, at: qmc_hdlc_framer_set_carrier+0x30/0x98\nAvoid the spinlock usage and convert carrier_lock to a mutex.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/c4d6a347ba7babdf9d90a0eb24048c266cae0532"
          },
          {
            "url": "https://git.kernel.org/stable/c/f223d2b4acb7a45a6e0581cb380e1af1a6dc7ab9"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-43863",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-21T00:15:04.847",
        "lastModified": "2024-08-21T00:15:04.847",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/vmwgfx: Fix a deadlock in dma buf fence polling\nIntroduce a version of the fence ops that on release doesn't remove\nthe fence from the pending list, and thus doesn't require a lock to\nfix poll->fence wait->fence unref deadlocks.\nvmwgfx overwrites the wait callback to iterate over the list of all\nfences and update their status, to do that it holds a lock to prevent\nthe list modifcations from other threads. The fence destroy callback\nboth deletes the fence and removes it from the list of pending\nfences, for which it holds a lock.\ndma buf polling cb unrefs a fence after it's been signaled: so the poll\ncalls the wait, which signals the fences, which are being destroyed.\nThe destruction tries to acquire the lock on the pending fences list\nwhich it can never get because it's held by the wait from which it\nwas called.\nOld bug, but not a lot of userspace apps were using dma-buf polling\ninterfaces. Fix those, in particular this fixes KDE stalls/deadlock.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3b933b16c996af8adb6bc1b5748a63dfb41a82bc"
          },
          {
            "url": "https://git.kernel.org/stable/c/9e20d028d8d1deb1e7fed18f22ffc01669cf3237"
          },
          {
            "url": "https://git.kernel.org/stable/c/a8943969f9ead2fd3044fc826140a21622ef830e"
          },
          {
            "url": "https://git.kernel.org/stable/c/c98ab18b9f315ff977c2c65d7c71298ef98be8e3"
          },
          {
            "url": "https://git.kernel.org/stable/c/e58337100721f3cc0c7424a18730e4f39844934f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-43864",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-21T00:15:04.910",
        "lastModified": "2024-08-21T00:15:04.910",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/mlx5e: Fix CT entry update leaks of modify header context\nThe cited commit allocates a new modify header to replace the old\none when updating CT entry. But if failed to allocate a new one, eg.\nexceed the max number firmware can support, modify header will be\nan error pointer that will trigger a panic when deallocating it. And\nthe old modify header point is copied to old attr. When the old\nattr is freed, the old modify header is lost.\nFix it by restoring the old attr to attr when failed to allocate a\nnew modify header context. So when the CT entry is freed, the right\nmodify header context will be freed. And the panic of accessing\nerror pointer is also fixed.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/025f2b85a5e5a46df14ecf162c3c80a957a36d0b"
          },
          {
            "url": "https://git.kernel.org/stable/c/89064d09c56b44c668509bf793c410484f63f5ad"
          },
          {
            "url": "https://git.kernel.org/stable/c/daab2cc17b6b6ab158566bba037e9551fd432b59"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-43865",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-21T00:15:04.967",
        "lastModified": "2024-08-21T00:15:04.967",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ns390/fpu: Re-add exception handling in load_fpu_state()\nWith the recent rewrite of the fpu code exception handling for the\nlfpc instruction within load_fpu_state() was erroneously removed.\nAdd it again to prevent that loading invalid floating point register\nvalues cause an unhandled specification exception.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4734406c39238cbeafe66f0060084caa3247ff53"
          },
          {
            "url": "https://git.kernel.org/stable/c/494b14138201f07343e5488db6360c828fcc8cf6"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-43866",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-21T00:15:05.023",
        "lastModified": "2024-08-21T00:15:05.023",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/mlx5: Always drain health in shutdown callback\nThere is no point in recovery during device shutdown. if health\nwork started need to wait for it to avoid races and NULL pointer\naccess.\nHence, drain health WQ on shutdown callback.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1b75da22ed1e6171e261bc9265370162553d5393"
          },
          {
            "url": "https://git.kernel.org/stable/c/6048dec754554a1303d632be6042d3feb3295285"
          },
          {
            "url": "https://git.kernel.org/stable/c/6b6c2ebd83f2bf97e8f221479372aaca97a4a9b2"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-43867",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-21T00:15:05.087",
        "lastModified": "2024-08-21T00:15:05.087",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/nouveau: prime: fix refcount underflow\nCalling nouveau_bo_ref() on a nouveau_bo without initializing it (and\nhence the backing ttm_bo) leads to a refcount underflow.\nInstead of calling nouveau_bo_ref() in the unwind path of\ndrm_gem_object_init(), clean things up manually.\n(cherry picked from commit 1b93f3e89d03cfc576636e195466a0d728ad8de5)",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/16998763c62bb465ebc409d0373b9cdcef1a61a6"
          },
          {
            "url": "https://git.kernel.org/stable/c/2a1b327d57a8ac080977633a18999f032d7e9e3f"
          },
          {
            "url": "https://git.kernel.org/stable/c/3bcb8bba72ce89667fa863054956267c450c47ef"
          },
          {
            "url": "https://git.kernel.org/stable/c/906372e753c5027a1dc88743843b6aa2ad1aaecf"
          },
          {
            "url": "https://git.kernel.org/stable/c/a9bf3efc33f1fbf88787a277f7349459283c9b95"
          },
          {
            "url": "https://git.kernel.org/stable/c/ebebba4d357b6c67f96776a48ddbaf0060fa4c10"
          },
          {
            "url": "https://git.kernel.org/stable/c/f23cd66933fe76b84d8e282e5606b4d99068c320"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-43868",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-21T00:15:05.150",
        "lastModified": "2024-08-21T00:15:05.150",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nriscv/purgatory: align riscv_kernel_entry\nWhen alignment handling is delegated to the kernel, everything must be\nword-aligned in purgatory, since the trap handler is then set to the\nkexec one. Without the alignment, hitting the exception would\nultimately crash. On other occasions, the kernel's handler would take\ncare of exceptions.\nThis has been tested on a JH7110 SoC with oreboot and its SBI delegating\nunaligned access exceptions and the kernel configured to handle them.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/5d4aaf16a8255f7c71790e211724ba029609c5ff"
          },
          {
            "url": "https://git.kernel.org/stable/c/fb197c5d2fd24b9af3d4697d0cf778645846d6d5"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-8022",
        "sourceIdentifier": "cna@vuldb.com",
        "published": "2024-08-21T00:15:05.227",
        "lastModified": "2024-08-21T00:15:05.227",
        "baseScore": 3.5,
        "baseSeverity": "LOW",
        "exploitabilityScore": 2.1,
        "impactScore": 1.4,
        "description": "A vulnerability was found in Genexis Tilgin Home Gateway 322_AS0500-03_05_13_05. It has been rated as problematic. This issue affects some unknown processing of the file /vood/cgi-bin/vood_view.cgi?lang=EN&act=user/spec_conf&sessionId=86213915328111654515&user=A&message2user=Account%20updated. The manipulation of the argument Phone Number leads to cross site scripting. The attack may be initiated remotely. The exploit has been disclosed to the public and may be used. NOTE: The vendor was contacted early about this disclosure but did not respond in any way.",
        "cweIds": [
          {
            "id": "CWE-79",
            "description": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
          }
        ],
        "references": [
          {
            "url": "https://vuldb.com/?ctiid.275291"
          },
          {
            "url": "https://vuldb.com/?id.275291"
          },
          {
            "url": "https://vuldb.com/?submit.389913"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-8023",
        "sourceIdentifier": "cna@vuldb.com",
        "published": "2024-08-21T00:15:05.527",
        "lastModified": "2024-08-21T00:15:05.527",
        "baseScore": 6.3,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 2.8,
        "impactScore": 3.4,
        "description": "A vulnerability classified as critical has been found in chillzhuang SpringBlade 4.1.0. Affected is an unknown function of the file /api/blade-system/menu/list?updatexml. The manipulation leads to sql injection. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used. NOTE: The vendor was contacted early about this disclosure but did not respond in any way.",
        "cweIds": [
          {
            "id": "CWE-89",
            "description": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
          }
        ],
        "references": [
          {
            "url": "https://gist.github.com/topsky979/74dcbe81062718f314d81fb6ad5dc1e0"
          },
          {
            "url": "https://vuldb.com/?ctiid.275292"
          },
          {
            "url": "https://vuldb.com/?id.275292"
          },
          {
            "url": "https://vuldb.com/?submit.390087"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-43869",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-21T01:15:11.550",
        "lastModified": "2024-08-21T01:15:11.550",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nperf: Fix event leak upon exec and file release\nThe perf pending task work is never waited upon the matching event\nrelease. In the case of a child event, released via free_event()\ndirectly, this can potentially result in a leaked event, such as in the\nfollowing scenario that doesn't even require a weak IRQ work\nimplementation to trigger:\nschedule()\n   prepare_task_switch()\n=======> <NMI>\n      perf_event_overflow()\n         event->pending_sigtrap = ...\n         irq_work_queue(&event->pending_irq)\n<======= </NMI>\n      perf_event_task_sched_out()\n          event_sched_out()\n              event->pending_sigtrap = 0;\n              atomic_long_inc_not_zero(&event->refcount)\n              task_work_add(&event->pending_task)\n   finish_lock_switch()\n=======> <IRQ>\n   perf_pending_irq()\n      //do nothing, rely on pending task work\n<======= </IRQ>\nbegin_new_exec()\n   perf_event_exit_task()\n      perf_event_exit_event()\n         // If is child event\n         free_event()\n            WARN(atomic_long_cmpxchg(&event->refcount, 1, 0) != 1)\n            // event is leaked\nSimilar scenarios can also happen with perf_event_remove_on_exec() or\nsimply against concurrent perf_event_release().\nFix this with synchonizing against the possibly remaining pending task\nwork while freeing the event, just like is done with remaining pending\nIRQ work. This means that the pending task callback neither need nor\nshould hold a reference to the event, preventing it from ever beeing\nfreed.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/104e258a004037bc7dba9f6085c71dad6af57ad4"
          },
          {
            "url": "https://git.kernel.org/stable/c/3a5465418f5fd970e86a86c7f4075be262682840"
          },
          {
            "url": "https://git.kernel.org/stable/c/9ad46f1fef421d43cdab3a7d1744b2f43b54dae0"
          },
          {
            "url": "https://git.kernel.org/stable/c/ed2c202dac55423a52d7e2290f2888bf08b8ee99"
          },
          {
            "url": "https://git.kernel.org/stable/c/f34d8307a73a18de5320fcc6f40403146d061891"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-43870",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-21T01:15:11.620",
        "lastModified": "2024-08-21T01:15:11.620",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nperf: Fix event leak upon exit\nWhen a task is scheduled out, pending sigtrap deliveries are deferred\nto the target task upon resume to userspace via task_work.\nHowever failures while adding an event's callback to the task_work\nengine are ignored. And since the last call for events exit happen\nafter task work is eventually closed, there is a small window during\nwhich pending sigtrap can be queued though ignored, leaking the event\nrefcount addition such as in the following scenario:\n    TASK A\n    -----\n    do_exit()\n       exit_task_work(tsk);\n       <IRQ>\n       perf_event_overflow()\n          event->pending_sigtrap = pending_id;\n          irq_work_queue(&event->pending_irq);\n       </IRQ>\n    =========> PREEMPTION: TASK A -> TASK B\n       event_sched_out()\n          event->pending_sigtrap = 0;\n          atomic_long_inc_not_zero(&event->refcount)\n          // FAILS: task work has exited\n          task_work_add(&event->pending_task)\n       [...]\n       <IRQ WORK>\n       perf_pending_irq()\n          // early return: event->oncpu = -1\n       </IRQ WORK>\n       [...]\n    =========> TASK B -> TASK A\n       perf_event_exit_task(tsk)\n          perf_event_exit_event()\n             free_event()\n                WARN(atomic_long_cmpxchg(&event->refcount, 1, 0) != 1)\n                // leak event due to unexpected refcount == 2\nAs a result the event is never released while the task exits.\nFix this with appropriate task_work_add()'s error handling.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/05d3fd599594abf79aad4484bccb2b26e1cb0b51"
          },
          {
            "url": "https://git.kernel.org/stable/c/2fd5ad3f310de22836cdacae919dd99d758a1f1b"
          },
          {
            "url": "https://git.kernel.org/stable/c/3d7a63352a93bdb8a1cdf29606bf617d3ac1c22a"
          },
          {
            "url": "https://git.kernel.org/stable/c/67fad724f1b568b356c1065d50df46e6b30eb2f7"
          },
          {
            "url": "https://git.kernel.org/stable/c/70882d7fa74f0731492a0d493e8515a4f7131831"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-43871",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-21T01:15:11.680",
        "lastModified": "2024-08-21T01:15:11.680",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndevres: Fix memory leakage caused by driver API devm_free_percpu()\nIt will cause memory leakage when use driver API devm_free_percpu()\nto free memory allocated by devm_alloc_percpu(), fixed by using\ndevres_release() instead of devres_destroy() within devm_free_percpu().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3047f99caec240a88ccd06197af2868da1af6a96"
          },
          {
            "url": "https://git.kernel.org/stable/c/3dcd0673e47664bc6c719ad47dadac6d55d5950d"
          },
          {
            "url": "https://git.kernel.org/stable/c/700e8abd65b10792b2f179ce4e858f2ca2880f85"
          },
          {
            "url": "https://git.kernel.org/stable/c/95065edb8ebb27771d5f1e898eef6ab43dc6c87c"
          },
          {
            "url": "https://git.kernel.org/stable/c/b044588a16a978cd891cb3d665dd7ae06850d5bf"
          },
          {
            "url": "https://git.kernel.org/stable/c/b67552d7c61f52f1271031adfa7834545ae99701"
          },
          {
            "url": "https://git.kernel.org/stable/c/bd50a974097bb82d52a458bd3ee39fb723129a0c"
          },
          {
            "url": "https://git.kernel.org/stable/c/ef56dcdca8f2a53abc3a83d388b8336447533d85"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-43872",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-21T01:15:11.740",
        "lastModified": "2024-08-21T01:15:11.740",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nRDMA/hns: Fix soft lockup under heavy CEQE load\nCEQEs are handled in interrupt handler currently. This may cause the\nCPU core staying in interrupt context too long and lead to soft lockup\nunder heavy load.\nHandle CEQEs in BH workqueue and set an upper limit for the number of\nCEQE handled by a single call of work handler.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/06580b33c183c9f98e2a2ca96a86137179032c08"
          },
          {
            "url": "https://git.kernel.org/stable/c/2fdf34038369c0a27811e7b4680662a14ada1d6b"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-43873",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-21T01:15:11.790",
        "lastModified": "2024-08-21T01:15:11.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nvhost/vsock: always initialize seqpacket_allow\nThere are two issues around seqpacket_allow:\n1. seqpacket_allow is not initialized when socket is\n   created. Thus if features are never set, it will be\n   read uninitialized.\n2. if VIRTIO_VSOCK_F_SEQPACKET is set and then cleared,\n   then seqpacket_allow will not be cleared appropriately\n   (existing apps I know about don't usually do this but\n    it's legal and there's no way to be sure no one relies\n    on this).\nTo fix:\n\t- initialize seqpacket_allow after allocation\n\t- set it unconditionally in set_features",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1e1fdcbdde3b7663e5d8faeb2245b9b151417d22"
          },
          {
            "url": "https://git.kernel.org/stable/c/3062cb100787a9ddf45de30004b962035cd497fb"
          },
          {
            "url": "https://git.kernel.org/stable/c/30bd4593669443ac58515e23557dc8cef70d8582"
          },
          {
            "url": "https://git.kernel.org/stable/c/ea558f10fb05a6503c6e655a1b7d81fdf8e5924c"
          },
          {
            "url": "https://git.kernel.org/stable/c/eab96e8716cbfc2834b54f71cc9501ad4eec963b"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-43874",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-21T01:15:11.843",
        "lastModified": "2024-08-21T01:15:11.843",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ncrypto: ccp - Fix null pointer dereference in __sev_snp_shutdown_locked\nFix a null pointer dereference induced by DEBUG_TEST_DRIVER_REMOVE.\nReturn from __sev_snp_shutdown_locked() if the psp_device or the\nsev_device structs are not initialized. Without the fix, the driver will\nproduce the following splat:\n   ccp 0000:55:00.5: enabling device (0000 -> 0002)\n   ccp 0000:55:00.5: sev enabled\n   ccp 0000:55:00.5: psp enabled\n   BUG: kernel NULL pointer dereference, address: 00000000000000f0\n   #PF: supervisor read access in kernel mode\n   #PF: error_code(0x0000) - not-present page\n   PGD 0 P4D 0\n   Oops: 0000 [#1] PREEMPT SMP DEBUG_PAGEALLOC NOPTI\n   CPU: 262 PID: 1 Comm: swapper/0 Not tainted 6.9.0-rc1+ #29\n   RIP: 0010:__sev_snp_shutdown_locked+0x2e/0x150\n   Code: 00 55 48 89 e5 41 57 41 56 41 54 53 48 83 ec 10 41 89 f7 49 89 fe 65 48 8b 04 25 28 00 00 00 48 89 45 d8 48 8b 05 6a 5a 7f 06 <4c> 8b a0 f0 00 00 00 41 0f b6 9c 24 a2 00 00 00 48 83 fb 02 0f 83\n   RSP: 0018:ffffb2ea4014b7b8 EFLAGS: 00010286\n   RAX: 0000000000000000 RBX: ffff9e4acd2e0a28 RCX: 0000000000000000\n   RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffb2ea4014b808\n   RBP: ffffb2ea4014b7e8 R08: 0000000000000106 R09: 000000000003d9c0\n   R10: 0000000000000001 R11: ffffffffa39ff070 R12: ffff9e49d40590c8\n   R13: 0000000000000000 R14: ffffb2ea4014b808 R15: 0000000000000000\n   FS:  0000000000000000(0000) GS:ffff9e58b1e00000(0000) knlGS:0000000000000000\n   CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n   CR2: 00000000000000f0 CR3: 0000000418a3e001 CR4: 0000000000770ef0\n   PKRU: 55555554\n   Call Trace:\n    <TASK>\n    ? __die_body+0x6f/0xb0\n    ? __die+0xcc/0xf0\n    ? page_fault_oops+0x330/0x3a0\n    ? save_trace+0x2a5/0x360\n    ? do_user_addr_fault+0x583/0x630\n    ? exc_page_fault+0x81/0x120\n    ? asm_exc_page_fault+0x2b/0x30\n    ? __sev_snp_shutdown_locked+0x2e/0x150\n    __sev_firmware_shutdown+0x349/0x5b0\n    ? pm_runtime_barrier+0x66/0xe0\n    sev_dev_destroy+0x34/0xb0\n    psp_dev_destroy+0x27/0x60\n    sp_destroy+0x39/0x90\n    sp_pci_remove+0x22/0x60\n    pci_device_remove+0x4e/0x110\n    really_probe+0x271/0x4e0\n    __driver_probe_device+0x8f/0x160\n    driver_probe_device+0x24/0x120\n    __driver_attach+0xc7/0x280\n    ? driver_attach+0x30/0x30\n    bus_for_each_dev+0x10d/0x130\n    driver_attach+0x22/0x30\n    bus_add_driver+0x171/0x2b0\n    ? unaccepted_memory_init_kdump+0x20/0x20\n    driver_register+0x67/0x100\n    __pci_register_driver+0x83/0x90\n    sp_pci_init+0x22/0x30\n    sp_mod_init+0x13/0x30\n    do_one_initcall+0xb8/0x290\n    ? sched_clock_noinstr+0xd/0x10\n    ? local_clock_noinstr+0x3e/0x100\n    ? stack_depot_save_flags+0x21e/0x6a0\n    ? local_clock+0x1c/0x60\n    ? stack_depot_save_flags+0x21e/0x6a0\n    ? sched_clock_noinstr+0xd/0x10\n    ? local_clock_noinstr+0x3e/0x100\n    ? __lock_acquire+0xd90/0xe30\n    ? sched_clock_noinstr+0xd/0x10\n    ? local_clock_noinstr+0x3e/0x100\n    ? __create_object+0x66/0x100\n    ? local_clock+0x1c/0x60\n    ? __create_object+0x66/0x100\n    ? parameq+0x1b/0x90\n    ? parse_one+0x6d/0x1d0\n    ? parse_args+0xd7/0x1f0\n    ? do_initcall_level+0x180/0x180\n    do_initcall_level+0xb0/0x180\n    do_initcalls+0x60/0xa0\n    ? kernel_init+0x1f/0x1d0\n    do_basic_setup+0x41/0x50\n    kernel_init_freeable+0x1ac/0x230\n    ? rest_init+0x1f0/0x1f0\n    kernel_init+0x1f/0x1d0\n    ? rest_init+0x1f0/0x1f0\n    ret_from_fork+0x3d/0x50\n    ? rest_init+0x1f0/0x1f0\n    ret_from_fork_asm+0x11/0x20\n    </TASK>\n   Modules linked in:\n   CR2: 00000000000000f0\n   ---[ end trace 0000000000000000 ]---\n   RIP: 0010:__sev_snp_shutdown_locked+0x2e/0x150\n   Code: 00 55 48 89 e5 41 57 41 56 41 54 53 48 83 ec 10 41 89 f7 49 89 fe 65 48 8b 04 25 28 00 00 00 48 89 45 d8 48 8b 05 6a 5a 7f 06 <4c> 8b a0 f0 00 00 00 41 0f b6 9c 24 a2 00 00 00 48 83 fb 02 0f 83\n   RSP: 0018:ffffb2ea4014b7b8 EFLAGS: 00010286\n   RAX: 0000000000000000 RBX: ffff9e4acd2e0a28 RCX: 0000000000000000\n   RDX: 0000000\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/468e3295774d0edce15f4ae475913b5076dd4f40"
          },
          {
            "url": "https://git.kernel.org/stable/c/bbf2c94503f6a421ed9b79e300d8085810da765d"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-43875",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-21T01:15:11.910",
        "lastModified": "2024-08-21T01:15:11.910",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nPCI: endpoint: Clean up error handling in vpci_scan_bus()\nSmatch complains about inconsistent NULL checking in vpci_scan_bus():\n    drivers/pci/endpoint/functions/pci-epf-vntb.c:1024 vpci_scan_bus() error: we previously assumed 'vpci_bus' could be null (see line 1021)\nInstead of printing an error message and then crashing we should return\nan error code and clean up.\nAlso the NULL check is reversed so it prints an error for success\ninstead of failure.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0e27e2e8697b8ce96cdef43f135426525d9d1f8f"
          },
          {
            "url": "https://git.kernel.org/stable/c/24414c842a24d0fd498f9db6d2a762a8dddf1832"
          },
          {
            "url": "https://git.kernel.org/stable/c/7d368de78b60088ec9031c60c88976c0063ea4c0"
          },
          {
            "url": "https://git.kernel.org/stable/c/8e0f5a96c534f781e8c57ca30459448b3bfe5429"
          },
          {
            "url": "https://git.kernel.org/stable/c/b9e8695246bcfc028341470cbf92630cdc1ba36b"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-43876",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-21T01:15:11.973",
        "lastModified": "2024-08-21T01:15:11.973",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nPCI: rcar: Demote WARN() to dev_warn_ratelimited() in rcar_pcie_wakeup()\nAvoid large backtrace, it is sufficient to warn the user that there has\nbeen a link problem. Either the link has failed and the system is in need\nof maintenance, or the link continues to work and user has been informed.\nThe message from the warning can be looked up in the sources.\nThis makes an actual link issue less verbose.\nFirst of all, this controller has a limitation in that the controller\ndriver has to assist the hardware with transition to L1 link state by\nwriting L1IATN to PMCTRL register, the L1 and L0 link state switching\nis not fully automatic on this controller.\nIn case of an ASMedia ASM1062 PCIe SATA controller which does not support\nASPM, on entry to suspend or during platform pm_test, the SATA controller\nenters D3hot state and the link enters L1 state. If the SATA controller\nwakes up before rcar_pcie_wakeup() was called and returns to D0, the link\nreturns to L0 before the controller driver even started its transition to\nL1 link state. At this point, the SATA controller did send an PM_ENTER_L1\nDLLP to the PCIe controller and the PCIe controller received it, and the\nPCIe controller did set PMSR PMEL1RX bit.\nOnce rcar_pcie_wakeup() is called, if the link is already back in L0 state\nand PMEL1RX bit is set, the controller driver has no way to determine if\nit should perform the link transition to L1 state, or treat the link as if\nit is in L0 state. Currently the driver attempts to perform the transition\nto L1 link state unconditionally, which in this specific case fails with a\nPMSR L1FAEG poll timeout, however the link still works as it is already\nback in L0 state.\nReduce this warning verbosity. In case the link is really broken, the\nrcar_pcie_config_access() would fail, otherwise it will succeed and any\nsystem with this controller and ASM1062 can suspend without generating\na backtrace.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2ae4769332dfdb97f4b6f5dc9ac8f46d02aaa3df"
          },
          {
            "url": "https://git.kernel.org/stable/c/3ff3bdde950f1840df4030726cef156758a244d7"
          },
          {
            "url": "https://git.kernel.org/stable/c/526a877c6273d4cd0d0aede84c1d620479764b1c"
          },
          {
            "url": "https://git.kernel.org/stable/c/c93637e6a4c4e1d0e85ef7efac78d066bbb24d96"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-43877",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-21T01:15:12.033",
        "lastModified": "2024-08-21T01:15:12.033",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmedia: pci: ivtv: Add check for DMA map result\nIn case DMA fails, 'dma->SG_length' is 0. This value is later used to\naccess 'dma->SGarray[dma->SG_length - 1]', which will cause out of\nbounds access.\nAdd check to return early on invalid value. Adjust warnings accordingly.\nFound by Linux Verification Center (linuxtesting.org) with SVACE.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/24062aa7407091dee3e45a8e8037df437e848718"
          },
          {
            "url": "https://git.kernel.org/stable/c/3d8fd92939e21ff0d45100ab208f8124af79402a"
          },
          {
            "url": "https://git.kernel.org/stable/c/629913d6d79508b166c66e07e4857e20233d85a9"
          },
          {
            "url": "https://git.kernel.org/stable/c/c766065e8272085ea9c436414b7ddf1f12e7787b"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-43878",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-21T01:15:12.093",
        "lastModified": "2024-08-21T01:15:12.093",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nxfrm: Fix input error path memory access\nWhen there is a misconfiguration of input state slow path\nKASAN report error. Fix this error.\nwest login:\n[   52.987278] eth1: renamed from veth11\n[   53.078814] eth1: renamed from veth21\n[   53.181355] eth1: renamed from veth31\n[   54.921702] ==================================================================\n[   54.922602] BUG: KASAN: wild-memory-access in xfrmi_rcv_cb+0x2d/0x295\n[   54.923393] Read of size 8 at addr 6b6b6b6b00000000 by task ping/512\n[   54.924169]\n[   54.924386] CPU: 0 PID: 512 Comm: ping Not tainted 6.9.0-08574-gcd29a4313a1b #25\n[   54.925290] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2 04/01/2014\n[   54.926401] Call Trace:\n[   54.926731]  <IRQ>\n[   54.927009]  dump_stack_lvl+0x2a/0x3b\n[   54.927478]  kasan_report+0x84/0xa6\n[   54.927930]  ? xfrmi_rcv_cb+0x2d/0x295\n[   54.928410]  xfrmi_rcv_cb+0x2d/0x295\n[   54.928872]  ? xfrm4_rcv_cb+0x3d/0x5e\n[   54.929354]  xfrm4_rcv_cb+0x46/0x5e\n[   54.929804]  xfrm_rcv_cb+0x7e/0xa1\n[   54.930240]  xfrm_input+0x1b3a/0x1b96\n[   54.930715]  ? xfrm_offload+0x41/0x41\n[   54.931182]  ? raw_rcv+0x292/0x292\n[   54.931617]  ? nf_conntrack_confirm+0xa2/0xa2\n[   54.932158]  ? skb_sec_path+0xd/0x3f\n[   54.932610]  ? xfrmi_input+0x90/0xce\n[   54.933066]  xfrm4_esp_rcv+0x33/0x54\n[   54.933521]  ip_protocol_deliver_rcu+0xd7/0x1b2\n[   54.934089]  ip_local_deliver_finish+0x110/0x120\n[   54.934659]  ? ip_protocol_deliver_rcu+0x1b2/0x1b2\n[   54.935248]  NF_HOOK.constprop.0+0xf8/0x138\n[   54.935767]  ? ip_sublist_rcv_finish+0x68/0x68\n[   54.936317]  ? secure_tcpv6_ts_off+0x23/0x168\n[   54.936859]  ? ip_protocol_deliver_rcu+0x1b2/0x1b2\n[   54.937454]  ? __xfrm_policy_check2.constprop.0+0x18d/0x18d\n[   54.938135]  NF_HOOK.constprop.0+0xf8/0x138\n[   54.938663]  ? ip_sublist_rcv_finish+0x68/0x68\n[   54.939220]  ? __xfrm_policy_check2.constprop.0+0x18d/0x18d\n[   54.939904]  ? ip_local_deliver_finish+0x120/0x120\n[   54.940497]  __netif_receive_skb_one_core+0xc9/0x107\n[   54.941121]  ? __netif_receive_skb_list_core+0x1c2/0x1c2\n[   54.941771]  ? blk_mq_start_stopped_hw_queues+0xc7/0xf9\n[   54.942413]  ? blk_mq_start_stopped_hw_queue+0x38/0x38\n[   54.943044]  ? virtqueue_get_buf_ctx+0x295/0x46b\n[   54.943618]  process_backlog+0xb3/0x187\n[   54.944102]  __napi_poll.constprop.0+0x57/0x1a7\n[   54.944669]  net_rx_action+0x1cb/0x380\n[   54.945150]  ? __napi_poll.constprop.0+0x1a7/0x1a7\n[   54.945744]  ? vring_new_virtqueue+0x17a/0x17a\n[   54.946300]  ? note_interrupt+0x2cd/0x367\n[   54.946805]  handle_softirqs+0x13c/0x2c9\n[   54.947300]  do_softirq+0x5f/0x7d\n[   54.947727]  </IRQ>\n[   54.948014]  <TASK>\n[   54.948300]  __local_bh_enable_ip+0x48/0x62\n[   54.948832]  __neigh_event_send+0x3fd/0x4ca\n[   54.949361]  neigh_resolve_output+0x1e/0x210\n[   54.949896]  ip_finish_output2+0x4bf/0x4f0\n[   54.950410]  ? __ip_finish_output+0x171/0x1b8\n[   54.950956]  ip_send_skb+0x25/0x57\n[   54.951390]  raw_sendmsg+0xf95/0x10c0\n[   54.951850]  ? check_new_pages+0x45/0x71\n[   54.952343]  ? raw_hash_sk+0x21b/0x21b\n[   54.952815]  ? kernel_init_pages+0x42/0x51\n[   54.953337]  ? prep_new_page+0x44/0x51\n[   54.953811]  ? get_page_from_freelist+0x72b/0x915\n[   54.954390]  ? signal_pending_state+0x77/0x77\n[   54.954936]  ? preempt_count_sub+0x14/0xb3\n[   54.955450]  ? __might_resched+0x8a/0x240\n[   54.955951]  ? __might_sleep+0x25/0xa0\n[   54.956424]  ? first_zones_zonelist+0x2c/0x43\n[   54.956977]  ? __rcu_read_lock+0x2d/0x3a\n[   54.957476]  ? __pte_offset_map+0x32/0xa4\n[   54.957980]  ? __might_resched+0x8a/0x240\n[   54.958483]  ? __might_sleep+0x25/0xa0\n[   54.958963]  ? inet_send_prepare+0x54/0x54\n[   54.959478]  ? sock_sendmsg_nosec+0x42/0x6c\n[   54.960000]  sock_sendmsg_nosec+0x42/0x6c\n[   54.960502]  __sys_sendto+0x15d/0x1cc\n[   54.960966]  ? __x64_sys_getpeername+0x44/0x44\n[   54.961522]  ? __handle_mm_fault+0x679/0xae4\n[   54.962068]  ? find_vma+0x6b/0x\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/54fcc6189dfb822eea984fa2b3e477a02447279d"
          },
          {
            "url": "https://git.kernel.org/stable/c/a4c10813bc394ff2b5c61f913971be216f8f8834"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-43879",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-21T01:15:12.153",
        "lastModified": "2024-08-21T01:15:12.153",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nwifi: cfg80211: handle 2x996 RU allocation in cfg80211_calculate_bitrate_he()\nCurrently NL80211_RATE_INFO_HE_RU_ALLOC_2x996 is not handled in\ncfg80211_calculate_bitrate_he(), leading to below warning:\nkernel: invalid HE MCS: bw:6, ru:6\nkernel: WARNING: CPU: 0 PID: 2312 at net/wireless/util.c:1501 cfg80211_calculate_bitrate_he+0x22b/0x270 [cfg80211]\nFix it by handling 2x996 RU allocation in the same way as 160 MHz bandwidth.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/16ad67e73309db0c20cc2a651992bd01c05e6b27"
          },
          {
            "url": "https://git.kernel.org/stable/c/19eaf4f2f5a981f55a265242ada2bf92b0c742dd"
          },
          {
            "url": "https://git.kernel.org/stable/c/2e201b3d162c6c49417c438ffb30b58c9f85769f"
          },
          {
            "url": "https://git.kernel.org/stable/c/45d20a1c54be4f3173862c7b950d4468447814c9"
          },
          {
            "url": "https://git.kernel.org/stable/c/576c64622649f3ec07e97bac8fec8b8a2ef4d086"
          },
          {
            "url": "https://git.kernel.org/stable/c/67b5f1054197e4f5553047759c15c1d67d4c8142"
          },
          {
            "url": "https://git.kernel.org/stable/c/b289ebb0516526cb4abae081b7ec29fd4fa1209d"
          },
          {
            "url": "https://git.kernel.org/stable/c/bcbd771cd5d68c0c52567556097d75f9fc4e7cd6"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-43880",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-21T01:15:12.213",
        "lastModified": "2024-08-21T01:15:12.213",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmlxsw: spectrum_acl_erp: Fix object nesting warning\nACLs in Spectrum-2 and newer ASICs can reside in the algorithmic TCAM\n(A-TCAM) or in the ordinary circuit TCAM (C-TCAM). The former can\ncontain more ACLs (i.e., tc filters), but the number of masks in each\nregion (i.e., tc chain) is limited.\nIn order to mitigate the effects of the above limitation, the device\nallows filters to share a single mask if their masks only differ in up\nto 8 consecutive bits. For example, dst_ip/25 can be represented using\ndst_ip/24 with a delta of 1 bit. The C-TCAM does not have a limit on the\nnumber of masks being used (and therefore does not support mask\naggregation), but can contain a limited number of filters.\nThe driver uses the \"objagg\" library to perform the mask aggregation by\npassing it objects that consist of the filter's mask and whether the\nfilter is to be inserted into the A-TCAM or the C-TCAM since filters in\ndifferent TCAMs cannot share a mask.\nThe set of created objects is dependent on the insertion order of the\nfilters and is not necessarily optimal. Therefore, the driver will\nperiodically ask the library to compute a more optimal set (\"hints\") by\nlooking at all the existing objects.\nWhen the library asks the driver whether two objects can be aggregated\nthe driver only compares the provided masks and ignores the A-TCAM /\nC-TCAM indication. This is the right thing to do since the goal is to\nmove as many filters as possible to the A-TCAM. The driver also forbids\ntwo identical masks from being aggregated since this can only happen if\none was intentionally put in the C-TCAM to avoid a conflict in the\nA-TCAM.\nThe above can result in the following set of hints:\nH1: {mask X, A-TCAM} -> H2: {mask Y, A-TCAM} // X is Y + delta\nH3: {mask Y, C-TCAM} -> H4: {mask Z, A-TCAM} // Y is Z + delta\nAfter getting the hints from the library the driver will start migrating\nfilters from one region to another while consulting the computed hints\nand instructing the device to perform a lookup in both regions during\nthe transition.\nAssuming a filter with mask X is being migrated into the A-TCAM in the\nnew region, the hints lookup will return H1. Since H2 is the parent of\nH1, the library will try to find the object associated with it and\ncreate it if necessary in which case another hints lookup (recursive)\nwill be performed. This hints lookup for {mask Y, A-TCAM} will either\nreturn H2 or H3 since the driver passes the library an object comparison\nfunction that ignores the A-TCAM / C-TCAM indication.\nThis can eventually lead to nested objects which are not supported by\nthe library [1].\nFix by removing the object comparison function from both the driver and\nthe library as the driver was the only user. That way the lookup will\nonly return exact matches.\nI do not have a reliable reproducer that can reproduce the issue in a\ntimely manner, but before the fix the issue would reproduce in several\nminutes and with the fix it does not reproduce in over an hour.\nNote that the current usefulness of the hints is limited because they\ninclude the C-TCAM indication and represent aggregation that cannot\nactually happen. This will be addressed in net-next.\n[1]\nWARNING: CPU: 0 PID: 153 at lib/objagg.c:170 objagg_obj_parent_assign+0xb5/0xd0\nModules linked in:\nCPU: 0 PID: 153 Comm: kworker/0:18 Not tainted 6.9.0-rc6-custom-g70fbc2c1c38b #42\nHardware name: Mellanox Technologies Ltd. MSN3700C/VMOD0008, BIOS 5.11 10/10/2018\nWorkqueue: mlxsw_core mlxsw_sp_acl_tcam_vregion_rehash_work\nRIP: 0010:objagg_obj_parent_assign+0xb5/0xd0\n[...]\nCall Trace:\n <TASK>\n __objagg_obj_get+0x2bb/0x580\n objagg_obj_get+0xe/0x80\n mlxsw_sp_acl_erp_mask_get+0xb5/0xf0\n mlxsw_sp_acl_atcam_entry_add+0xe8/0x3c0\n mlxsw_sp_acl_tcam_entry_create+0x5e/0xa0\n mlxsw_sp_acl_tcam_vchunk_migrate_one+0x16b/0x270\n mlxsw_sp_acl_tcam_vregion_rehash_work+0xbe/0x510\n process_one_work+0x151/0x370",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0e59c2d22853266704e127915653598f7f104037"
          },
          {
            "url": "https://git.kernel.org/stable/c/25c6fd9648ad05da493a5d30881896a78a08b624"
          },
          {
            "url": "https://git.kernel.org/stable/c/36a9996e020dd5aa325e0ecc55eb2328288ea6bb"
          },
          {
            "url": "https://git.kernel.org/stable/c/4dc09f6f260db3c4565a4ec52ba369393598f2fb"
          },
          {
            "url": "https://git.kernel.org/stable/c/97d833ceb27dc19f8777d63f90be4a27b5daeedf"
          },
          {
            "url": "https://git.kernel.org/stable/c/9a5261a984bba4f583d966c550fa72c33ff3714e"
          },
          {
            "url": "https://git.kernel.org/stable/c/fb5d4fc578e655d113f09565f6f047e15f7ab578"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-43881",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-21T01:15:12.280",
        "lastModified": "2024-08-21T01:15:12.280",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nwifi: ath12k: change DMA direction while mapping reinjected packets\nFor fragmented packets, ath12k reassembles each fragment as a normal\npacket and then reinjects it into HW ring. In this case, the DMA\ndirection should be DMA_TO_DEVICE, not DMA_FROM_DEVICE. Otherwise,\nan invalid payload may be reinjected into the HW and\nsubsequently delivered to the host.\nGiven that arbitrary memory can be allocated to the skb buffer,\nknowledge about the data contained in the reinjected buffer is lacking.\nConsequently, thereâ€™s a risk of private information being leaked.\nTested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.1.1-00209-QCAHKSWPL_SILICONZ-1",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/33322e3ef07409278a18c6919c448e369d66a18e"
          },
          {
            "url": "https://git.kernel.org/stable/c/6925320fcd40d8042d32bf4ede8248e7a5315c3b"
          },
          {
            "url": "https://git.kernel.org/stable/c/e99d9b16ff153de9540073239d24adc3b0a3a997"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-43882",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-21T01:15:12.340",
        "lastModified": "2024-08-21T01:15:12.340",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nexec: Fix ToCToU between perm check and set-uid/gid usage\nWhen opening a file for exec via do_filp_open(), permission checking is\ndone against the file's metadata at that moment, and on success, a file\npointer is passed back. Much later in the execve() code path, the file\nmetadata (specifically mode, uid, and gid) is used to determine if/how\nto set the uid and gid. However, those values may have changed since the\npermissions check, meaning the execution may gain unintended privileges.\nFor example, if a file could change permissions from executable and not\nset-id:\n---------x 1 root root 16048 Aug  7 13:16 target\nto set-id and non-executable:\n---S------ 1 root root 16048 Aug  7 13:16 target\nit is possible to gain root privileges when execution should have been\ndisallowed.\nWhile this race condition is rare in real-world scenarios, it has been\nobserved (and proven exploitable) when package managers are updating\nthe setuid bits of installed programs. Such files start with being\nworld-executable but then are adjusted to be group-exec with a set-uid\nbit. For example, \"chmod o-x,u+s target\" makes \"target\" executable only\nby uid \"root\" and gid \"cdrom\", while also becoming setuid-root:\n-rwxr-xr-x 1 root cdrom 16048 Aug  7 13:16 target\nbecomes:\n-rwsr-xr-- 1 root cdrom 16048 Aug  7 13:16 target\nBut racing the chmod means users without group \"cdrom\" membership can\nget the permission to execute \"target\" just before the chmod, and when\nthe chmod finishes, the exec reaches brpm_fill_uid(), and performs the\nsetuid to root, violating the expressed authorization of \"only cdrom\ngroup members can setuid to root\".\nRe-check that we still have execute permissions in case the metadata\nhas changed. It would be better to keep a copy from the perm-check time,\nbut until we can do that refactoring, the least-bad option is to do a\nfull inode_permission() call (under inode lock). It is understood that\nthis is safe against dead-locks, but hardly optimal.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/15469d46ba34559bfe7e3de6659115778c624759"
          },
          {
            "url": "https://git.kernel.org/stable/c/368f6985d46657b8b466a421dddcacd4051f7ada"
          },
          {
            "url": "https://git.kernel.org/stable/c/90dfbba89ad4f0d9c9744ecbb1adac4aa2ff4f3e"
          },
          {
            "url": "https://git.kernel.org/stable/c/9b424c5d4130d56312e2a3be17efb0928fec4d64"
          },
          {
            "url": "https://git.kernel.org/stable/c/d2a2a4714d80d09b0f8eb6438ab4224690b7121e"
          },
          {
            "url": "https://git.kernel.org/stable/c/d5c3c7e26275a2d83b894d30f7582a42853a958f"
          },
          {
            "url": "https://git.kernel.org/stable/c/f50733b45d865f91db90919f8311e2127ce5a0cb"
          },
          {
            "url": "https://git.kernel.org/stable/c/f6cfc6bcfd5e1cf76115b6450516ea4c99897ae1"
          }
        ]
      }
    }
  ]
}