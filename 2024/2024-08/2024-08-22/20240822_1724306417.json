{
  "totalResults": 24,
  "datePublished": "2024-08-22T15:00:17.100737Z",
  "vulnerabilities": [
    {
      "cve": {
        "id": "CVE-2022-48926",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-22T04:15:15.363",
        "lastModified": "2024-08-22T12:48:02.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nusb: gadget: rndis: add spinlock for rndis response list\nThere's no lock for rndis response list. It could cause list corruption\nif there're two different list_add at the same time like below.\nIt's better to add in rndis_add_response / rndis_free_response\n/ rndis_get_next_response to prevent any race condition on response list.\n[  361.894299] [1:   irq/191-dwc3:16979] list_add corruption.\nnext->prev should be prev (ffffff80651764d0),\nbut was ffffff883dc36f80. (next=ffffff80651764d0).\n[  361.904380] [1:   irq/191-dwc3:16979] Call trace:\n[  361.904391] [1:   irq/191-dwc3:16979]  __list_add_valid+0x74/0x90\n[  361.904401] [1:   irq/191-dwc3:16979]  rndis_msg_parser+0x168/0x8c0\n[  361.904409] [1:   irq/191-dwc3:16979]  rndis_command_complete+0x24/0x84\n[  361.904417] [1:   irq/191-dwc3:16979]  usb_gadget_giveback_request+0x20/0xe4\n[  361.904426] [1:   irq/191-dwc3:16979]  dwc3_gadget_giveback+0x44/0x60\n[  361.904434] [1:   irq/191-dwc3:16979]  dwc3_ep0_complete_data+0x1e8/0x3a0\n[  361.904442] [1:   irq/191-dwc3:16979]  dwc3_ep0_interrupt+0x29c/0x3dc\n[  361.904450] [1:   irq/191-dwc3:16979]  dwc3_process_event_entry+0x78/0x6cc\n[  361.904457] [1:   irq/191-dwc3:16979]  dwc3_process_event_buf+0xa0/0x1ec\n[  361.904465] [1:   irq/191-dwc3:16979]  dwc3_thread_interrupt+0x34/0x5c",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/33222d1571d7ce8c1c75f6b488f38968fa93d2d9"
          },
          {
            "url": "https://git.kernel.org/stable/c/4ce247af3f30078d5b97554f1ae6200a0222c15a"
          },
          {
            "url": "https://git.kernel.org/stable/c/669c2b178956718407af5631ccbc61c24413f038"
          },
          {
            "url": "https://git.kernel.org/stable/c/9ab652d41deab49848673c3dadb57ad338485376"
          },
          {
            "url": "https://git.kernel.org/stable/c/9f5d8ba538ef81cd86ea587ca3f8c77e26bea405"
          },
          {
            "url": "https://git.kernel.org/stable/c/9f688aadede6b862a0a898792b1a35421c93636f"
          },
          {
            "url": "https://git.kernel.org/stable/c/aaaba1c86d04dac8e49bf508b492f81506257da3"
          },
          {
            "url": "https://git.kernel.org/stable/c/da514063440b53a27309a4528b726f92c3cfe56f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48927",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-22T04:15:15.530",
        "lastModified": "2024-08-22T12:48:02.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\niio: adc: tsc2046: fix memory corruption by preventing array overflow\nOn one side we have indio_dev->num_channels includes all physical channels +\ntimestamp channel. On other side we have an array allocated only for\nphysical channels. So, fix memory corruption by ARRAY_SIZE() instead of\nnum_channels variable.\nNote the first case is a cleanup rather than a fix as the software\ntimestamp channel bit in active_scanmask is never set by the IIO core.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/082d2c047b0d305bb0b6e9f9d671a09470e2db2d"
          },
          {
            "url": "https://git.kernel.org/stable/c/0cb9b2f73c182d242a640e512f4785c7c504512f"
          },
          {
            "url": "https://git.kernel.org/stable/c/b7a78a8adaa8849c02f174d707aead0f85dca0da"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48928",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-22T04:15:15.677",
        "lastModified": "2024-08-22T12:48:02.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\niio: adc: men_z188_adc: Fix a resource leak in an error handling path\nIf iio_device_register() fails, a previous ioremap() is left unbalanced.\nUpdate the error handling path and add the missing iounmap() call, as\nalready done in the remove function.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0f88722313645a903f4d420ba61ddc690ec2481d"
          },
          {
            "url": "https://git.kernel.org/stable/c/1aa12ecfdcbafebc218910ec47acf6262e600cf5"
          },
          {
            "url": "https://git.kernel.org/stable/c/53d43a9c8dd224e66559fe86af1e473802c7130e"
          },
          {
            "url": "https://git.kernel.org/stable/c/c5723b422f564af15f2e3bc0592fd6376a0a6c45"
          },
          {
            "url": "https://git.kernel.org/stable/c/ce1076b33e299dc8d270e4450a420a18bfb3e190"
          },
          {
            "url": "https://git.kernel.org/stable/c/d6ed5426a7fad36cf928c244483ba24e72359638"
          },
          {
            "url": "https://git.kernel.org/stable/c/e0a2e37f303828d030a83f33ffe14b36cb88d563"
          },
          {
            "url": "https://git.kernel.org/stable/c/fe73477802981bd0d0d70f2b22f109bcca801bdb"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48929",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-22T04:15:15.773",
        "lastModified": "2024-08-22T12:48:02.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbpf: Fix crash due to out of bounds access into reg2btf_ids.\nWhen commit e6ac2450d6de (\"bpf: Support bpf program calling kernel function\") added\nkfunc support, it defined reg2btf_ids as a cheap way to translate the verifier\nreg type to the appropriate btf_vmlinux BTF ID, however\ncommit c25b2ae13603 (\"bpf: Replace PTR_TO_XXX_OR_NULL with PTR_TO_XXX | PTR_MAYBE_NULL\")\nmoved the __BPF_REG_TYPE_MAX from the last member of bpf_reg_type enum to after\nthe base register types, and defined other variants using type flag\ncomposition. However, now, the direct usage of reg->type to index into\nreg2btf_ids may no longer fall into __BPF_REG_TYPE_MAX range, and hence lead to\nout of bounds access and kernel crash on dereference of bad pointer.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/45ce4b4f9009102cd9f581196d480a59208690c1"
          },
          {
            "url": "https://git.kernel.org/stable/c/8c39925e98d498b9531343066ef82ae39e41adae"
          },
          {
            "url": "https://git.kernel.org/stable/c/f0ce1bc9e0235dd7412240be493d7ea65ed9eadc"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48930",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-22T04:15:15.870",
        "lastModified": "2024-08-22T12:48:02.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nRDMA/ib_srp: Fix a deadlock\nRemove the flush_workqueue(system_long_wq) call since flushing\nsystem_long_wq is deadlock-prone and since that call is redundant with a\npreceding cancel_work_sync()",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/081bdc9fe05bb23248f5effb6f811da3da4b8252"
          },
          {
            "url": "https://git.kernel.org/stable/c/4752fafb461821f8c8581090c923ababba68c5bd"
          },
          {
            "url": "https://git.kernel.org/stable/c/8cc342508f9e7fdccd2e9758ae9d52aff72dab7f"
          },
          {
            "url": "https://git.kernel.org/stable/c/901206f71e6ad2b2e7accefc5199a438d173c25f"
          },
          {
            "url": "https://git.kernel.org/stable/c/98d056603ce55ceb90631b3927151c190dfb1b27"
          },
          {
            "url": "https://git.kernel.org/stable/c/99eb8d694174c777558dc902d575d1997d5ca650"
          },
          {
            "url": "https://git.kernel.org/stable/c/c8b56e51aa91b8e7df3a98388dce3fdabd15c1d4"
          },
          {
            "url": "https://git.kernel.org/stable/c/d7997d19dfa7001ca41e971cd9efd091bb195b51"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48931",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-22T04:15:16.010",
        "lastModified": "2024-08-22T12:48:02.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nconfigfs: fix a race in configfs_{,un}register_subsystem()\nWhen configfs_register_subsystem() or configfs_unregister_subsystem()\nis executing link_group() or unlink_group(),\nit is possible that two processes add or delete list concurrently.\nSome unfortunate interleavings of them can cause kernel panic.\nOne of cases is:\nA --> B --> C --> D\nA <-- B <-- C <-- D\n     delete list_head *B        |      delete list_head *C\n--------------------------------|-----------------------------------\nconfigfs_unregister_subsystem   |   configfs_unregister_subsystem\n  unlink_group                  |     unlink_group\n    unlink_obj                  |       unlink_obj\n      list_del_init             |         list_del_init\n        __list_del_entry        |           __list_del_entry\n          __list_del            |             __list_del\n            // next == C        |\n            next->prev = prev   |\n                                |               next->prev = prev\n            prev->next = next   |\n                                |                 // prev == B\n                                |                 prev->next = next\nFix this by adding mutex when calling link_group() or unlink_group(),\nbut parent configfs_subsystem is NULL when config_item is root.\nSo I create a mutex configfs_subsystem_mutex.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3aadfd46858b1f64d4d6a0654b863e21aabff975"
          },
          {
            "url": "https://git.kernel.org/stable/c/40805099af11f68c5ca7dbcfacf455da8f99f622"
          },
          {
            "url": "https://git.kernel.org/stable/c/84ec758fb2daa236026506868c8796b0500c047d"
          },
          {
            "url": "https://git.kernel.org/stable/c/a37024f7757c25550accdebf49e497ad6ae239fe"
          },
          {
            "url": "https://git.kernel.org/stable/c/a7ab53d3c27dfe83bb594456b9f38a37796ec39b"
          },
          {
            "url": "https://git.kernel.org/stable/c/b7e2b91fcb5c78c414e33dc8d50642e307ca0c5a"
          },
          {
            "url": "https://git.kernel.org/stable/c/d1654de19d42f513b6cfe955cc77e7f427e05a77"
          },
          {
            "url": "https://git.kernel.org/stable/c/e7a66dd2687758718eddd79b542a95cf3aa488cc"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48932",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-22T04:15:16.087",
        "lastModified": "2024-08-22T12:48:02.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/mlx5: DR, Fix slab-out-of-bounds in mlx5_cmd_dr_create_fte\nWhen adding a rule with 32 destinations, we hit the following out-of-band\naccess issue:\n  BUG: KASAN: slab-out-of-bounds in mlx5_cmd_dr_create_fte+0x18ee/0x1e70\nThis patch fixes the issue by both increasing the allocated buffers to\naccommodate for the needed actions and by checking the number of actions\nto prevent this issue when a rule with too many actions is provided.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0aec12d97b2036af0946e3d582144739860ac07b"
          },
          {
            "url": "https://git.kernel.org/stable/c/4ad319cdfbe555b4ff67bc608736c46a6930c848"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48933",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-22T04:15:16.143",
        "lastModified": "2024-08-22T12:48:02.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnetfilter: nf_tables: fix memory leak during stateful obj update\nstateful objects can be updated from the control plane.\nThe transaction logic allocates a temporary object for this purpose.\nThe ->init function was called for this object, so plain kfree() leaks\nresources. We must call ->destroy function of the object.\nnft_obj_destroy does this, but it also decrements the module refcount,\nbut the update path doesn't increment it.\nTo avoid special-casing the update object release, do module_get for\nthe update case too and release it via nft_obj_destroy().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/34bb90e407e3288f610558beaae54ecaa32b11c4"
          },
          {
            "url": "https://git.kernel.org/stable/c/53026346a94c43f35c32b18804041bc483271d87"
          },
          {
            "url": "https://git.kernel.org/stable/c/7e9880e81d3fd6a43c202f205717485290432826"
          },
          {
            "url": "https://git.kernel.org/stable/c/dad3bdeef45f81a6e90204bcc85360bb76eccec7"
          },
          {
            "url": "https://git.kernel.org/stable/c/e96e204ee6fa46702f6c94c3c69a09e69e0eac52"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48934",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-22T04:15:16.357",
        "lastModified": "2024-08-22T12:48:02.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnfp: flower: Fix a potential leak in nfp_tunnel_add_shared_mac()\nida_simple_get() returns an id between min (0) and max (NFP_MAX_MAC_INDEX)\ninclusive.\nSo NFP_MAX_MAC_INDEX (0xff) is a valid id.\nIn order for the error handling path to work correctly, the 'invalid'\nvalue for 'ida_idx' should not be in the 0..NFP_MAX_MAC_INDEX range,\ninclusive.\nSo set it to -1.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3a14d0888eb4b0045884126acc69abfb7b87814d"
          },
          {
            "url": "https://git.kernel.org/stable/c/4086d2433576baf85f0e538511df97c8101e0a10"
          },
          {
            "url": "https://git.kernel.org/stable/c/5ad5886f85b6bd893e3ed19013765fb0c243c069"
          },
          {
            "url": "https://git.kernel.org/stable/c/9d8097caa73200710d52b9f4d9f430548f46a900"
          },
          {
            "url": "https://git.kernel.org/stable/c/af4bc921d39dffdb83076e0a7eed1321242b7d87"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48935",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-22T04:15:16.877",
        "lastModified": "2024-08-22T12:48:02.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnetfilter: nf_tables: unregister flowtable hooks on netns exit\nUnregister flowtable hooks before they are releases via\nnf_tables_flowtable_destroy() otherwise hook core reports UAF.\nBUG: KASAN: use-after-free in nf_hook_entries_grow+0x5a7/0x700 net/netfilter/core.c:142 net/netfilter/core.c:142\nRead of size 4 at addr ffff8880736f7438 by task syz-executor579/3666\nCPU: 0 PID: 3666 Comm: syz-executor579 Not tainted 5.16.0-rc5-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n __dump_stack lib/dump_stack.c:88 [inline] lib/dump_stack.c:106\n dump_stack_lvl+0x1dc/0x2d8 lib/dump_stack.c:106 lib/dump_stack.c:106\n print_address_description+0x65/0x380 mm/kasan/report.c:247 mm/kasan/report.c:247\n __kasan_report mm/kasan/report.c:433 [inline]\n __kasan_report mm/kasan/report.c:433 [inline] mm/kasan/report.c:450\n kasan_report+0x19a/0x1f0 mm/kasan/report.c:450 mm/kasan/report.c:450\n nf_hook_entries_grow+0x5a7/0x700 net/netfilter/core.c:142 net/netfilter/core.c:142\n __nf_register_net_hook+0x27e/0x8d0 net/netfilter/core.c:429 net/netfilter/core.c:429\n nf_register_net_hook+0xaa/0x180 net/netfilter/core.c:571 net/netfilter/core.c:571\n nft_register_flowtable_net_hooks+0x3c5/0x730 net/netfilter/nf_tables_api.c:7232 net/netfilter/nf_tables_api.c:7232\n nf_tables_newflowtable+0x2022/0x2cf0 net/netfilter/nf_tables_api.c:7430 net/netfilter/nf_tables_api.c:7430\n nfnetlink_rcv_batch net/netfilter/nfnetlink.c:513 [inline]\n nfnetlink_rcv_skb_batch net/netfilter/nfnetlink.c:634 [inline]\n nfnetlink_rcv_batch net/netfilter/nfnetlink.c:513 [inline] net/netfilter/nfnetlink.c:652\n nfnetlink_rcv_skb_batch net/netfilter/nfnetlink.c:634 [inline] net/netfilter/nfnetlink.c:652\n nfnetlink_rcv+0x10e6/0x2550 net/netfilter/nfnetlink.c:652 net/netfilter/nfnetlink.c:652\n__nft_release_hook() calls nft_unregister_flowtable_net_hooks() which\nonly unregisters the hooks, then after RCU grace period, it is\nguaranteed that no packets add new entries to the flowtable (no flow\noffload rules and flowtable hooks are reachable from packet path), so it\nis safe to call nf_flow_table_free() which cleans up the remaining\nentries from the flowtable (both software and hardware) and it unbinds\nthe flow_block.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/6069da443bf65f513bb507bb21e2f87cfb1ad0b6"
          },
          {
            "url": "https://git.kernel.org/stable/c/88c795491bf45a8c08a0f94c9ca4f13722e51013"
          },
          {
            "url": "https://git.kernel.org/stable/c/8ffb8ac3448845f65634889b051bd65e4dee484b"
          },
          {
            "url": "https://git.kernel.org/stable/c/b05a24cc453e3cd51b0c79e3c583b5d495eba1d6"
          },
          {
            "url": "https://git.kernel.org/stable/c/b4fcc081e527aa2ce12e956912fc47e251f6bd27"
          },
          {
            "url": "https://git.kernel.org/stable/c/e51f30826bc5384801df98d76109c94953d1df64"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48936",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-22T04:15:16.950",
        "lastModified": "2024-08-22T12:48:02.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ngso: do not skip outer ip header in case of ipip and net_failover\nWe encounter a tcp drop issue in our cloud environment. Packet GROed in\nhost forwards to a VM virtio_net nic with net_failover enabled. VM acts\nas a IPVS LB with ipip encapsulation. The full path like:\nhost gro -> vm virtio_net rx -> net_failover rx -> ipvs fullnat\n -> ipip encap -> net_failover tx -> virtio_net tx\nWhen net_failover transmits a ipip pkt (gso_type = 0x0103, which means\nSKB_GSO_TCPV4, SKB_GSO_DODGY and SKB_GSO_IPXIP4), there is no gso\ndid because it supports TSO and GSO_IPXIP4. But network_header points to\ninner ip header.\nCall Trace:\n tcp4_gso_segment        ------> return NULL\n inet_gso_segment        ------> inner iph, network_header points to\n ipip_gso_segment\n inet_gso_segment        ------> outer iph\n skb_mac_gso_segment\nAfterwards virtio_net transmits the pkt, only inner ip header is modified.\nAnd the outer one just keeps unchanged. The pkt will be dropped in remote\nhost.\nCall Trace:\n inet_gso_segment        ------> inner iph, outer iph is skipped\n skb_mac_gso_segment\n __skb_gso_segment\n validate_xmit_skb\n validate_xmit_skb_list\n sch_direct_xmit\n __qdisc_run\n __dev_queue_xmit        ------> virtio_net\n dev_hard_start_xmit\n __dev_queue_xmit        ------> net_failover\n ip_finish_output2\n ip_output\n iptunnel_xmit\n ip_tunnel_xmit\n ipip_tunnel_xmit        ------> ipip\n dev_hard_start_xmit\n __dev_queue_xmit\n ip_finish_output2\n ip_output\n ip_forward\n ip_rcv\n __netif_receive_skb_one_core\n netif_receive_skb_internal\n napi_gro_receive\n receive_buf\n virtnet_poll\n net_rx_action\nThe root cause of this issue is specific with the rare combination of\nSKB_GSO_DODGY and a tunnel device that adds an SKB_GSO_ tunnel option.\nSKB_GSO_DODGY is set from external virtio_net. We need to reset network\nheader when callbacks.gso_segment() returns NULL.\nThis patch also includes ipv6_gso_segment(), considering SIT, etc.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2b3cdd70ea5f5a694f95ea1788393fb3b83071ea"
          },
          {
            "url": "https://git.kernel.org/stable/c/45d006c2c7ed7baf1fa258fa7b5bc9923d3a983e"
          },
          {
            "url": "https://git.kernel.org/stable/c/7840e559799a08a8588ee6de27516a991cb2e5e7"
          },
          {
            "url": "https://git.kernel.org/stable/c/899e56a1ad435261812355550ae869d8be3df395"
          },
          {
            "url": "https://git.kernel.org/stable/c/a739963f43269297c3f438b776194542e2a97499"
          },
          {
            "url": "https://git.kernel.org/stable/c/cc20cced0598d9a5ff91ae4ab147b3b5e99ee819"
          },
          {
            "url": "https://git.kernel.org/stable/c/dac2490d9ee0b89dffc72f1172b8bbeb60eaec39"
          },
          {
            "url": "https://git.kernel.org/stable/c/e9ffbe63f6f32f526a461756309b61c395168d73"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48937",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-22T04:15:17.137",
        "lastModified": "2024-08-22T12:48:02.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nio_uring: add a schedule point in io_add_buffers()\nLooping ~65535 times doing kmalloc() calls can trigger soft lockups,\nespecially with DEBUG features (like KASAN).\n[  253.536212] watchdog: BUG: soft lockup - CPU#64 stuck for 26s! [b219417889:12575]\n[  253.544433] Modules linked in: vfat fat i2c_mux_pca954x i2c_mux spidev cdc_acm xhci_pci xhci_hcd sha3_generic gq(O)\n[  253.544451] CPU: 64 PID: 12575 Comm: b219417889 Tainted: G S         O      5.17.0-smp-DEV #801\n[  253.544457] RIP: 0010:kernel_text_address (./include/asm-generic/sections.h:192 ./include/linux/kallsyms.h:29 kernel/extable.c:67 kernel/extable.c:98)\n[  253.544464] Code: 0f 93 c0 48 c7 c1 e0 63 d7 a4 48 39 cb 0f 92 c1 20 c1 0f b6 c1 5b 5d c3 90 0f 1f 44 00 00 55 48 89 e5 41 57 41 56 53 48 89 fb <48> c7 c0 00 00 80 a0 41 be 01 00 00 00 48 39 c7 72 0c 48 c7 c0 40\n[  253.544468] RSP: 0018:ffff8882d8baf4c0 EFLAGS: 00000246\n[  253.544471] RAX: 1ffff1105b175e00 RBX: ffffffffa13ef09a RCX: 00000000a13ef001\n[  253.544474] RDX: ffffffffa13ef09a RSI: ffff8882d8baf558 RDI: ffffffffa13ef09a\n[  253.544476] RBP: ffff8882d8baf4d8 R08: ffff8882d8baf5e0 R09: 0000000000000004\n[  253.544479] R10: ffff8882d8baf5e8 R11: ffffffffa0d59a50 R12: ffff8882eab20380\n[  253.544481] R13: ffffffffa0d59a50 R14: dffffc0000000000 R15: 1ffff1105b175eb0\n[  253.544483] FS:  00000000016d3380(0000) GS:ffff88af48c00000(0000) knlGS:0000000000000000\n[  253.544486] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  253.544488] CR2: 00000000004af0f0 CR3: 00000002eabfa004 CR4: 00000000003706e0\n[  253.544491] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  253.544492] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  253.544494] Call Trace:\n[  253.544496]  <TASK>\n[  253.544498] ? io_queue_sqe (fs/io_uring.c:7143)\n[  253.544505] __kernel_text_address (kernel/extable.c:78)\n[  253.544508] unwind_get_return_address (arch/x86/kernel/unwind_frame.c:19)\n[  253.544514] arch_stack_walk (arch/x86/kernel/stacktrace.c:27)\n[  253.544517] ? io_queue_sqe (fs/io_uring.c:7143)\n[  253.544521] stack_trace_save (kernel/stacktrace.c:123)\n[  253.544527] ____kasan_kmalloc (mm/kasan/common.c:39 mm/kasan/common.c:45 mm/kasan/common.c:436 mm/kasan/common.c:515)\n[  253.544531] ? ____kasan_kmalloc (mm/kasan/common.c:39 mm/kasan/common.c:45 mm/kasan/common.c:436 mm/kasan/common.c:515)\n[  253.544533] ? __kasan_kmalloc (mm/kasan/common.c:524)\n[  253.544535] ? kmem_cache_alloc_trace (./include/linux/kasan.h:270 mm/slab.c:3567)\n[  253.544541] ? io_issue_sqe (fs/io_uring.c:4556 fs/io_uring.c:4589 fs/io_uring.c:6828)\n[  253.544544] ? __io_queue_sqe (fs/io_uring.c:?)\n[  253.544551] __kasan_kmalloc (mm/kasan/common.c:524)\n[  253.544553] kmem_cache_alloc_trace (./include/linux/kasan.h:270 mm/slab.c:3567)\n[  253.544556] ? io_issue_sqe (fs/io_uring.c:4556 fs/io_uring.c:4589 fs/io_uring.c:6828)\n[  253.544560] io_issue_sqe (fs/io_uring.c:4556 fs/io_uring.c:4589 fs/io_uring.c:6828)\n[  253.544564] ? __kasan_slab_alloc (mm/kasan/common.c:45 mm/kasan/common.c:436 mm/kasan/common.c:469)\n[  253.544567] ? __kasan_slab_alloc (mm/kasan/common.c:39 mm/kasan/common.c:45 mm/kasan/common.c:436 mm/kasan/common.c:469)\n[  253.544569] ? kmem_cache_alloc_bulk (mm/slab.h:732 mm/slab.c:3546)\n[  253.544573] ? __io_alloc_req_refill (fs/io_uring.c:2078)\n[  253.544578] ? io_submit_sqes (fs/io_uring.c:7441)\n[  253.544581] ? __se_sys_io_uring_enter (fs/io_uring.c:10154 fs/io_uring.c:10096)\n[  253.544584] ? __x64_sys_io_uring_enter (fs/io_uring.c:10096)\n[  253.544587] ? do_syscall_64 (arch/x86/entry/common.c:50 arch/x86/entry/common.c:80)\n[  253.544590] ? entry_SYSCALL_64_after_hwframe (??:?)\n[  253.544596] __io_queue_sqe (fs/io_uring.c:?)\n[  253.544600] io_queue_sqe (fs/io_uring.c:7143)\n[  253.544603] io_submit_sqe (fs/io_uring.c:?)\n[  253.544608] io_submit_sqes (fs/io_uring.c:?)\n[  253.544612] __se_sys_io_uring_enter (fs/io_uring.c:10154 fs/io_uri\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4a93c6594613c3429b6f30136fff115c7f803af4"
          },
          {
            "url": "https://git.kernel.org/stable/c/8f3cc3c5bc43d03b5748ac4fb8d180084952c36a"
          },
          {
            "url": "https://git.kernel.org/stable/c/c718ea4e7382e18957ed0e88a5f855e2122d9c00"
          },
          {
            "url": "https://git.kernel.org/stable/c/f240762f88b4b1b58561939ffd44837759756477"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48938",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-22T04:15:17.787",
        "lastModified": "2024-08-22T12:48:02.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nCDC-NCM: avoid overflow in sanity checking\nA broken device may give an extreme offset like 0xFFF0\nand a reasonable length for a fragment. In the sanity\ncheck as formulated now, this will create an integer\noverflow, defeating the sanity check. Both offset\nand offset + len need to be checked in such a manner\nthat no overflow can occur.\nAnd those quantities should be unsigned.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/49909c9f8458cacb5b241106cba65aba5a6d8f4c"
          },
          {
            "url": "https://git.kernel.org/stable/c/69560efa001397ebb8dc1c3e6a3ce00302bb9f7f"
          },
          {
            "url": "https://git.kernel.org/stable/c/7b737e47b87589031f0d4657f6d7b0b770474925"
          },
          {
            "url": "https://git.kernel.org/stable/c/8d2b1a1ec9f559d30b724877da4ce592edc41fdc"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48939",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-22T04:15:17.843",
        "lastModified": "2024-08-22T12:48:02.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbpf: Add schedule points in batch ops\nsyzbot reported various soft lockups caused by bpf batch operations.\n INFO: task kworker/1:1:27 blocked for more than 140 seconds.\n INFO: task hung in rcu_barrier\nNothing prevents batch ops to process huge amount of data,\nwe need to add schedule points in them.\nNote that maybe_wait_bpf_programs(map) calls from\ngeneric_map_delete_batch() can be factorized by moving\nthe call after the loop.\nThis will be done later in -next tree once we get this fix merged,\nunless there is strong opinion doing this optimization sooner.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/75134f16e7dd0007aa474b281935c5f42e79f2c8"
          },
          {
            "url": "https://git.kernel.org/stable/c/7e8099967d0e3ff9d1ae043e80b27fbe46c08417"
          },
          {
            "url": "https://git.kernel.org/stable/c/7ef94bfb08fb9e73defafbd5ddef6b5a0e2ee12b"
          },
          {
            "url": "https://git.kernel.org/stable/c/8628f489b749a4f9767991631921dbe3fbcdc784"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48940",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-22T04:15:17.907",
        "lastModified": "2024-08-22T12:48:02.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbpf: Fix crash due to incorrect copy_map_value\nWhen both bpf_spin_lock and bpf_timer are present in a BPF map value,\ncopy_map_value needs to skirt both objects when copying a value into and\nout of the map. However, the current code does not set both s_off and\nt_off in copy_map_value, which leads to a crash when e.g. bpf_spin_lock\nis placed in map value with bpf_timer, as bpf_map_update_elem call will\nbe able to overwrite the other timer object.\nWhen the issue is not fixed, an overwriting can produce the following\nsplat:\n[root@(none) bpf]# ./test_progs -t timer_crash\n[   15.930339] bpf_testmod: loading out-of-tree module taints kernel.\n[   16.037849] ==================================================================\n[   16.038458] BUG: KASAN: user-memory-access in __pv_queued_spin_lock_slowpath+0x32b/0x520\n[   16.038944] Write of size 8 at addr 0000000000043ec0 by task test_progs/325\n[   16.039399]\n[   16.039514] CPU: 0 PID: 325 Comm: test_progs Tainted: G           OE     5.16.0+ #278\n[   16.039983] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS ArchLinux 1.15.0-1 04/01/2014\n[   16.040485] Call Trace:\n[   16.040645]  <TASK>\n[   16.040805]  dump_stack_lvl+0x59/0x73\n[   16.041069]  ? __pv_queued_spin_lock_slowpath+0x32b/0x520\n[   16.041427]  kasan_report.cold+0x116/0x11b\n[   16.041673]  ? __pv_queued_spin_lock_slowpath+0x32b/0x520\n[   16.042040]  __pv_queued_spin_lock_slowpath+0x32b/0x520\n[   16.042328]  ? memcpy+0x39/0x60\n[   16.042552]  ? pv_hash+0xd0/0xd0\n[   16.042785]  ? lockdep_hardirqs_off+0x95/0xd0\n[   16.043079]  __bpf_spin_lock_irqsave+0xdf/0xf0\n[   16.043366]  ? bpf_get_current_comm+0x50/0x50\n[   16.043608]  ? jhash+0x11a/0x270\n[   16.043848]  bpf_timer_cancel+0x34/0xe0\n[   16.044119]  bpf_prog_c4ea1c0f7449940d_sys_enter+0x7c/0x81\n[   16.044500]  bpf_trampoline_6442477838_0+0x36/0x1000\n[   16.044836]  __x64_sys_nanosleep+0x5/0x140\n[   16.045119]  do_syscall_64+0x59/0x80\n[   16.045377]  ? lock_is_held_type+0xe4/0x140\n[   16.045670]  ? irqentry_exit_to_user_mode+0xa/0x40\n[   16.046001]  ? mark_held_locks+0x24/0x90\n[   16.046287]  ? asm_exc_page_fault+0x1e/0x30\n[   16.046569]  ? asm_exc_page_fault+0x8/0x30\n[   16.046851]  ? lockdep_hardirqs_on+0x7e/0x100\n[   16.047137]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[   16.047405] RIP: 0033:0x7f9e4831718d\n[   16.047602] Code: b4 0c 00 0f 05 eb a9 66 0f 1f 44 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d b3 6c 0c 00 f7 d8 64 89 01 48\n[   16.048764] RSP: 002b:00007fff488086b8 EFLAGS: 00000206 ORIG_RAX: 0000000000000023\n[   16.049275] RAX: ffffffffffffffda RBX: 00007f9e48683740 RCX: 00007f9e4831718d\n[   16.049747] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 00007fff488086d0\n[   16.050225] RBP: 00007fff488086f0 R08: 00007fff488085d7 R09: 00007f9e4cb594a0\n[   16.050648] R10: 0000000000000000 R11: 0000000000000206 R12: 00007f9e484cde30\n[   16.051124] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\n[   16.051608]  </TASK>\n[   16.051762] ==================================================================",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/719d1c2524c89ada78c4c9202641c1d9e942a322"
          },
          {
            "url": "https://git.kernel.org/stable/c/a8abb0c3dc1e28454851a00f8b7333d9695d566c"
          },
          {
            "url": "https://git.kernel.org/stable/c/eca9bd215d2233de79d930fa97aefbce03247a98"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48941",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-22T04:15:17.967",
        "lastModified": "2024-08-22T12:48:02.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nice: fix concurrent reset and removal of VFs\nCommit c503e63200c6 (\"ice: Stop processing VF messages during teardown\")\nintroduced a driver state flag, ICE_VF_DEINIT_IN_PROGRESS, which is\nintended to prevent some issues with concurrently handling messages from\nVFs while tearing down the VFs.\nThis change was motivated by crashes caused while tearing down and\nbringing up VFs in rapid succession.\nIt turns out that the fix actually introduces issues with the VF driver\ncaused because the PF no longer responds to any messages sent by the VF\nduring its .remove routine. This results in the VF potentially removing\nits DMA memory before the PF has shut down the device queues.\nAdditionally, the fix doesn't actually resolve concurrency issues within\nthe ice driver. It is possible for a VF to initiate a reset just prior\nto the ice driver removing VFs. This can result in the remove task\nconcurrently operating while the VF is being reset. This results in\nsimilar memory corruption and panics purportedly fixed by that commit.\nFix this concurrency at its root by protecting both the reset and\nremoval flows using the existing VF cfg_lock. This ensures that we\ncannot remove the VF while any outstanding critical tasks such as a\nvirtchnl message or a reset are occurring.\nThis locking change also fixes the root cause originally fixed by commit\nc503e63200c6 (\"ice: Stop processing VF messages during teardown\"), so we\ncan simply revert it.\nNote that I kept these two changes together because simply reverting the\noriginal commit alone would leave the driver vulnerable to worse race\nconditions.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/05ae1f0fe9c6c5ead08b306e665763a352d20716"
          },
          {
            "url": "https://git.kernel.org/stable/c/2a3e61de89bab6696aa28b70030eb119968c5586"
          },
          {
            "url": "https://git.kernel.org/stable/c/3c805fce07c9dbc47d8a9129c7c5458025951957"
          },
          {
            "url": "https://git.kernel.org/stable/c/fadead80fe4c033b5e514fcbadd20b55c4494112"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48942",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-22T04:15:18.953",
        "lastModified": "2024-08-22T12:48:02.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nhwmon: Handle failure to register sensor with thermal zone correctly\nIf an attempt is made to a sensor with a thermal zone and it fails,\nthe call to devm_thermal_zone_of_sensor_register() may return -ENODEV.\nThis may result in crashes similar to the following.\nUnable to handle kernel NULL pointer dereference at virtual address 00000000000003cd\n...\nInternal error: Oops: 96000021 [#1] PREEMPT SMP\n...\npstate: 60400009 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : mutex_lock+0x18/0x60\nlr : thermal_zone_device_update+0x40/0x2e0\nsp : ffff800014c4fc60\nx29: ffff800014c4fc60 x28: ffff365ee3f6e000 x27: ffffdde218426790\nx26: ffff365ee3f6e000 x25: 0000000000000000 x24: ffff365ee3f6e000\nx23: ffffdde218426870 x22: ffff365ee3f6e000 x21: 00000000000003cd\nx20: ffff365ee8bf3308 x19: ffffffffffffffed x18: 0000000000000000\nx17: ffffdde21842689c x16: ffffdde1cb7a0b7c x15: 0000000000000040\nx14: ffffdde21a4889a0 x13: 0000000000000228 x12: 0000000000000000\nx11: 0000000000000000 x10: 0000000000000000 x9 : 0000000000000000\nx8 : 0000000001120000 x7 : 0000000000000001 x6 : 0000000000000000\nx5 : 0068000878e20f07 x4 : 0000000000000000 x3 : 00000000000003cd\nx2 : ffff365ee3f6e000 x1 : 0000000000000000 x0 : 00000000000003cd\nCall trace:\n mutex_lock+0x18/0x60\n hwmon_notify_event+0xfc/0x110\n 0xffffdde1cb7a0a90\n 0xffffdde1cb7a0b7c\n irq_thread_fn+0x2c/0xa0\n irq_thread+0x134/0x240\n kthread+0x178/0x190\n ret_from_fork+0x10/0x20\nCode: d503201f d503201f d2800001 aa0103e4 (c8e47c02)\nJon Hunter reports that the exact call sequence is:\nhwmon_notify_event()\n  --> hwmon_thermal_notify()\n    --> thermal_zone_device_update()\n      --> update_temperature()\n        --> mutex_lock()\nThe hwmon core needs to handle all errors returned from calls\nto devm_thermal_zone_of_sensor_register(). If the call fails\nwith -ENODEV, report that the sensor was not attached to a\nthermal zone  but continue to register the hwmon device.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1b5f517cca36292076d9e38fa6e33a257703e62e"
          },
          {
            "url": "https://git.kernel.org/stable/c/7efe8499cb90651c540753f4269d2d43ede14223"
          },
          {
            "url": "https://git.kernel.org/stable/c/8a1969e14ad93663f9a3ed02ccc2138da9956a0e"
          },
          {
            "url": "https://git.kernel.org/stable/c/962b2a3188bfa5388756ffbc47dfa5ff59cb8011"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48943",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-08-22T04:15:19.027",
        "lastModified": "2024-08-22T12:48:02.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nKVM: x86/mmu: make apf token non-zero to fix bug\nIn current async pagefault logic, when a page is ready, KVM relies on\nkvm_arch_can_dequeue_async_page_present() to determine whether to deliver\na READY event to the Guest. This function test token value of struct\nkvm_vcpu_pv_apf_data, which must be reset to zero by Guest kernel when a\nREADY event is finished by Guest. If value is zero meaning that a READY\nevent is done, so the KVM can deliver another.\nBut the kvm_arch_setup_async_pf() may produce a valid token with zero\nvalue, which is confused with previous mention and may lead the loss of\nthis READY event.\nThis bug may cause task blocked forever in Guest:\n INFO: task stress:7532 blocked for more than 1254 seconds.\n       Not tainted 5.10.0 #16\n \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\n task:stress          state:D stack:    0 pid: 7532 ppid:  1409\n flags:0x00000080\n Call Trace:\n  __schedule+0x1e7/0x650\n  schedule+0x46/0xb0\n  kvm_async_pf_task_wait_schedule+0xad/0xe0\n  ? exit_to_user_mode_prepare+0x60/0x70\n  __kvm_handle_async_pf+0x4f/0xb0\n  ? asm_exc_page_fault+0x8/0x30\n  exc_page_fault+0x6f/0x110\n  ? asm_exc_page_fault+0x8/0x30\n  asm_exc_page_fault+0x1e/0x30\n RIP: 0033:0x402d00\n RSP: 002b:00007ffd31912500 EFLAGS: 00010206\n RAX: 0000000000071000 RBX: ffffffffffffffff RCX: 00000000021a32b0\n RDX: 000000000007d011 RSI: 000000000007d000 RDI: 00000000021262b0\n RBP: 00000000021262b0 R08: 0000000000000003 R09: 0000000000000086\n R10: 00000000000000eb R11: 00007fefbdf2baa0 R12: 0000000000000000\n R13: 0000000000000002 R14: 000000000007d000 R15: 0000000000001000",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4c3644b6c96c5daa5149e5abddc07234eea47c7c"
          },
          {
            "url": "https://git.kernel.org/stable/c/62040f5cd7d937de547836e747b6aa8212fec573"
          },
          {
            "url": "https://git.kernel.org/stable/c/6f3c1fc53d86d580d8d6d749c4af23705e4f6f79"
          },
          {
            "url": "https://git.kernel.org/stable/c/72fdfc75d4217b32363cc80def3de2cb3fef3f02"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45163",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-08-22T04:15:20.247",
        "lastModified": "2024-08-22T12:48:02.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "The Mirai botnet through 2024-08-19 mishandles simultaneous TCP connections to the CNC (command and control) server. Unauthenticated sessions remain open, causing resource consumption. For example, an attacker can send a recognized username (such as root), or can send arbitrary data.",
        "cweIds": null,
        "references": [
          {
            "url": "https://cypressthatkid.medium.com/remote-dos-exploit-found-in-mirai-botnet-source-code-27a1aad284f1"
          },
          {
            "url": "https://pastebin.com/6tqHnCva"
          },
          {
            "url": "https://youtu.be/aJkvSr85ML8"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45165",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-08-22T04:15:22.310",
        "lastModified": "2024-08-22T12:48:02.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "An issue was discovered in UCI IDOL 2 (aka uciIDOL or IDOL2) through 2.12. Data is sent between client and server with encryption. However, the key is derived from the string \"(c)2007 UCI Software GmbH B.Boll\" (without quotes). The key is both static and hardcoded. With access to messages, this results in message decryption and encryption by an attacker. Thus, it enables passive and active man-in-the-middle attacks.",
        "cweIds": null,
        "references": [
          {
            "url": "http://download.uci.de/idol2/idol2Client_2_12.exe"
          },
          {
            "url": "https://uci.de/download/idol2-client.html"
          },
          {
            "url": "https://uci.de/products/index.html"
          },
          {
            "url": "https://www.syss.de/en/responsible-disclosure-policy"
          },
          {
            "url": "https://www.syss.de/fileadmin/dokumente/Publikationen/Advisories/SYSS-2024-048.txt"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45166",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-08-22T04:15:24.467",
        "lastModified": "2024-08-22T14:35:13.183",
        "baseScore": 9.8,
        "baseSeverity": "CRITICAL",
        "exploitabilityScore": 3.9,
        "impactScore": 5.9,
        "description": "An issue was discovered in UCI IDOL 2 (aka uciIDOL or IDOL2) through 2.12. Due to improper input validation, improper deserialization, and improper restriction of operations within the bounds of a memory buffer, IDOL2 is vulnerable to Denial-of-Service (DoS) attacks and possibly remote code execution. There is an access violation and EIP overwrite after five logins.",
        "cweIds": [
          {
            "id": "CWE-400",
            "description": "Uncontrolled Resource Consumption"
          }
        ],
        "references": [
          {
            "url": "http://download.uci.de/idol2/idol2Client_2_12.exe"
          },
          {
            "url": "https://uci.de/download/idol2-client.html"
          },
          {
            "url": "https://uci.de/products/index.html"
          },
          {
            "url": "https://www.syss.de/en/responsible-disclosure-policy"
          },
          {
            "url": "https://www.syss.de/fileadmin/dokumente/Publikationen/Advisories/SYSS-2024-050.txt"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45167",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-08-22T04:15:25.710",
        "lastModified": "2024-08-22T12:48:02.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "An issue was discovered in UCI IDOL 2 (aka uciIDOL or IDOL2) through 2.12. Due to improper input validation, improper deserialization, and improper restriction of operations within the bounds of a memory buffer, IDOL2 is vulnerable to Denial-of-Service (DoS) attacks and possibly remote code execution. A certain XmlMessage document causes 100% CPU consumption.",
        "cweIds": null,
        "references": [
          {
            "url": "http://download.uci.de/idol2/idol2Client_2_12.exe"
          },
          {
            "url": "https://uci.de/download/idol2-client.html"
          },
          {
            "url": "https://uci.de/products/index.html"
          },
          {
            "url": "https://www.syss.de/en/responsible-disclosure-policy"
          },
          {
            "url": "https://www.syss.de/fileadmin/dokumente/Publikationen/Advisories/SYSS-2024-050.txt"
          },
          {
            "url": "https://www.syss.de/fileadmin/dokumente/Publikationen/Advisories/SYSS-2024-051.txt"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45168",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-08-22T04:15:27.190",
        "lastModified": "2024-08-22T14:35:13.957",
        "baseScore": 9.1,
        "baseSeverity": "CRITICAL",
        "exploitabilityScore": 3.9,
        "impactScore": 5.2,
        "description": "An issue was discovered in UCI IDOL 2 (aka uciIDOL or IDOL2) through 2.12. Data is transferred over a raw socket without any authentication mechanism. Thus, communication endpoints are not verifiable.",
        "cweIds": [
          {
            "id": "CWE-862",
            "description": "Missing Authorization"
          }
        ],
        "references": [
          {
            "url": "http://download.uci.de/idol2/idol2Client_2_12.exe"
          },
          {
            "url": "https://uci.de/download/idol2-client.html"
          },
          {
            "url": "https://uci.de/products/index.html"
          },
          {
            "url": "https://www.syss.de/en/responsible-disclosure-policy"
          },
          {
            "url": "https://www.syss.de/fileadmin/dokumente/Publikationen/Advisories/SYSS-2024-049.txt"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45169",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-08-22T04:15:27.583",
        "lastModified": "2024-08-22T12:48:02.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "An issue was discovered in UCI IDOL 2 (aka uciIDOL or IDOL2) through 2.12. Due to improper input validation, improper deserialization, and improper restriction of operations within the bounds of a memory buffer, IDOL2 is vulnerable to Denial-of-Service (DoS) attacks and possibly remote code execution via the \\xB0\\x00\\x3c byte sequence.",
        "cweIds": null,
        "references": [
          {
            "url": "http://download.uci.de/idol2/idol2Client_2_12.exe"
          },
          {
            "url": "https://uci.de/download/idol2-client.html"
          },
          {
            "url": "https://uci.de/products/index.html"
          },
          {
            "url": "https://www.syss.de/en/responsible-disclosure-policy"
          },
          {
            "url": "https://www.syss.de/fileadmin/dokumente/Publikationen/Advisories/SYSS-2024-052.txt"
          }
        ]
      }
    }
  ]
}