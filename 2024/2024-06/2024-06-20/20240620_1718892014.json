{
  "totalResults": 59,
  "datePublished": "2024-06-20T23:00:14.185763Z",
  "vulnerabilities": [
    {
      "cve": {
        "id": "CVE-2021-4439",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:10.447",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nisdn: cpai: check ctr->cnr to avoid array index out of bound\nThe cmtp_add_connection() would add a cmtp session to a controller\nand run a kernel thread to process cmtp.\n\t__module_get(THIS_MODULE);\n\tsession->task = kthread_run(cmtp_session, session, \"kcmtpd_ctr_%d\",\n\t\t\t\t\t\t\t\tsession->num);\nDuring this process, the kernel thread would call detach_capi_ctr()\nto detach a register controller. if the controller\nwas not attached yet, detach_capi_ctr() would\ntrigger an array-index-out-bounds bug.\n[   46.866069][ T6479] UBSAN: array-index-out-of-bounds in\ndrivers/isdn/capi/kcapi.c:483:21\n[   46.867196][ T6479] index -1 is out of range for type 'capi_ctr *[32]'\n[   46.867982][ T6479] CPU: 1 PID: 6479 Comm: kcmtpd_ctr_0 Not tainted\n5.15.0-rc2+ #8\n[   46.869002][ T6479] Hardware name: QEMU Standard PC (i440FX + PIIX,\n1996), BIOS 1.14.0-2 04/01/2014\n[   46.870107][ T6479] Call Trace:\n[   46.870473][ T6479]  dump_stack_lvl+0x57/0x7d\n[   46.870974][ T6479]  ubsan_epilogue+0x5/0x40\n[   46.871458][ T6479]  __ubsan_handle_out_of_bounds.cold+0x43/0x48\n[   46.872135][ T6479]  detach_capi_ctr+0x64/0xc0\n[   46.872639][ T6479]  cmtp_session+0x5c8/0x5d0\n[   46.873131][ T6479]  ? __init_waitqueue_head+0x60/0x60\n[   46.873712][ T6479]  ? cmtp_add_msgpart+0x120/0x120\n[   46.874256][ T6479]  kthread+0x147/0x170\n[   46.874709][ T6479]  ? set_kthread_struct+0x40/0x40\n[   46.875248][ T6479]  ret_from_fork+0x1f/0x30\n[   46.875773][ T6479]",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1f3e2e97c003f80c4b087092b225c8787ff91e4d"
          },
          {
            "url": "https://git.kernel.org/stable/c/24219a977bfe3d658687e45615c70998acdbac5a"
          },
          {
            "url": "https://git.kernel.org/stable/c/285e9210b1fab96a11c0be3ed5cea9dd48b6ac54"
          },
          {
            "url": "https://git.kernel.org/stable/c/7d91adc0ccb060ce564103315189466eb822cc6a"
          },
          {
            "url": "https://git.kernel.org/stable/c/7f221ccbee4ec662e2292d490a43ce6c314c4594"
          },
          {
            "url": "https://git.kernel.org/stable/c/9b6b2db77bc3121fe435f1d4b56e34de443bec75"
          },
          {
            "url": "https://git.kernel.org/stable/c/cc20226e218a2375d50dd9ac14fb4121b43375ff"
          },
          {
            "url": "https://git.kernel.org/stable/c/e8b8de17e164c9f1b7777f1c6f99d05539000036"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48724",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:10.900",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\niommu/vt-d: Fix potential memory leak in intel_setup_irq_remapping()\nAfter commit e3beca48a45b (\"irqdomain/treewide: Keep firmware node\nunconditionally allocated\"). For tear down scenario, fn is only freed\nafter fail to allocate ir_domain, though it also should be freed in case\ndmar_enable_qi returns error.\nBesides free fn, irq_domain and ir_msi_domain need to be removed as well\nif intel_setup_irq_remapping fails to enable queued invalidation.\nImprove the rewinding path by add out_free_ir_domain and out_free_fwnode\nlables per Baolu's suggestion.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/336d096b62bdc673e852b6b80d5072d7888ce85d"
          },
          {
            "url": "https://git.kernel.org/stable/c/5c43d46daa0d2928234dd2792ebebc35d29ee2d1"
          },
          {
            "url": "https://git.kernel.org/stable/c/99e675d473eb8cf2deac1376a0f840222fc1adcf"
          },
          {
            "url": "https://git.kernel.org/stable/c/9d9995b0371e4e8c18d4f955479e5d47efe7b2d4"
          },
          {
            "url": "https://git.kernel.org/stable/c/a0c685ba99961b1dd894b2e470e692a539770f6d"
          },
          {
            "url": "https://git.kernel.org/stable/c/a31cb1f0fb6caf46ffe88c41252b6b7a4ee062d9"
          },
          {
            "url": "https://git.kernel.org/stable/c/b62eceb5f8f08815fe3f945fc55bbf997c344ecd"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48725",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:10.997",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nRDMA/siw: Fix refcounting leak in siw_create_qp()\nThe atomic_inc() needs to be paired with an atomic_dec() on the error\npath.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2989ba9532babac66e79997ccff73c015b69700c"
          },
          {
            "url": "https://git.kernel.org/stable/c/a75badebfdc0b3823054bedf112edb54d6357c75"
          },
          {
            "url": "https://git.kernel.org/stable/c/fa3b844a50845c817660146c27c0fc29b08d3116"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48726",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:11.077",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nRDMA/ucma: Protect mc during concurrent multicast leaves\nPartially revert the commit mentioned in the Fixes line to make sure that\nallocation and erasing multicast struct are locked.\n  BUG: KASAN: use-after-free in ucma_cleanup_multicast drivers/infiniband/core/ucma.c:491 [inline]\n  BUG: KASAN: use-after-free in ucma_destroy_private_ctx+0x914/0xb70 drivers/infiniband/core/ucma.c:579\n  Read of size 8 at addr ffff88801bb74b00 by task syz-executor.1/25529\n  CPU: 0 PID: 25529 Comm: syz-executor.1 Not tainted 5.16.0-rc7-syzkaller #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\n  Call Trace:\n   __dump_stack lib/dump_stack.c:88 [inline]\n   dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106\n   print_address_description.constprop.0.cold+0x8d/0x320 mm/kasan/report.c:247\n   __kasan_report mm/kasan/report.c:433 [inline]\n   kasan_report.cold+0x83/0xdf mm/kasan/report.c:450\n   ucma_cleanup_multicast drivers/infiniband/core/ucma.c:491 [inline]\n   ucma_destroy_private_ctx+0x914/0xb70 drivers/infiniband/core/ucma.c:579\n   ucma_destroy_id+0x1e6/0x280 drivers/infiniband/core/ucma.c:614\n   ucma_write+0x25c/0x350 drivers/infiniband/core/ucma.c:1732\n   vfs_write+0x28e/0xae0 fs/read_write.c:588\n   ksys_write+0x1ee/0x250 fs/read_write.c:643\n   do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n   do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n   entry_SYSCALL_64_after_hwframe+0x44/0xae\nCurrently the xarray search can touch a concurrently freeing mc as the\nxa_for_each() is not surrounded by any lock. Rather than hold the lock for\na full scan hold it only for the effected items, which is usually an empty\nlist.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2923948ffe0835f7114e948b35bcc42bc9b3baa1"
          },
          {
            "url": "https://git.kernel.org/stable/c/36e8169ec973359f671f9ec7213547059cae972e"
          },
          {
            "url": "https://git.kernel.org/stable/c/75c610212b9f1756b9384911d3a2c347eee8031c"
          },
          {
            "url": "https://git.kernel.org/stable/c/ee2477e8ccd3d978eeac0dc5a981b286d9bb7b0a"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48727",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:11.167",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nKVM: arm64: Avoid consuming a stale esr value when SError occur\nWhen any exception other than an IRQ occurs, the CPU updates the ESR_EL2\nregister with the exception syndrome. An SError may also become pending,\nand will be synchronised by KVM. KVM notes the exception type, and whether\nan SError was synchronised in exit_code.\nWhen an exception other than an IRQ occurs, fixup_guest_exit() updates\nvcpu->arch.fault.esr_el2 from the hardware register. When an SError was\nsynchronised, the vcpu esr value is used to determine if the exception\nwas due to an HVC. If so, ELR_EL2 is moved back one instruction. This\nis so that KVM can process the SError first, and re-execute the HVC if\nthe guest survives the SError.\nBut if an IRQ synchronises an SError, the vcpu's esr value is stale.\nIf the previous non-IRQ exception was an HVC, KVM will corrupt ELR_EL2,\ncausing an unrelated guest instruction to be executed twice.\nCheck ARM_EXCEPTION_CODE() before messing with ELR_EL2, IRQs don't\nupdate this register so don't need to check.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1c71dbc8a179d99dd9bb7e7fc1888db613cf85de"
          },
          {
            "url": "https://git.kernel.org/stable/c/57e2986c3b25092691a6e3d6ee9168caf8978932"
          },
          {
            "url": "https://git.kernel.org/stable/c/e1e852746997500f1873f60b954da5f02cc2dba3"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48728",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:11.253",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nIB/hfi1: Fix AIP early init panic\nAn early failure in hfi1_ipoib_setup_rn() can lead to the following panic:\n  BUG: unable to handle kernel NULL pointer dereference at 00000000000001b0\n  PGD 0 P4D 0\n  Oops: 0002 [#1] SMP NOPTI\n  Workqueue: events work_for_cpu_fn\n  RIP: 0010:try_to_grab_pending+0x2b/0x140\n  Code: 1f 44 00 00 41 55 41 54 55 48 89 d5 53 48 89 fb 9c 58 0f 1f 44 00 00 48 89 c2 fa 66 0f 1f 44 00 00 48 89 55 00 40 84 f6 75 77 <f0> 48 0f ba 2b 00 72 09 31 c0 5b 5d 41 5c 41 5d c3 48 89 df e8 6c\n  RSP: 0018:ffffb6b3cf7cfa48 EFLAGS: 00010046\n  RAX: 0000000000000246 RBX: 00000000000001b0 RCX: 0000000000000000\n  RDX: 0000000000000246 RSI: 0000000000000000 RDI: 00000000000001b0\n  RBP: ffffb6b3cf7cfa70 R08: 0000000000000f09 R09: 0000000000000001\n  R10: 0000000000000000 R11: 0000000000000001 R12: 0000000000000000\n  R13: ffffb6b3cf7cfa90 R14: ffffffff9b2fbfc0 R15: ffff8a4fdf244690\n  FS:  0000000000000000(0000) GS:ffff8a527f400000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00000000000001b0 CR3: 00000017e2410003 CR4: 00000000007706f0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n  PKRU: 55555554\n  Call Trace:\n   __cancel_work_timer+0x42/0x190\n   ? dev_printk_emit+0x4e/0x70\n   iowait_cancel_work+0x15/0x30 [hfi1]\n   hfi1_ipoib_txreq_deinit+0x5a/0x220 [hfi1]\n   ? dev_err+0x6c/0x90\n   hfi1_ipoib_netdev_dtor+0x15/0x30 [hfi1]\n   hfi1_ipoib_setup_rn+0x10e/0x150 [hfi1]\n   rdma_init_netdev+0x5a/0x80 [ib_core]\n   ? hfi1_ipoib_free_rdma_netdev+0x20/0x20 [hfi1]\n   ipoib_intf_init+0x6c/0x350 [ib_ipoib]\n   ipoib_intf_alloc+0x5c/0xc0 [ib_ipoib]\n   ipoib_add_one+0xbe/0x300 [ib_ipoib]\n   add_client_context+0x12c/0x1a0 [ib_core]\n   enable_device_and_get+0xdc/0x1d0 [ib_core]\n   ib_register_device+0x572/0x6b0 [ib_core]\n   rvt_register_device+0x11b/0x220 [rdmavt]\n   hfi1_register_ib_device+0x6b4/0x770 [hfi1]\n   do_init_one.isra.20+0x3e3/0x680 [hfi1]\n   local_pci_probe+0x41/0x90\n   work_for_cpu_fn+0x16/0x20\n   process_one_work+0x1a7/0x360\n   ? create_worker+0x1a0/0x1a0\n   worker_thread+0x1cf/0x390\n   ? create_worker+0x1a0/0x1a0\n   kthread+0x116/0x130\n   ? kthread_flush_work_fn+0x10/0x10\n   ret_from_fork+0x1f/0x40\nThe panic happens in hfi1_ipoib_txreq_deinit() because there is a NULL\nderef when hfi1_ipoib_netdev_dtor() is called in this error case.\nhfi1_ipoib_txreq_init() and hfi1_ipoib_rxq_init() are self unwinding so\nfix by adjusting the error paths accordingly.\nOther changes:\n- hfi1_ipoib_free_rdma_netdev() is deleted including the free_netdev()\n  since the netdev core code deletes calls free_netdev()\n- The switch to the accelerated entrances is moved to the success path.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1899c3cad265c4583658aed5293d02e8af84276b"
          },
          {
            "url": "https://git.kernel.org/stable/c/4a9bd1e6780fc59f81466ec3489d5ad535a37190"
          },
          {
            "url": "https://git.kernel.org/stable/c/5f8f55b92edd621f056bdf09e572092849fabd83"
          },
          {
            "url": "https://git.kernel.org/stable/c/a3dd4d2682f2a796121609e5f3bbeb1243198c53"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48729",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:11.343",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nIB/hfi1: Fix panic with larger ipoib send_queue_size\nWhen the ipoib send_queue_size is increased from the default the following\npanic happens:\n  RIP: 0010:hfi1_ipoib_drain_tx_ring+0x45/0xf0 [hfi1]\n  Code: 31 e4 eb 0f 8b 85 c8 02 00 00 41 83 c4 01 44 39 e0 76 60 8b 8d cc 02 00 00 44 89 e3 be 01 00 00 00 d3 e3 48 03 9d c0 02 00 00 <c7> 83 18 01 00 00 00 00 00 00 48 8b bb 30 01 00 00 e8 25 af a7 e0\n  RSP: 0018:ffffc9000798f4a0 EFLAGS: 00010286\n  RAX: 0000000000008000 RBX: ffffc9000aa0f000 RCX: 000000000000000f\n  RDX: 0000000000000000 RSI: 0000000000000001 RDI: 0000000000000000\n  RBP: ffff88810ff08000 R08: ffff88889476d900 R09: 0000000000000101\n  R10: 0000000000000000 R11: ffffc90006590ff8 R12: 0000000000000200\n  R13: ffffc9000798fba8 R14: 0000000000000000 R15: 0000000000000001\n  FS:  00007fd0f79cc3c0(0000) GS:ffff88885fb00000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: ffffc9000aa0f118 CR3: 0000000889c84001 CR4: 00000000001706e0\n  Call Trace:\n   <TASK>\n   hfi1_ipoib_napi_tx_disable+0x45/0x60 [hfi1]\n   hfi1_ipoib_dev_stop+0x18/0x80 [hfi1]\n   ipoib_ib_dev_stop+0x1d/0x40 [ib_ipoib]\n   ipoib_stop+0x48/0xc0 [ib_ipoib]\n   __dev_close_many+0x9e/0x110\n   __dev_change_flags+0xd9/0x210\n   dev_change_flags+0x21/0x60\n   do_setlink+0x31c/0x10f0\n   ? __nla_validate_parse+0x12d/0x1a0\n   ? __nla_parse+0x21/0x30\n   ? inet6_validate_link_af+0x5e/0xf0\n   ? cpumask_next+0x1f/0x20\n   ? __snmp6_fill_stats64.isra.53+0xbb/0x140\n   ? __nla_validate_parse+0x47/0x1a0\n   __rtnl_newlink+0x530/0x910\n   ? pskb_expand_head+0x73/0x300\n   ? __kmalloc_node_track_caller+0x109/0x280\n   ? __nla_put+0xc/0x20\n   ? cpumask_next_and+0x20/0x30\n   ? update_sd_lb_stats.constprop.144+0xd3/0x820\n   ? _raw_spin_unlock_irqrestore+0x25/0x37\n   ? __wake_up_common_lock+0x87/0xc0\n   ? kmem_cache_alloc_trace+0x3d/0x3d0\n   rtnl_newlink+0x43/0x60\nThe issue happens when the shift that should have been a function of the\ntxq item size mistakenly used the ring size.\nFix by using the item size.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1530d84fba1e459ba55f46aa42649b88773210e7"
          },
          {
            "url": "https://git.kernel.org/stable/c/8c83d39cc730378bbac64d67a551897b203a606e"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48730",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:11.430",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndma-buf: heaps: Fix potential spectre v1 gadget\nIt appears like nr could be a Spectre v1 gadget as it's supplied by a\nuser and used as an array index. Prevent the contents\nof kernel memory from being leaked to userspace via speculative\nexecution by using array_index_nospec.\n [sumits: added fixes and cc: stable tags]",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/24f8e12d965b24f8aea762589e0e9fe2025c005e"
          },
          {
            "url": "https://git.kernel.org/stable/c/5d40f1bdad3dd1a177f21a90ad4353c1ed40ba3a"
          },
          {
            "url": "https://git.kernel.org/stable/c/92c4cfaee6872038563c5b6f2e8e613f9d84d47d"
          },
          {
            "url": "https://git.kernel.org/stable/c/cc8f7940d9c2d45f67b3d1a2f2b7a829ca561bed"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48731",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:11.517",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmm/kmemleak: avoid scanning potential huge holes\nWhen using devm_request_free_mem_region() and devm_memremap_pages() to\nadd ZONE_DEVICE memory, if requested free mem region's end pfn were\nhuge(e.g., 0x400000000), the node_end_pfn() will be also huge (see\nmove_pfn_range_to_zone()).  Thus it creates a huge hole between\nnode_start_pfn() and node_end_pfn().\nWe found on some AMD APUs, amdkfd requested such a free mem region and\ncreated a huge hole.  In such a case, following code snippet was just\ndoing busy test_bit() looping on the huge hole.\n  for (pfn = start_pfn; pfn < end_pfn; pfn++) {\n\tstruct page *page = pfn_to_online_page(pfn);\n\t\tif (!page)\n\t\t\tcontinue;\n\t...\n  }\nSo we got a soft lockup:\n  watchdog: BUG: soft lockup - CPU#6 stuck for 26s! [bash:1221]\n  CPU: 6 PID: 1221 Comm: bash Not tainted 5.15.0-custom #1\n  RIP: 0010:pfn_to_online_page+0x5/0xd0\n  Call Trace:\n    ? kmemleak_scan+0x16a/0x440\n    kmemleak_write+0x306/0x3a0\n    ? common_file_perm+0x72/0x170\n    full_proxy_write+0x5c/0x90\n    vfs_write+0xb9/0x260\n    ksys_write+0x67/0xe0\n    __x64_sys_write+0x1a/0x20\n    do_syscall_64+0x3b/0xc0\n    entry_SYSCALL_64_after_hwframe+0x44/0xae\nI did some tests with the patch.\n(1) amdgpu module unloaded\nbefore the patch:\n  real    0m0.976s\n  user    0m0.000s\n  sys     0m0.968s\nafter the patch:\n  real    0m0.981s\n  user    0m0.000s\n  sys     0m0.973s\n(2) amdgpu module loaded\nbefore the patch:\n  real    0m35.365s\n  user    0m0.000s\n  sys     0m35.354s\nafter the patch:\n  real    0m1.049s\n  user    0m0.000s\n  sys     0m1.042s",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/352715593e81b917ce1b321e794549815b850134"
          },
          {
            "url": "https://git.kernel.org/stable/c/a5389c80992f0001ee505838fe6a8b20897ce96e"
          },
          {
            "url": "https://git.kernel.org/stable/c/c10a0f877fe007021d70f9cada240f42adc2b5db"
          },
          {
            "url": "https://git.kernel.org/stable/c/cebb0aceb21ad91429617a40e3a17444fabf1529"
          },
          {
            "url": "https://git.kernel.org/stable/c/d3533ee20e9a0e2e8f60384da7450d43d1c63d1a"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48732",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:11.607",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/nouveau: fix off by one in BIOS boundary checking\nBounds checking when parsing init scripts embedded in the BIOS reject\naccess to the last byte. This causes driver initialization to fail on\nApple eMac's with GeForce 2 MX GPUs, leaving the system with no working\nconsole.\nThis is probably only seen on OpenFirmware machines like PowerPC Macs\nbecause the BIOS image provided by OF is only the used parts of the ROM,\nnot a power-of-two blocks read from PCI directly so PCs always have\nempty bytes at the end that are never accessed.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1b777d4d9e383d2744fc9b3a09af6ec1893c8b1a"
          },
          {
            "url": "https://git.kernel.org/stable/c/909d3ec1bf9f0ec534bfc081b77c0836fea7b0e2"
          },
          {
            "url": "https://git.kernel.org/stable/c/acc887ba88333f5fec49631f12d8cc7ebd95781c"
          },
          {
            "url": "https://git.kernel.org/stable/c/b2a21669ee98aafc41c6d42ef15af4dab9e6e882"
          },
          {
            "url": "https://git.kernel.org/stable/c/d4b746e60fd8eaa8016e144223abe91158edcdad"
          },
          {
            "url": "https://git.kernel.org/stable/c/d877e814a62b7de9069aeff8bc1d979dfc996e06"
          },
          {
            "url": "https://git.kernel.org/stable/c/e7c36fa8a1e63b08312162179c78a0c7795ea369"
          },
          {
            "url": "https://git.kernel.org/stable/c/f071d9fa857582d7bd77f4906691f73d3edeab73"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48733",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:11.700",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbtrfs: fix use-after-free after failure to create a snapshot\nAt ioctl.c:create_snapshot(), we allocate a pending snapshot structure and\nthen attach it to the transaction's list of pending snapshots. After that\nwe call btrfs_commit_transaction(), and if that returns an error we jump\nto 'fail' label, where we kfree() the pending snapshot structure. This can\nresult in a later use-after-free of the pending snapshot:\n1) We allocated the pending snapshot and added it to the transaction's\n   list of pending snapshots;\n2) We call btrfs_commit_transaction(), and it fails either at the first\n   call to btrfs_run_delayed_refs() or btrfs_start_dirty_block_groups().\n   In both cases, we don't abort the transaction and we release our\n   transaction handle. We jump to the 'fail' label and free the pending\n   snapshot structure. We return with the pending snapshot still in the\n   transaction's list;\n3) Another task commits the transaction. This time there's no error at\n   all, and then during the transaction commit it accesses a pointer\n   to the pending snapshot structure that the snapshot creation task\n   has already freed, resulting in a user-after-free.\nThis issue could actually be detected by smatch, which produced the\nfollowing warning:\n  fs/btrfs/ioctl.c:843 create_snapshot() warn: '&pending_snapshot->list' not removed from list\nSo fix this by not having the snapshot creation ioctl directly add the\npending snapshot to the transaction's list. Instead add the pending\nsnapshot to the transaction handle, and then at btrfs_commit_transaction()\nwe add the snapshot to the list only when we can guarantee that any error\nreturned after that point will result in a transaction abort, in which\ncase the ioctl code can safely free the pending snapshot and no one can\naccess it anymore.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/28b21c558a3753171097193b6f6602a94169093a"
          },
          {
            "url": "https://git.kernel.org/stable/c/9372fa1d73da5f1673921e365d0cd2c27ec7adc2"
          },
          {
            "url": "https://git.kernel.org/stable/c/a7b717fa15165d3d9245614680bebc48a52ac05d"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48734",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:11.797",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbtrfs: fix deadlock between quota disable and qgroup rescan worker\nQuota disable ioctl starts a transaction before waiting for the qgroup\nrescan worker completes. However, this wait can be infinite and results\nin deadlock because of circular dependency among the quota disable\nioctl, the qgroup rescan worker and the other task with transaction such\nas block group relocation task.\nThe deadlock happens with the steps following:\n1) Task A calls ioctl to disable quota. It starts a transaction and\n   waits for qgroup rescan worker completes.\n2) Task B such as block group relocation task starts a transaction and\n   joins to the transaction that task A started. Then task B commits to\n   the transaction. In this commit, task B waits for a commit by task A.\n3) Task C as the qgroup rescan worker starts its job and starts a\n   transaction. In this transaction start, task C waits for completion\n   of the transaction that task A started and task B committed.\nThis deadlock was found with fstests test case btrfs/115 and a zoned\nnull_blk device. The test case enables and disables quota, and the\nblock group reclaim was triggered during the quota disable by chance.\nThe deadlock was also observed by running quota enable and disable in\nparallel with 'btrfs balance' command on regular null_blk devices.\nAn example report of the deadlock:\n  [372.469894] INFO: task kworker/u16:6:103 blocked for more than 122 seconds.\n  [372.479944]       Not tainted 5.16.0-rc8 #7\n  [372.485067] \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\n  [372.493898] task:kworker/u16:6   state:D stack:    0 pid:  103 ppid:     2 flags:0x00004000\n  [372.503285] Workqueue: btrfs-qgroup-rescan btrfs_work_helper [btrfs]\n  [372.510782] Call Trace:\n  [372.514092]  <TASK>\n  [372.521684]  __schedule+0xb56/0x4850\n  [372.530104]  ? io_schedule_timeout+0x190/0x190\n  [372.538842]  ? lockdep_hardirqs_on+0x7e/0x100\n  [372.547092]  ? _raw_spin_unlock_irqrestore+0x3e/0x60\n  [372.555591]  schedule+0xe0/0x270\n  [372.561894]  btrfs_commit_transaction+0x18bb/0x2610 [btrfs]\n  [372.570506]  ? btrfs_apply_pending_changes+0x50/0x50 [btrfs]\n  [372.578875]  ? free_unref_page+0x3f2/0x650\n  [372.585484]  ? finish_wait+0x270/0x270\n  [372.591594]  ? release_extent_buffer+0x224/0x420 [btrfs]\n  [372.599264]  btrfs_qgroup_rescan_worker+0xc13/0x10c0 [btrfs]\n  [372.607157]  ? lock_release+0x3a9/0x6d0\n  [372.613054]  ? btrfs_qgroup_account_extent+0xda0/0xda0 [btrfs]\n  [372.620960]  ? do_raw_spin_lock+0x11e/0x250\n  [372.627137]  ? rwlock_bug.part.0+0x90/0x90\n  [372.633215]  ? lock_is_held_type+0xe4/0x140\n  [372.639404]  btrfs_work_helper+0x1ae/0xa90 [btrfs]\n  [372.646268]  process_one_work+0x7e9/0x1320\n  [372.652321]  ? lock_release+0x6d0/0x6d0\n  [372.658081]  ? pwq_dec_nr_in_flight+0x230/0x230\n  [372.664513]  ? rwlock_bug.part.0+0x90/0x90\n  [372.670529]  worker_thread+0x59e/0xf90\n  [372.676172]  ? process_one_work+0x1320/0x1320\n  [372.682440]  kthread+0x3b9/0x490\n  [372.687550]  ? _raw_spin_unlock_irq+0x24/0x50\n  [372.693811]  ? set_kthread_struct+0x100/0x100\n  [372.700052]  ret_from_fork+0x22/0x30\n  [372.705517]  </TASK>\n  [372.709747] INFO: task btrfs-transacti:2347 blocked for more than 123 seconds.\n  [372.729827]       Not tainted 5.16.0-rc8 #7\n  [372.745907] \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\n  [372.767106] task:btrfs-transacti state:D stack:    0 pid: 2347 ppid:     2 flags:0x00004000\n  [372.787776] Call Trace:\n  [372.801652]  <TASK>\n  [372.812961]  __schedule+0xb56/0x4850\n  [372.830011]  ? io_schedule_timeout+0x190/0x190\n  [372.852547]  ? lockdep_hardirqs_on+0x7e/0x100\n  [372.871761]  ? _raw_spin_unlock_irqrestore+0x3e/0x60\n  [372.886792]  schedule+0xe0/0x270\n  [372.901685]  wait_current_trans+0x22c/0x310 [btrfs]\n  [372.919743]  ? btrfs_put_transaction+0x3d0/0x3d0 [btrfs]\n  [372.938923]  ? finish_wait+0x270/0x270\n  [372.959085]  ? join_transaction+0xc7\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/26b3901d20bf9da2c6a00cb1fb48932166f80a45"
          },
          {
            "url": "https://git.kernel.org/stable/c/31198e58c09e21d4f65c49d2361f76b87aca4c3f"
          },
          {
            "url": "https://git.kernel.org/stable/c/32747e01436aac8ef93fe85b5b523b4f3b52f040"
          },
          {
            "url": "https://git.kernel.org/stable/c/89d4cca583fc9594ee7d1a0bc986886d6fb587e6"
          },
          {
            "url": "https://git.kernel.org/stable/c/e804861bd4e69cc5fe1053eedcb024982dde8e48"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48735",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:11.890",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nALSA: hda: Fix UAF of leds class devs at unbinding\nThe LED class devices that are created by HD-audio codec drivers are\nregistered via devm_led_classdev_register() and associated with the\nHD-audio codec device.  Unfortunately, it turned out that the devres\nrelease doesn't work for this case; namely, since the codec resource\nrelease happens before the devm call chain, it triggers a NULL\ndereference or a UAF for a stale set_brightness_delay callback.\nFor fixing the bug, this patch changes the LED class device register\nand unregister in a manual manner without devres, keeping the\ninstances in hda_gen_spec.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0e629052f013eeb61494d4df2f1f647c2a9aef47"
          },
          {
            "url": "https://git.kernel.org/stable/c/549f8ffc7b2f7561bea7f90930b6c5104318e87b"
          },
          {
            "url": "https://git.kernel.org/stable/c/813e9f3e06d22e29872d4fd51b54992d89cf66c8"
          },
          {
            "url": "https://git.kernel.org/stable/c/a7de1002135cf94367748ffc695a29812d7633b5"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48736",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:11.973",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nASoC: ops: Reject out of bounds values in snd_soc_put_xr_sx()\nWe don't currently validate that the values being set are within the range\nwe advertised to userspace as being valid, do so and reject any values\nthat are out of range.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/17e16a66b4f9a310713d8599e6e1ca4a0c9fd28c"
          },
          {
            "url": "https://git.kernel.org/stable/c/4cf28e9ae6e2e11a044be1bcbcfa1b0d8675fe4d"
          },
          {
            "url": "https://git.kernel.org/stable/c/54abca038e287d3746dd40016514670a7f654c5c"
          },
          {
            "url": "https://git.kernel.org/stable/c/6877f87579ed830f9ff6d478539074f035d04bfb"
          },
          {
            "url": "https://git.kernel.org/stable/c/7659f25a80e6affb784b690df8994b79b4212fd4"
          },
          {
            "url": "https://git.kernel.org/stable/c/b0a7836ecf1345814a7d8ef748fb797c520dad18"
          },
          {
            "url": "https://git.kernel.org/stable/c/e09cf398e8c6db69c620b6d8073abc4377a07af5"
          },
          {
            "url": "https://git.kernel.org/stable/c/fd9a23319f16e7031f0d8c98eed6e093c2927229"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48737",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:12.060",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nASoC: ops: Reject out of bounds values in snd_soc_put_volsw_sx()\nWe don't currently validate that the values being set are within the range\nwe advertised to userspace as being valid, do so and reject any values\nthat are out of range.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/038f8b7caa74d29e020949a43ca368c93f6b29b9"
          },
          {
            "url": "https://git.kernel.org/stable/c/4977491e4b3aad8567f57e2a9992d251410c1db3"
          },
          {
            "url": "https://git.kernel.org/stable/c/4f1e50d6a9cf9c1b8c859d449b5031cacfa8404e"
          },
          {
            "url": "https://git.kernel.org/stable/c/9a12fcbf3c622f9bf6b110a873d62b0cba93972e"
          },
          {
            "url": "https://git.kernel.org/stable/c/9e5c40b5706d8aae2cf70bd7e01f0b4575a642d0"
          },
          {
            "url": "https://git.kernel.org/stable/c/c33402b056de61104b6146dedbe138ca8d7ec62b"
          },
          {
            "url": "https://git.kernel.org/stable/c/e8e07c5e25a29e2a6f119fd947f55d7a55eb8a13"
          },
          {
            "url": "https://git.kernel.org/stable/c/ef6cd9eeb38062a145802b7b56be7ae1090e165e"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48738",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:12.150",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nASoC: ops: Reject out of bounds values in snd_soc_put_volsw()\nWe don't currently validate that the values being set are within the range\nwe advertised to userspace as being valid, do so and reject any values\nthat are out of range.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/40f598698129b5ceaf31012f9501b775c7b6e57d"
          },
          {
            "url": "https://git.kernel.org/stable/c/586ef863c94354a7e00e5ae5ef01443d1dc99bc7"
          },
          {
            "url": "https://git.kernel.org/stable/c/65a61b1f56f5386486757930069fbdce94af08bf"
          },
          {
            "url": "https://git.kernel.org/stable/c/68fd718724284788fc5f379e0b7cac541429ece7"
          },
          {
            "url": "https://git.kernel.org/stable/c/817f7c9335ec01e0f5e8caffc4f1dcd5e458a4c0"
          },
          {
            "url": "https://git.kernel.org/stable/c/9e8895f1b3d4433f6d78aa6578e9db61ca6e6830"
          },
          {
            "url": "https://git.kernel.org/stable/c/a9394f21fba027147bf275b083c77955864c366a"
          },
          {
            "url": "https://git.kernel.org/stable/c/bb72d2dda85564c66d909108ea6903937a41679d"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48739",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:12.243",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nASoC: hdmi-codec: Fix OOB memory accesses\nCorrect size of iec_status array by changing it to the size of status\narray of the struct snd_aes_iec958. This fixes out-of-bounds slab\nread accesses made by memcpy() of the hdmi-codec driver. This problem\nis reported by KASAN.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/06feec6005c9d9500cd286ec440aabf8b2ddd94d"
          },
          {
            "url": "https://git.kernel.org/stable/c/10007bd96b6c4c3cfaea9e76c311b06a07a5e260"
          },
          {
            "url": "https://git.kernel.org/stable/c/1552e66be325a21d7eff49f46013fb402165a0ac"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48740",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:12.330",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nselinux: fix double free of cond_list on error paths\nOn error path from cond_read_list() and duplicate_policydb_cond_list()\nthe cond_list_destroy() gets called a second time in caller functions,\nresulting in NULL pointer deref.  Fix this by resetting the\ncond_list_len to 0 in cond_list_destroy(), making subsequent calls a\nnoop.\nAlso consistently reset the cond_list pointer to NULL after freeing.\n[PM: fix line lengths in the description]",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/186edf7e368c40d06cf727a1ad14698ea67b74ad"
          },
          {
            "url": "https://git.kernel.org/stable/c/70caa32e6d81f45f0702070c0e4dfe945e92fbd7"
          },
          {
            "url": "https://git.kernel.org/stable/c/7ed9cbf7ac0d4ed86b356e1b944304ae9ee450d4"
          },
          {
            "url": "https://git.kernel.org/stable/c/f446089a268c8fc6908488e991d28a9b936293db"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48741",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:12.430",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\novl: fix NULL pointer dereference in copy up warning\nThis patch is fixing a NULL pointer dereference to get a recently\nintroduced warning message working.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4ee7e4a6c9b298da44029ed9ec8ed23ae49cc209"
          },
          {
            "url": "https://git.kernel.org/stable/c/9c7f8a35c5a83740c0e3ea540b6ad145c50d79aa"
          },
          {
            "url": "https://git.kernel.org/stable/c/e6b678c1a3673de6a5d2f4e22bb725a086a0701a"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48742",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:12.517",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nrtnetlink: make sure to refresh master_dev/m_ops in __rtnl_newlink()\nWhile looking at one unrelated syzbot bug, I found the replay logic\nin __rtnl_newlink() to potentially trigger use-after-free.\nIt is better to clear master_dev and m_ops inside the loop,\nin case we have to replay it.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2cf180360d66bd657e606c1217e0e668e6faa303"
          },
          {
            "url": "https://git.kernel.org/stable/c/36a9a0aee881940476b254e0352581401b23f210"
          },
          {
            "url": "https://git.kernel.org/stable/c/3bbe2019dd12b8d13671ee6cda055d49637b4c39"
          },
          {
            "url": "https://git.kernel.org/stable/c/7d9211678c0f0624f74cdff36117ab8316697bb8"
          },
          {
            "url": "https://git.kernel.org/stable/c/a01e60a1ec6bef9be471fb7182a33c6d6f124e93"
          },
          {
            "url": "https://git.kernel.org/stable/c/bd43771ee9759dd9dfae946bff190e2c5a120de5"
          },
          {
            "url": "https://git.kernel.org/stable/c/c6f6f2444bdbe0079e41914a35081530d0409963"
          },
          {
            "url": "https://git.kernel.org/stable/c/def5e7070079b2a214b3b1a2fbec623e6fbfe34a"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48743",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:12.610",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: amd-xgbe: Fix skb data length underflow\nThere will be BUG_ON() triggered in include/linux/skbuff.h leading to\nintermittent kernel panic, when the skb length underflow is detected.\nFix this by dropping the packet if such length underflows are seen\nbecause of inconsistencies in the hardware descriptors.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/34aeb4da20f93ac80a6291a2dbe7b9c6460e9b26"
          },
          {
            "url": "https://git.kernel.org/stable/c/4d3fcfe8464838b3920bc2b939d888e0b792934e"
          },
          {
            "url": "https://git.kernel.org/stable/c/5aac9108a180fc06e28d4e7fb00247ce603b72ee"
          },
          {
            "url": "https://git.kernel.org/stable/c/617f9934bb37993b9813832516f318ba874bcb7d"
          },
          {
            "url": "https://git.kernel.org/stable/c/9892742f035f7aa7dcd2bb0750effa486db89576"
          },
          {
            "url": "https://git.kernel.org/stable/c/9924c80bd484340191e586110ca22bff23a49f2e"
          },
          {
            "url": "https://git.kernel.org/stable/c/db6fd92316a254be2097556f01bccecf560e53ce"
          },
          {
            "url": "https://git.kernel.org/stable/c/e8f73f620fee5f52653ed2da360121e4446575c5"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48744",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:12.700",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/mlx5e: Avoid field-overflowing memcpy()\nIn preparation for FORTIFY_SOURCE performing compile-time and run-time\nfield bounds checking for memcpy(), memmove(), and memset(), avoid\nintentionally writing across neighboring fields.\nUse flexible arrays instead of zero-element arrays (which look like they\nare always overflowing) and split the cross-field memcpy() into two halves\nthat can be appropriately bounds-checked by the compiler.\nWe were doing:\n\t#define ETH_HLEN  14\n\t#define VLAN_HLEN  4\n\t...\n\t#define MLX5E_XDP_MIN_INLINE (ETH_HLEN + VLAN_HLEN)\n\t...\n        struct mlx5e_tx_wqe      *wqe  = mlx5_wq_cyc_get_wqe(wq, pi);\n\t...\n        struct mlx5_wqe_eth_seg  *eseg = &wqe->eth;\n        struct mlx5_wqe_data_seg *dseg = wqe->data;\n\t...\n\tmemcpy(eseg->inline_hdr.start, xdptxd->data, MLX5E_XDP_MIN_INLINE);\ntarget is wqe->eth.inline_hdr.start (which the compiler sees as being\n2 bytes in size), but copying 18, intending to write across start\n(really vlan_tci, 2 bytes). The remaining 16 bytes get written into\nwqe->data[0], covering byte_count (4 bytes), lkey (4 bytes), and addr\n(8 bytes).\nstruct mlx5e_tx_wqe {\n        struct mlx5_wqe_ctrl_seg   ctrl;                 /*     0    16 */\n        struct mlx5_wqe_eth_seg    eth;                  /*    16    16 */\n        struct mlx5_wqe_data_seg   data[];               /*    32     0 */\n        /* size: 32, cachelines: 1, members: 3 */\n        /* last cacheline: 32 bytes */\n};\nstruct mlx5_wqe_eth_seg {\n        u8                         swp_outer_l4_offset;  /*     0     1 */\n        u8                         swp_outer_l3_offset;  /*     1     1 */\n        u8                         swp_inner_l4_offset;  /*     2     1 */\n        u8                         swp_inner_l3_offset;  /*     3     1 */\n        u8                         cs_flags;             /*     4     1 */\n        u8                         swp_flags;            /*     5     1 */\n        __be16                     mss;                  /*     6     2 */\n        __be32                     flow_table_metadata;  /*     8     4 */\n        union {\n                struct {\n                        __be16     sz;                   /*    12     2 */\n                        u8         start[2];             /*    14     2 */\n                } inline_hdr;                            /*    12     4 */\n                struct {\n                        __be16     type;                 /*    12     2 */\n                        __be16     vlan_tci;             /*    14     2 */\n                } insert;                                /*    12     4 */\n                __be32             trailer;              /*    12     4 */\n        };                                               /*    12     4 */\n        /* size: 16, cachelines: 1, members: 9 */\n        /* last cacheline: 16 bytes */\n};\nstruct mlx5_wqe_data_seg {\n        __be32                     byte_count;           /*     0     4 */\n        __be32                     lkey;                 /*     4     4 */\n        __be64                     addr;                 /*     8     8 */\n        /* size: 16, cachelines: 1, members: 3 */\n        /* last cacheline: 16 bytes */\n};\nSo, split the memcpy() so the compiler can reason about the buffer\nsizes.\n\"pahole\" shows no size nor member offset changes to struct mlx5e_tx_wqe\nnor struct mlx5e_umr_wqe. \"objdump -d\" shows no meaningful object\ncode changes (i.e. only source line number induced differences and\noptimizations).",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/8fbdf8c8b8ab82beab882175157650452c46493e"
          },
          {
            "url": "https://git.kernel.org/stable/c/ad5185735f7dab342fdd0dd41044da4c9ccfef67"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48745",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:12.783",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/mlx5: Use del_timer_sync in fw reset flow of halting poll\nSubstitute del_timer() with del_timer_sync() in fw reset polling\ndeactivation flow, in order to prevent a race condition which occurs\nwhen del_timer() is called and timer is deactivated while another\nprocess is handling the timer interrupt. A situation that led to\nthe following call trace:\n\tRIP: 0010:run_timer_softirq+0x137/0x420\n\t<IRQ>\n\trecalibrate_cpu_khz+0x10/0x10\n\tktime_get+0x3e/0xa0\n\t? sched_clock_cpu+0xb/0xc0\n\t__do_softirq+0xf5/0x2ea\n\tirq_exit_rcu+0xc1/0xf0\n\tsysvec_apic_timer_interrupt+0x9e/0xc0\n\tasm_sysvec_apic_timer_interrupt+0x12/0x20\n\t</IRQ>",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2a038dd1d942f8fbc495c58fa592ff24af05f1c2"
          },
          {
            "url": "https://git.kernel.org/stable/c/3c5193a87b0fea090aa3f769d020337662d87b5e"
          },
          {
            "url": "https://git.kernel.org/stable/c/502c37b033fab7cde3e95a570af4f073306be45e"
          },
          {
            "url": "https://git.kernel.org/stable/c/f895ebeb44d09d02674cfdd0cfc2bf687603918c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48746",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:12.870",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/mlx5e: Fix handling of wrong devices during bond netevent\nCurrent implementation of bond netevent handler only check if\nthe handled netdev is VF representor and it missing a check if\nthe VF representor is on the same phys device of the bond handling\nthe netevent.\nFix by adding the missing check and optimizing the check if\nthe netdev is VF representor so it will not access uninitialized\nprivate data and crashes.\nBUG: kernel NULL pointer dereference, address: 000000000000036c\nPGD 0 P4D 0\nOops: 0000 [#1] SMP NOPTI\nWorkqueue: eth3bond0 bond_mii_monitor [bonding]\nRIP: 0010:mlx5e_is_uplink_rep+0xc/0x50 [mlx5_core]\nRSP: 0018:ffff88812d69fd60 EFLAGS: 00010282\nRAX: 0000000000000000 RBX: ffff8881cf800000 RCX: 0000000000000000\nRDX: ffff88812d69fe10 RSI: 000000000000001b RDI: ffff8881cf800880\nRBP: ffff8881cf800000 R08: 00000445cabccf2b R09: 0000000000000008\nR10: 0000000000000004 R11: 0000000000000008 R12: ffff88812d69fe10\nR13: 00000000fffffffe R14: ffff88820c0f9000 R15: 0000000000000000\nFS:  0000000000000000(0000) GS:ffff88846fb00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000000000000036c CR3: 0000000103d80006 CR4: 0000000000370ea0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n mlx5e_eswitch_uplink_rep+0x31/0x40 [mlx5_core]\n mlx5e_rep_is_lag_netdev+0x94/0xc0 [mlx5_core]\n mlx5e_rep_esw_bond_netevent+0xeb/0x3d0 [mlx5_core]\n raw_notifier_call_chain+0x41/0x60\n call_netdevice_notifiers_info+0x34/0x80\n netdev_lower_state_changed+0x4e/0xa0\n bond_mii_monitor+0x56b/0x640 [bonding]\n process_one_work+0x1b9/0x390\n worker_thread+0x4d/0x3d0\n ? rescuer_thread+0x350/0x350\n kthread+0x124/0x150\n ? set_kthread_struct+0x40/0x40\n ret_from_fork+0x1f/0x30",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4fad499d7fece448e7230d5e5b92f6d8a073e0bb"
          },
          {
            "url": "https://git.kernel.org/stable/c/a01ee1b8165f4161459b5ec4e728bc7130fe8cd4"
          },
          {
            "url": "https://git.kernel.org/stable/c/ec41332e02bd0acf1f24206867bb6a02f5877a62"
          },
          {
            "url": "https://git.kernel.org/stable/c/fe70126da6063c29ca161cdec7ad1dae9af836b3"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48747",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:12.960",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nblock: Fix wrong offset in bio_truncate()\nbio_truncate() clears the buffer outside of last block of bdev, however\ncurrent bio_truncate() is using the wrong offset of page. So it can\nreturn the uninitialized data.\nThis happened when both of truncated/corrupted FS and userspace (via\nbdev) are trying to read the last of bdev.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3ee859e384d453d6ac68bfd5971f630d9fa46ad3"
          },
          {
            "url": "https://git.kernel.org/stable/c/4633a79ff8bc82770486a063a08b55e5162521d8"
          },
          {
            "url": "https://git.kernel.org/stable/c/6cbf4c731d7812518cd857c2cfc3da9fd120f6ae"
          },
          {
            "url": "https://git.kernel.org/stable/c/941d5180c430ce5b0f7a3622ef9b76077bfa3d82"
          },
          {
            "url": "https://git.kernel.org/stable/c/b63e120189fd92aff00096d11e2fc5253f60248b"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48748",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:13.047",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: bridge: vlan: fix memory leak in __allowed_ingress\nWhen using per-vlan state, if vlan snooping and stats are disabled,\nuntagged or priority-tagged ingress frame will go to check pvid state.\nIf the port state is forwarding and the pvid state is not\nlearning/forwarding, untagged or priority-tagged frame will be dropped\nbut skb memory is not freed.\nShould free skb when __allowed_ingress returns false.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/14be8d448fca6fe7b2a413831eedd55aef6c6511"
          },
          {
            "url": "https://git.kernel.org/stable/c/446ff1fc37c74093e81db40811a07b5a19f1d797"
          },
          {
            "url": "https://git.kernel.org/stable/c/c5e216e880fa6f2cd9d4a6541269377657163098"
          },
          {
            "url": "https://git.kernel.org/stable/c/fd20d9738395cf8e27d0a17eba34169699fccdff"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48749",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:13.143",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/msm/dpu: invalid parameter check in dpu_setup_dspp_pcc\nThe function performs a check on the \"ctx\" input parameter, however, it\nis used before the check.\nInitialize the \"base\" variable after the sanity check to avoid a\npossible NULL pointer dereference.\nAddresses-Coverity-ID: 1493866 (\"Null pointer dereference\")",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/170b22234d5495f5e0844246e23f004639ee89ba"
          },
          {
            "url": "https://git.kernel.org/stable/c/1ebc18836d5df09061657f8c548e594cbb519476"
          },
          {
            "url": "https://git.kernel.org/stable/c/8f069f6dde518dfebe86e848508c07e497bd9298"
          },
          {
            "url": "https://git.kernel.org/stable/c/93a6e920d8ccb4df846c03b6e72f7e08843d294c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48750",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:13.223",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nhwmon: (nct6775) Fix crash in clear_caseopen\nPawe? Marciniak reports the following crash, observed when clearing\nthe chassis intrusion alarm.\nBUG: kernel NULL pointer dereference, address: 0000000000000028\nPGD 0 P4D 0\nOops: 0000 [#1] PREEMPT SMP PTI\nCPU: 3 PID: 4815 Comm: bash Tainted: G S                5.16.2-200.fc35.x86_64 #1\nHardware name: To Be Filled By O.E.M. To Be Filled By O.E.M./Z97 Extreme4, BIOS P2.60A 05/03/2018\nRIP: 0010:clear_caseopen+0x5a/0x120 [nct6775]\nCode: 68 70 e8 e9 32 b1 e3 85 c0 0f 85 d2 00 00 00 48 83 7c 24 ...\nRSP: 0018:ffffabcb02803dd8 EFLAGS: 00010246\nRAX: 0000000000000000 RBX: 0000000000000002 RCX: 0000000000000000\nRDX: ffff8e8808192880 RSI: 0000000000000000 RDI: ffff8e87c7509a68\nRBP: 0000000000000000 R08: 0000000000000001 R09: 000000000000000a\nR10: 000000000000000a R11: f000000000000000 R12: 000000000000001f\nR13: ffff8e87c7509828 R14: ffff8e87c7509a68 R15: ffff8e88494527a0\nFS:  00007f4db9151740(0000) GS:ffff8e8ebfec0000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000000028 CR3: 0000000166b66001 CR4: 00000000001706e0\nCall Trace:\n <TASK>\n kernfs_fop_write_iter+0x11c/0x1b0\n new_sync_write+0x10b/0x180\n vfs_write+0x209/0x2a0\n ksys_write+0x4f/0xc0\n do_syscall_64+0x3b/0x90\n entry_SYSCALL_64_after_hwframe+0x44/0xae\nThe problem is that the device passed to clear_caseopen() is the hwmon\ndevice, not the platform device, and the platform data is not set in the\nhwmon device. Store the pointer to sio_data in struct nct6775_data and\nget if from there if needed.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/79da533d3cc717ccc05ddbd3190da8a72bc2408b"
          },
          {
            "url": "https://git.kernel.org/stable/c/cfb7d12f2e4a4d694f49e9b4ebb352f7b67cdfbb"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48751",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:13.310",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/smc: Transitional solution for clcsock race issue\nWe encountered a crash in smc_setsockopt() and it is caused by\naccessing smc->clcsock after clcsock was released.\n BUG: kernel NULL pointer dereference, address: 0000000000000020\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n PGD 0 P4D 0\n Oops: 0000 [#1] PREEMPT SMP PTI\n CPU: 1 PID: 50309 Comm: nginx Kdump: loaded Tainted: G E     5.16.0-rc4+ #53\n RIP: 0010:smc_setsockopt+0x59/0x280 [smc]\n Call Trace:\n  <TASK>\n  __sys_setsockopt+0xfc/0x190\n  __x64_sys_setsockopt+0x20/0x30\n  do_syscall_64+0x34/0x90\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\n RIP: 0033:0x7f16ba83918e\n  </TASK>\nThis patch tries to fix it by holding clcsock_release_lock and\nchecking whether clcsock has already been released before access.\nIn case that a crash of the same reason happens in smc_getsockopt()\nor smc_switch_to_fallback(), this patch also checkes smc->clcsock\nin them too. And the caller of smc_switch_to_fallback() will identify\nwhether fallback succeeds according to the return value.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/38f0bdd548fd2ef5d481b88d8a2bfef968452e34"
          },
          {
            "url": "https://git.kernel.org/stable/c/4284225cd8001e134f5cf533a7cd244bbb654d0f"
          },
          {
            "url": "https://git.kernel.org/stable/c/c0bf3d8a943b6f2e912b7c1de03e2ef28e76f760"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48752",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:13.397",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\npowerpc/perf: Fix power_pmu_disable to call clear_pmi_irq_pending only if PMI is pending\nRunning selftest with CONFIG_PPC_IRQ_SOFT_MASK_DEBUG enabled in kernel\ntriggered below warning:\n[  172.851380] ------------[ cut here ]------------\n[  172.851391] WARNING: CPU: 8 PID: 2901 at arch/powerpc/include/asm/hw_irq.h:246 power_pmu_disable+0x270/0x280\n[  172.851402] Modules linked in: dm_mod bonding nft_ct nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables rfkill nfnetlink sunrpc xfs libcrc32c pseries_rng xts vmx_crypto uio_pdrv_genirq uio sch_fq_codel ip_tables ext4 mbcache jbd2 sd_mod t10_pi sg ibmvscsi ibmveth scsi_transport_srp fuse\n[  172.851442] CPU: 8 PID: 2901 Comm: lost_exception_ Not tainted 5.16.0-rc5-03218-g798527287598 #2\n[  172.851451] NIP:  c00000000013d600 LR: c00000000013d5a4 CTR: c00000000013b180\n[  172.851458] REGS: c000000017687860 TRAP: 0700   Not tainted  (5.16.0-rc5-03218-g798527287598)\n[  172.851465] MSR:  8000000000029033 <SF,EE,ME,IR,DR,RI,LE>  CR: 48004884  XER: 20040000\n[  172.851482] CFAR: c00000000013d5b4 IRQMASK: 1\n[  172.851482] GPR00: c00000000013d5a4 c000000017687b00 c000000002a10600 0000000000000004\n[  172.851482] GPR04: 0000000082004000 c0000008ba08f0a8 0000000000000000 00000008b7ed0000\n[  172.851482] GPR08: 00000000446194f6 0000000000008000 c00000000013b118 c000000000d58e68\n[  172.851482] GPR12: c00000000013d390 c00000001ec54a80 0000000000000000 0000000000000000\n[  172.851482] GPR16: 0000000000000000 0000000000000000 c000000015d5c708 c0000000025396d0\n[  172.851482] GPR20: 0000000000000000 0000000000000000 c00000000a3bbf40 0000000000000003\n[  172.851482] GPR24: 0000000000000000 c0000008ba097400 c0000000161e0d00 c00000000a3bb600\n[  172.851482] GPR28: c000000015d5c700 0000000000000001 0000000082384090 c0000008ba0020d8\n[  172.851549] NIP [c00000000013d600] power_pmu_disable+0x270/0x280\n[  172.851557] LR [c00000000013d5a4] power_pmu_disable+0x214/0x280\n[  172.851565] Call Trace:\n[  172.851568] [c000000017687b00] [c00000000013d5a4] power_pmu_disable+0x214/0x280 (unreliable)\n[  172.851579] [c000000017687b40] [c0000000003403ac] perf_pmu_disable+0x4c/0x60\n[  172.851588] [c000000017687b60] [c0000000003445e4] __perf_event_task_sched_out+0x1d4/0x660\n[  172.851596] [c000000017687c50] [c000000000d1175c] __schedule+0xbcc/0x12a0\n[  172.851602] [c000000017687d60] [c000000000d11ea8] schedule+0x78/0x140\n[  172.851608] [c000000017687d90] [c0000000001a8080] sys_sched_yield+0x20/0x40\n[  172.851615] [c000000017687db0] [c0000000000334dc] system_call_exception+0x18c/0x380\n[  172.851622] [c000000017687e10] [c00000000000c74c] system_call_common+0xec/0x268\nThe warning indicates that MSR_EE being set(interrupt enabled) when\nthere was an overflown PMC detected. This could happen in\npower_pmu_disable since it runs under interrupt soft disable\ncondition ( local_irq_save ) and not with interrupts hard disabled.\ncommit 2c9ac51b850d (\"powerpc/perf: Fix PMU callbacks to clear\npending PMI before resetting an overflown PMC\") intended to clear\nPMI pending bit in Paca when disabling the PMU. It could happen\nthat PMC gets overflown while code is in power_pmu_disable\ncallback function. Hence add a check to see if PMI pending bit\nis set in Paca before clearing it via clear_pmi_pending.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/28aaed966e76807a71de79dd40a8eee9042374dd"
          },
          {
            "url": "https://git.kernel.org/stable/c/55402a4618721f350a9ab660bb42717d8aa18e7c"
          },
          {
            "url": "https://git.kernel.org/stable/c/fa4ad064a6bd49208221df5e62adf27b426d1720"
          },
          {
            "url": "https://git.kernel.org/stable/c/fb6433b48a178d4672cb26632454ee0b21056eaa"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48753",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:13.480",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nblock: fix memory leak in disk_register_independent_access_ranges\nkobject_init_and_add() takes reference even when it fails.\nAccording to the doc of kobject_init_and_add()\n   If this function returns an error, kobject_put() must be called to\n   properly clean up the memory associated with the object.\nFix this issue by adding kobject_put().\nCallback function blk_ia_ranges_sysfs_release() in kobject_put()\ncan handle the pointer \"iars\" properly.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/83114df32ae779df57e0af99a8ba6c3968b2ba3d"
          },
          {
            "url": "https://git.kernel.org/stable/c/fe4214a07e0b53d2af711f57519e33739c5df23f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48754",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:13.563",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nphylib: fix potential use-after-free\nCommit bafbdd527d56 (\"phylib: Add device reset GPIO support\") added call\nto phy_device_reset(phydev) after the put_device() call in phy_detach().\nThe comment before the put_device() call says that the phydev might go\naway with put_device().\nFix potential use-after-free by calling phy_device_reset() before\nput_device().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/67d271760b037ce0806d687ee6057edc8afd4205"
          },
          {
            "url": "https://git.kernel.org/stable/c/aefaccd19379d6c4620269a162bfb88ff687f289"
          },
          {
            "url": "https://git.kernel.org/stable/c/bd024e36f68174b1793906c39ca16cee0c9295c2"
          },
          {
            "url": "https://git.kernel.org/stable/c/cb2fab10fc5e7a3aa1bb0a68a3abdcf3e37852af"
          },
          {
            "url": "https://git.kernel.org/stable/c/cbda1b16687580d5beee38273f6241ae3725960c"
          },
          {
            "url": "https://git.kernel.org/stable/c/f39027cbada43b33566c312e6be3db654ca3ad17"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48755",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:13.653",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\npowerpc64/bpf: Limit 'ldbrx' to processors compliant with ISA v2.06\nJohan reported the below crash with test_bpf on ppc64 e5500:\n  test_bpf: #296 ALU_END_FROM_LE 64: 0x0123456789abcdef -> 0x67452301 jited:1\n  Oops: Exception in kernel mode, sig: 4 [#1]\n  BE PAGE_SIZE=4K SMP NR_CPUS=24 QEMU e500\n  Modules linked in: test_bpf(+)\n  CPU: 0 PID: 76 Comm: insmod Not tainted 5.14.0-03771-g98c2059e008a-dirty #1\n  NIP:  8000000000061c3c LR: 80000000006dea64 CTR: 8000000000061c18\n  REGS: c0000000032d3420 TRAP: 0700   Not tainted (5.14.0-03771-g98c2059e008a-dirty)\n  MSR:  0000000080089000 <EE,ME>  CR: 88002822  XER: 20000000 IRQMASK: 0\n  <...>\n  NIP [8000000000061c3c] 0x8000000000061c3c\n  LR [80000000006dea64] .__run_one+0x104/0x17c [test_bpf]\n  Call Trace:\n   .__run_one+0x60/0x17c [test_bpf] (unreliable)\n   .test_bpf_init+0x6a8/0xdc8 [test_bpf]\n   .do_one_initcall+0x6c/0x28c\n   .do_init_module+0x68/0x28c\n   .load_module+0x2460/0x2abc\n   .__do_sys_init_module+0x120/0x18c\n   .system_call_exception+0x110/0x1b8\n   system_call_common+0xf0/0x210\n  --- interrupt: c00 at 0x101d0acc\n  <...>\n  ---[ end trace 47b2bf19090bb3d0 ]---\n  Illegal instruction\nThe illegal instruction turned out to be 'ldbrx' emitted for\nBPF_FROM_[L|B]E, which was only introduced in ISA v2.06. Guard use of\nthe same and implement an alternative approach for older processors.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/129c71829d7f46423d95c19e8d87ce956d4c6e1c"
          },
          {
            "url": "https://git.kernel.org/stable/c/3bfbc00587dc883eaed383558ae512a351c2cd09"
          },
          {
            "url": "https://git.kernel.org/stable/c/3f5f766d5f7f95a69a630da3544a1a0cee1cdddf"
          },
          {
            "url": "https://git.kernel.org/stable/c/aaccfeeee1630b155e8ff0d6c449d3de1ef86e73"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48756",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:13.740",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/msm/dsi: invalid parameter check in msm_dsi_phy_enable\nThe function performs a check on the \"phy\" input parameter, however, it\nis used before the check.\nInitialize the \"dev\" variable after the sanity check to avoid a possible\nNULL pointer dereference.\nAddresses-Coverity-ID: 1493860 (\"Null pointer dereference\")",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2b7e7df1eacd280e561ede3e977853606871c951"
          },
          {
            "url": "https://git.kernel.org/stable/c/56480fb10b976581a363fd168dc2e4fbee87a1a7"
          },
          {
            "url": "https://git.kernel.org/stable/c/581317b1f001b7509041544d7019b75571daa100"
          },
          {
            "url": "https://git.kernel.org/stable/c/5e761a2287234bc402ba7ef07129f5103bcd775c"
          },
          {
            "url": "https://git.kernel.org/stable/c/6d9f8ba28f3747ca0f910a363e46f1114856dbbe"
          },
          {
            "url": "https://git.kernel.org/stable/c/79c0b5287ded74f4eacde4dfd8aa0a76cbd853b5"
          },
          {
            "url": "https://git.kernel.org/stable/c/ca63eeb70fcb53c42e1fe54e1735a54d8e7759fd"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48757",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:13.823",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: fix information leakage in /proc/net/ptype\nIn one net namespace, after creating a packet socket without binding\nit to a device, users in other net namespaces can observe the new\n`packet_type` added by this packet socket by reading `/proc/net/ptype`\nfile. This is minor information leakage as packet socket is\nnamespace aware.\nAdd a net pointer in `packet_type` to keep the net namespace of\nof corresponding packet socket. In `ptype_seq_show`, this net pointer\nmust be checked when it is not NULL.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/47934e06b65637c88a762d9c98329ae6e3238888"
          },
          {
            "url": "https://git.kernel.org/stable/c/839ec7039513a4f84bfbaff953a9393471176bee"
          },
          {
            "url": "https://git.kernel.org/stable/c/8f88c78d24f6f346919007cd459fd7e51a8c7779"
          },
          {
            "url": "https://git.kernel.org/stable/c/b67ad6170c0ea87391bb253f35d1f78857736e54"
          },
          {
            "url": "https://git.kernel.org/stable/c/be1ca30331c7923c6f376610c1bd6059be9b1908"
          },
          {
            "url": "https://git.kernel.org/stable/c/c38023032a598ec6263e008d62c7f02def72d5c7"
          },
          {
            "url": "https://git.kernel.org/stable/c/db044d97460ea792110eb8b971e82569ded536c6"
          },
          {
            "url": "https://git.kernel.org/stable/c/e372ecd455b6ebc7720f52bf4b5f5d44d02f2092"
          },
          {
            "url": "https://git.kernel.org/stable/c/e43669c77cb3a742b7d84ecdc7c68c4167a7709b"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48758",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:13.927",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nscsi: bnx2fc: Flush destroy_work queue before calling bnx2fc_interface_put()\nThe bnx2fc_destroy() functions are removing the interface before calling\ndestroy_work. This results multiple WARNings from sysfs_remove_group() as\nthe controller rport device attributes are removed too early.\nReplace the fcoe_port's destroy_work queue. It's not needed.\nThe problem is easily reproducible with the following steps.\nExample:\n  $ dmesg -w &\n  $ systemctl enable --now fcoe\n  $ fipvlan -s -c ens2f1\n  $ fcoeadm -d ens2f1.802\n  [  583.464488] host2: libfc: Link down on port (7500a1)\n  [  583.472651] bnx2fc: 7500a1 - rport not created Yet!!\n  [  583.490468] ------------[ cut here ]------------\n  [  583.538725] sysfs group 'power' not found for kobject 'rport-2:0-0'\n  [  583.568814] WARNING: CPU: 3 PID: 192 at fs/sysfs/group.c:279 sysfs_remove_group+0x6f/0x80\n  [  583.607130] Modules linked in: dm_service_time 8021q garp mrp stp llc bnx2fc cnic uio rpcsec_gss_krb5 auth_rpcgss nfsv4 ...\n  [  583.942994] CPU: 3 PID: 192 Comm: kworker/3:2 Kdump: loaded Not tainted 5.14.0-39.el9.x86_64 #1\n  [  583.984105] Hardware name: HP ProLiant DL120 G7, BIOS J01 07/01/2013\n  [  584.016535] Workqueue: fc_wq_2 fc_rport_final_delete [scsi_transport_fc]\n  [  584.050691] RIP: 0010:sysfs_remove_group+0x6f/0x80\n  [  584.074725] Code: ff 5b 48 89 ef 5d 41 5c e9 ee c0 ff ff 48 89 ef e8 f6 b8 ff ff eb d1 49 8b 14 24 48 8b 33 48 c7 c7 ...\n  [  584.162586] RSP: 0018:ffffb567c15afdc0 EFLAGS: 00010282\n  [  584.188225] RAX: 0000000000000000 RBX: ffffffff8eec4220 RCX: 0000000000000000\n  [  584.221053] RDX: ffff8c1586ce84c0 RSI: ffff8c1586cd7cc0 RDI: ffff8c1586cd7cc0\n  [  584.255089] RBP: 0000000000000000 R08: 0000000000000000 R09: ffffb567c15afc00\n  [  584.287954] R10: ffffb567c15afbf8 R11: ffffffff8fbe7f28 R12: ffff8c1486326400\n  [  584.322356] R13: ffff8c1486326480 R14: ffff8c1483a4a000 R15: 0000000000000004\n  [  584.355379] FS:  0000000000000000(0000) GS:ffff8c1586cc0000(0000) knlGS:0000000000000000\n  [  584.394419] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  [  584.421123] CR2: 00007fe95a6f7840 CR3: 0000000107674002 CR4: 00000000000606e0\n  [  584.454888] Call Trace:\n  [  584.466108]  device_del+0xb2/0x3e0\n  [  584.481701]  device_unregister+0x13/0x60\n  [  584.501306]  bsg_unregister_queue+0x5b/0x80\n  [  584.522029]  bsg_remove_queue+0x1c/0x40\n  [  584.541884]  fc_rport_final_delete+0xf3/0x1d0 [scsi_transport_fc]\n  [  584.573823]  process_one_work+0x1e3/0x3b0\n  [  584.592396]  worker_thread+0x50/0x3b0\n  [  584.609256]  ? rescuer_thread+0x370/0x370\n  [  584.628877]  kthread+0x149/0x170\n  [  584.643673]  ? set_kthread_struct+0x40/0x40\n  [  584.662909]  ret_from_fork+0x22/0x30\n  [  584.680002] ---[ end trace 53575ecefa942ece ]---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/00849de10f798a9538242824a51b1756e7110754"
          },
          {
            "url": "https://git.kernel.org/stable/c/262550f29c750f7876b6ed1244281e72b64ebffb"
          },
          {
            "url": "https://git.kernel.org/stable/c/2a12fe8248a38437b95b942bbe85aced72e6e2eb"
          },
          {
            "url": "https://git.kernel.org/stable/c/847f9ea4c5186fdb7b84297e3eeed9e340e83fce"
          },
          {
            "url": "https://git.kernel.org/stable/c/ace7b6ef41251c5fe47f629a9a922382fb7b0a6b"
          },
          {
            "url": "https://git.kernel.org/stable/c/b11e34f7bab21df36f02a5e54fb69e858c09a65d"
          },
          {
            "url": "https://git.kernel.org/stable/c/bf2bd892a0cb14dd2d21f2c658f4b747813be311"
          },
          {
            "url": "https://git.kernel.org/stable/c/c93a290c862ccfa404e42d7420565730d67cbff9"
          },
          {
            "url": "https://git.kernel.org/stable/c/de6336b17a1376db1c0f7a528cce8783db0881c0"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48759",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:14.023",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nrpmsg: char: Fix race between the release of rpmsg_ctrldev and cdev\nstruct rpmsg_ctrldev contains a struct cdev. The current code frees\nthe rpmsg_ctrldev struct in rpmsg_ctrldev_release_device(), but the\ncdev is a managed object, therefore its release is not predictable\nand the rpmsg_ctrldev could be freed before the cdev is entirely\nreleased, as in the backtrace below.\n[   93.625603] ODEBUG: free active (active state 0) object type: timer_list hint: delayed_work_timer_fn+0x0/0x7c\n[   93.636115] WARNING: CPU: 0 PID: 12 at lib/debugobjects.c:488 debug_print_object+0x13c/0x1b0\n[   93.644799] Modules linked in: veth xt_cgroup xt_MASQUERADE rfcomm algif_hash algif_skcipher af_alg uinput ip6table_nat fuse uvcvideo videobuf2_vmalloc venus_enc venus_dec videobuf2_dma_contig hci_uart btandroid btqca snd_soc_rt5682_i2c bluetooth qcom_spmi_temp_alarm snd_soc_rt5682v\n[   93.715175] CPU: 0 PID: 12 Comm: kworker/0:1 Tainted: G    B             5.4.163-lockdep #26\n[   93.723855] Hardware name: Google Lazor (rev3 - 8) with LTE (DT)\n[   93.730055] Workqueue: events kobject_delayed_cleanup\n[   93.735271] pstate: 60c00009 (nZCv daif +PAN +UAO)\n[   93.740216] pc : debug_print_object+0x13c/0x1b0\n[   93.744890] lr : debug_print_object+0x13c/0x1b0\n[   93.749555] sp : ffffffacf5bc7940\n[   93.752978] x29: ffffffacf5bc7940 x28: dfffffd000000000\n[   93.758448] x27: ffffffacdb11a800 x26: dfffffd000000000\n[   93.763916] x25: ffffffd0734f856c x24: dfffffd000000000\n[   93.769389] x23: 0000000000000000 x22: ffffffd0733c35b0\n[   93.774860] x21: ffffffd0751994a0 x20: ffffffd075ec27c0\n[   93.780338] x19: ffffffd075199100 x18: 00000000000276e0\n[   93.785814] x17: 0000000000000000 x16: dfffffd000000000\n[   93.791291] x15: ffffffffffffffff x14: 6e6968207473696c\n[   93.796768] x13: 0000000000000000 x12: ffffffd075e2b000\n[   93.802244] x11: 0000000000000001 x10: 0000000000000000\n[   93.807723] x9 : d13400dff1921900 x8 : d13400dff1921900\n[   93.813200] x7 : 0000000000000000 x6 : 0000000000000000\n[   93.818676] x5 : 0000000000000080 x4 : 0000000000000000\n[   93.824152] x3 : ffffffd0732a0fa4 x2 : 0000000000000001\n[   93.829628] x1 : ffffffacf5bc7580 x0 : 0000000000000061\n[   93.835104] Call trace:\n[   93.837644]  debug_print_object+0x13c/0x1b0\n[   93.841963]  __debug_check_no_obj_freed+0x25c/0x3c0\n[   93.846987]  debug_check_no_obj_freed+0x18/0x20\n[   93.851669]  slab_free_freelist_hook+0xbc/0x1e4\n[   93.856346]  kfree+0xfc/0x2f4\n[   93.859416]  rpmsg_ctrldev_release_device+0x78/0xb8\n[   93.864445]  device_release+0x84/0x168\n[   93.868310]  kobject_cleanup+0x12c/0x298\n[   93.872356]  kobject_delayed_cleanup+0x10/0x18\n[   93.876948]  process_one_work+0x578/0x92c\n[   93.881086]  worker_thread+0x804/0xcf8\n[   93.884963]  kthread+0x2a8/0x314\n[   93.888303]  ret_from_fork+0x10/0x18\nThe cdev_device_add/del() API was created to address this issue (see\ncommit '233ed09d7fda (\"chardev: add helper function to register char\ndevs with a struct device\")'), use it instead of cdev add/del().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1dbb206730f3e5ce90014ad569ddf8167ec4124a"
          },
          {
            "url": "https://git.kernel.org/stable/c/70cb4295ec806b663665e1d2ed15caab6159880e"
          },
          {
            "url": "https://git.kernel.org/stable/c/74d85e9fbc7022a4011102c7474a9c7aeb704a35"
          },
          {
            "url": "https://git.kernel.org/stable/c/85aba11a8ea92a8eef2de95ebbe063086fd62d9c"
          },
          {
            "url": "https://git.kernel.org/stable/c/b7fb2dad571d1e21173c06cef0bced77b323990a"
          },
          {
            "url": "https://git.kernel.org/stable/c/d6cdc6ae542845d4d0ac8b6d99362bde7042a3c7"
          },
          {
            "url": "https://git.kernel.org/stable/c/da27b834c1e0222e149e06caddf7718478086d1b"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48760",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:14.110",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nUSB: core: Fix hang in usb_kill_urb by adding memory barriers\nThe syzbot fuzzer has identified a bug in which processes hang waiting\nfor usb_kill_urb() to return.  It turns out the issue is not unlinking\nthe URB; that works just fine.  Rather, the problem arises when the\nwakeup notification that the URB has completed is not received.\nThe reason is memory-access ordering on SMP systems.  In outline form,\nusb_kill_urb() and __usb_hcd_giveback_urb() operating concurrently on\ndifferent CPUs perform the following actions:\nCPU 0\t\t\t\t\tCPU 1\n----------------------------\t\t---------------------------------\nusb_kill_urb():\t\t\t\t__usb_hcd_giveback_urb():\n  ...\t\t\t\t\t  ...\n  atomic_inc(&urb->reject);\t\t  atomic_dec(&urb->use_count);\n  ...\t\t\t\t\t  ...\n  wait_event(usb_kill_urb_queue,\n\tatomic_read(&urb->use_count) == 0);\n\t\t\t\t\t  if (atomic_read(&urb->reject))\n\t\t\t\t\t\twake_up(&usb_kill_urb_queue);\nConfining your attention to urb->reject and urb->use_count, you can\nsee that the overall pattern of accesses on CPU 0 is:\n\twrite urb->reject, then read urb->use_count;\nwhereas the overall pattern of accesses on CPU 1 is:\n\twrite urb->use_count, then read urb->reject.\nThis pattern is referred to in memory-model circles as SB (for \"Store\nBuffering\"), and it is well known that without suitable enforcement of\nthe desired order of accesses -- in the form of memory barriers -- it\nis entirely possible for one or both CPUs to execute their reads ahead\nof their writes.  The end result will be that sometimes CPU 0 sees the\nold un-decremented value of urb->use_count while CPU 1 sees the old\nun-incremented value of urb->reject.  Consequently CPU 0 ends up on\nthe wait queue and never gets woken up, leading to the observed hang\nin usb_kill_urb().\nThe same pattern of accesses occurs in usb_poison_urb() and the\nfailure pathway of usb_hcd_submit_urb().\nThe problem is fixed by adding suitable memory barriers.  To provide\nproper memory-access ordering in the SB pattern, a full barrier is\nrequired on both CPUs.  The atomic_inc() and atomic_dec() accesses\nthemselves don't provide any memory ordering, but since they are\npresent, we can use the optimized smp_mb__after_atomic() memory\nbarrier in the various routines to obtain the desired effect.\nThis patch adds the necessary memory barriers.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/26fbe9772b8c459687930511444ce443011f86bf"
          },
          {
            "url": "https://git.kernel.org/stable/c/546ba238535d925254e0b3f12012a5c55801e2f3"
          },
          {
            "url": "https://git.kernel.org/stable/c/5904dfd3ddaff3bf4a41c3baf0a8e8f31ed4599b"
          },
          {
            "url": "https://git.kernel.org/stable/c/5f138ef224dffd15d5e5c5b095859719e0038427"
          },
          {
            "url": "https://git.kernel.org/stable/c/9340226388c66a7e090ebb00e91ed64a753b6c26"
          },
          {
            "url": "https://git.kernel.org/stable/c/9c61fce322ac2ef7fecf025285353570d60e41d6"
          },
          {
            "url": "https://git.kernel.org/stable/c/b50f5ca60475710bbc9a3af32fbfc17b1e69c2f0"
          },
          {
            "url": "https://git.kernel.org/stable/c/c9a18f7c5b071dce5e6939568829d40994866ab0"
          },
          {
            "url": "https://git.kernel.org/stable/c/e3b131e30e612ff0e32de6c1cb4f69f89db29193"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48761",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:14.203",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nusb: xhci-plat: fix crash when suspend if remote wake enable\nCrashed at i.mx8qm platform when suspend if enable remote wakeup\nInternal error: synchronous external abort: 96000210 [#1] PREEMPT SMP\nModules linked in:\nCPU: 2 PID: 244 Comm: kworker/u12:6 Not tainted 5.15.5-dirty #12\nHardware name: Freescale i.MX8QM MEK (DT)\nWorkqueue: events_unbound async_run_entry_fn\npstate: 600000c5 (nZCv daIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : xhci_disable_hub_port_wake.isra.62+0x60/0xf8\nlr : xhci_disable_hub_port_wake.isra.62+0x34/0xf8\nsp : ffff80001394bbf0\nx29: ffff80001394bbf0 x28: 0000000000000000 x27: ffff00081193b578\nx26: ffff00081193b570 x25: 0000000000000000 x24: 0000000000000000\nx23: ffff00081193a29c x22: 0000000000020001 x21: 0000000000000001\nx20: 0000000000000000 x19: ffff800014e90490 x18: 0000000000000000\nx17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000\nx14: 0000000000000000 x13: 0000000000000002 x12: 0000000000000000\nx11: 0000000000000000 x10: 0000000000000960 x9 : ffff80001394baa0\nx8 : ffff0008145d1780 x7 : ffff0008f95b8e80 x6 : 000000001853b453\nx5 : 0000000000000496 x4 : 0000000000000000 x3 : ffff00081193a29c\nx2 : 0000000000000001 x1 : 0000000000000000 x0 : ffff000814591620\nCall trace:\n xhci_disable_hub_port_wake.isra.62+0x60/0xf8\n xhci_suspend+0x58/0x510\n xhci_plat_suspend+0x50/0x78\n platform_pm_suspend+0x2c/0x78\n dpm_run_callback.isra.25+0x50/0xe8\n __device_suspend+0x108/0x3c0\nThe basic flow:\n\t1. run time suspend call xhci_suspend, xhci parent devices gate the clock.\n        2. echo mem >/sys/power/state, system _device_suspend call xhci_suspend\n        3. xhci_suspend call xhci_disable_hub_port_wake, which access register,\n\t   but clock already gated by run time suspend.\nThis problem was hidden by power domain driver, which call run time resume before it.\nBut the below commit remove it and make this issue happen.\n\tcommit c1df456d0f06e (\"PM: domains: Don't runtime resume devices at genpd_prepare()\")\nThis patch call run time resume before suspend to make sure clock is on\nbefore access register.\nTesteb-by: Abel Vesa <abel.vesa@nxp.com>",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/20c51a4c52208f98e27308c456a1951778f41fa5"
          },
          {
            "url": "https://git.kernel.org/stable/c/8b05ad29acb972850ad795fa850e814b2e758b83"
          },
          {
            "url": "https://git.kernel.org/stable/c/9df478463d9feb90dae24f183383961cf123a0ec"
          },
          {
            "url": "https://git.kernel.org/stable/c/d5755832a1e47f5d8773f0776e211ecd4e02da72"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48762",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:14.287",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\narm64: extable: fix load_unaligned_zeropad() reg indices\nIn ex_handler_load_unaligned_zeropad() we erroneously extract the data and\naddr register indices from ex->type rather than ex->data. As ex->type will\ncontain EX_TYPE_LOAD_UNALIGNED_ZEROPAD (i.e. 4):\n * We'll always treat X0 as the address register, since EX_DATA_REG_ADDR is\n   extracted from bits [9:5]. Thus, we may attempt to dereference an\n   arbitrary address as X0 may hold an arbitrary value.\n * We'll always treat X4 as the data register, since EX_DATA_REG_DATA is\n   extracted from bits [4:0]. Thus we will corrupt X4 and cause arbitrary\n   behaviour within load_unaligned_zeropad() and its caller.\nFix this by extracting both values from ex->data as originally intended.\nOn an MTE-enabled QEMU image we are hitting the following crash:\n Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000\n Call trace:\n  fixup_exception+0xc4/0x108\n  __do_kernel_fault+0x3c/0x268\n  do_tag_check_fault+0x3c/0x104\n  do_mem_abort+0x44/0xf4\n  el1_abort+0x40/0x64\n  el1h_64_sync_handler+0x60/0xa0\n  el1h_64_sync+0x7c/0x80\n  link_path_walk+0x150/0x344\n  path_openat+0xa0/0x7dc\n  do_filp_open+0xb8/0x168\n  do_sys_openat2+0x88/0x17c\n  __arm64_sys_openat+0x74/0xa0\n  invoke_syscall+0x48/0x148\n  el0_svc_common+0xb8/0xf8\n  do_el0_svc+0x28/0x88\n  el0_svc+0x24/0x84\n  el0t_64_sync_handler+0x88/0xec\n  el0t_64_sync+0x1b4/0x1b8\n Code: f8695a69 71007d1f 540000e0 927df12a (f940014a)",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3758a6c74e08bdc15ccccd6872a6ad37d165239a"
          },
          {
            "url": "https://git.kernel.org/stable/c/47fe7a1c5e3e011eeb4ab79f2d54a794fdd1c3eb"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48763",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:14.363",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nKVM: x86: Forcibly leave nested virt when SMM state is toggled\nForcibly leave nested virtualization operation if userspace toggles SMM\nstate via KVM_SET_VCPU_EVENTS or KVM_SYNC_X86_EVENTS.  If userspace\nforces the vCPU out of SMM while it's post-VMXON and then injects an SMI,\nvmx_enter_smm() will overwrite vmx->nested.smm.vmxon and end up with both\nvmxon=false and smm.vmxon=false, but all other nVMX state allocated.\nDon't attempt to gracefully handle the transition as (a) most transitions\nare nonsencial, e.g. forcing SMM while L2 is running, (b) there isn't\nsufficient information to handle all transitions, e.g. SVM wants access\nto the SMRAM save state, and (c) KVM_SET_VCPU_EVENTS must precede\nKVM_SET_NESTED_STATE during state restore as the latter disallows putting\nthe vCPU into L2 if SMM is active, and disallows tagging the vCPU as\nbeing post-VMXON in SMM if SMM is not active.\nAbuse of KVM_SET_VCPU_EVENTS manifests as a WARN and memory leak in nVMX\ndue to failure to free vmcs01's shadow VMCS, but the bug goes far beyond\njust a memory leak, e.g. toggling SMM on while L2 is active puts the vCPU\nin an architecturally impossible state.\n  WARNING: CPU: 0 PID: 3606 at free_loaded_vmcs arch/x86/kvm/vmx/vmx.c:2665 [inline]\n  WARNING: CPU: 0 PID: 3606 at free_loaded_vmcs+0x158/0x1a0 arch/x86/kvm/vmx/vmx.c:2656\n  Modules linked in:\n  CPU: 1 PID: 3606 Comm: syz-executor725 Not tainted 5.17.0-rc1-syzkaller #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\n  RIP: 0010:free_loaded_vmcs arch/x86/kvm/vmx/vmx.c:2665 [inline]\n  RIP: 0010:free_loaded_vmcs+0x158/0x1a0 arch/x86/kvm/vmx/vmx.c:2656\n  Code: <0f> 0b eb b3 e8 8f 4d 9f 00 e9 f7 fe ff ff 48 89 df e8 92 4d 9f 00\n  Call Trace:\n   <TASK>\n   kvm_arch_vcpu_destroy+0x72/0x2f0 arch/x86/kvm/x86.c:11123\n   kvm_vcpu_destroy arch/x86/kvm/../../../virt/kvm/kvm_main.c:441 [inline]\n   kvm_destroy_vcpus+0x11f/0x290 arch/x86/kvm/../../../virt/kvm/kvm_main.c:460\n   kvm_free_vcpus arch/x86/kvm/x86.c:11564 [inline]\n   kvm_arch_destroy_vm+0x2e8/0x470 arch/x86/kvm/x86.c:11676\n   kvm_destroy_vm arch/x86/kvm/../../../virt/kvm/kvm_main.c:1217 [inline]\n   kvm_put_kvm+0x4fa/0xb00 arch/x86/kvm/../../../virt/kvm/kvm_main.c:1250\n   kvm_vm_release+0x3f/0x50 arch/x86/kvm/../../../virt/kvm/kvm_main.c:1273\n   __fput+0x286/0x9f0 fs/file_table.c:311\n   task_work_run+0xdd/0x1a0 kernel/task_work.c:164\n   exit_task_work include/linux/task_work.h:32 [inline]\n   do_exit+0xb29/0x2a30 kernel/exit.c:806\n   do_group_exit+0xd2/0x2f0 kernel/exit.c:935\n   get_signal+0x4b0/0x28c0 kernel/signal.c:2862\n   arch_do_signal_or_restart+0x2a9/0x1c40 arch/x86/kernel/signal.c:868\n   handle_signal_work kernel/entry/common.c:148 [inline]\n   exit_to_user_mode_loop kernel/entry/common.c:172 [inline]\n   exit_to_user_mode_prepare+0x17d/0x290 kernel/entry/common.c:207\n   __syscall_exit_to_user_mode_work kernel/entry/common.c:289 [inline]\n   syscall_exit_to_user_mode+0x19/0x60 kernel/entry/common.c:300\n   do_syscall_64+0x42/0xb0 arch/x86/entry/common.c:86\n   entry_SYSCALL_64_after_hwframe+0x44/0xae\n   </TASK>",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/080dbe7e9b86a0392d8dffc00d9971792afc121f"
          },
          {
            "url": "https://git.kernel.org/stable/c/b4c0d89c92e957ecccce12e66b63875d0cc7af7e"
          },
          {
            "url": "https://git.kernel.org/stable/c/e302786233e6bc512986d007c96458ccf5ca21c7"
          },
          {
            "url": "https://git.kernel.org/stable/c/f7e570780efc5cec9b2ed1e0472a7da14e864fdb"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48764",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:14.450",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nKVM: x86: Free kvm_cpuid_entry2 array on post-KVM_RUN KVM_SET_CPUID{,2}\nFree the \"struct kvm_cpuid_entry2\" array on successful post-KVM_RUN\nKVM_SET_CPUID{,2} to fix a memory leak, the callers of kvm_set_cpuid()\nfree the array only on failure.\n BUG: memory leak\n unreferenced object 0xffff88810963a800 (size 2048):\n  comm \"syz-executor025\", pid 3610, jiffies 4294944928 (age 8.080s)\n  hex dump (first 32 bytes):\n    00 00 00 00 00 00 00 00 00 00 00 00 0d 00 00 00  ................\n    47 65 6e 75 6e 74 65 6c 69 6e 65 49 00 00 00 00  GenuntelineI....\n  backtrace:\n    [<ffffffff814948ee>] kmalloc_node include/linux/slab.h:604 [inline]\n    [<ffffffff814948ee>] kvmalloc_node+0x3e/0x100 mm/util.c:580\n    [<ffffffff814950f2>] kvmalloc include/linux/slab.h:732 [inline]\n    [<ffffffff814950f2>] vmemdup_user+0x22/0x100 mm/util.c:199\n    [<ffffffff8109f5ff>] kvm_vcpu_ioctl_set_cpuid2+0x8f/0xf0 arch/x86/kvm/cpuid.c:423\n    [<ffffffff810711b9>] kvm_arch_vcpu_ioctl+0xb99/0x1e60 arch/x86/kvm/x86.c:5251\n    [<ffffffff8103e92d>] kvm_vcpu_ioctl+0x4ad/0x950 arch/x86/kvm/../../../virt/kvm/kvm_main.c:4066\n    [<ffffffff815afacc>] vfs_ioctl fs/ioctl.c:51 [inline]\n    [<ffffffff815afacc>] __do_sys_ioctl fs/ioctl.c:874 [inline]\n    [<ffffffff815afacc>] __se_sys_ioctl fs/ioctl.c:860 [inline]\n    [<ffffffff815afacc>] __x64_sys_ioctl+0xfc/0x140 fs/ioctl.c:860\n    [<ffffffff844a3335>] do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n    [<ffffffff844a3335>] do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n    [<ffffffff84600068>] entry_SYSCALL_64_after_hwframe+0x44/0xae",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/811f95ff95270e6048197821434d9301e3d7f07c"
          },
          {
            "url": "https://git.kernel.org/stable/c/b9ee734a14bb685b2088f2176d82b34cb4e30dbc"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48765",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:14.530",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nKVM: LAPIC: Also cancel preemption timer during SET_LAPIC\nThe below warning is splatting during guest reboot.\n  ------------[ cut here ]------------\n  WARNING: CPU: 0 PID: 1931 at arch/x86/kvm/x86.c:10322 kvm_arch_vcpu_ioctl_run+0x874/0x880 [kvm]\n  CPU: 0 PID: 1931 Comm: qemu-system-x86 Tainted: G          I       5.17.0-rc1+ #5\n  RIP: 0010:kvm_arch_vcpu_ioctl_run+0x874/0x880 [kvm]\n  Call Trace:\n   <TASK>\n   kvm_vcpu_ioctl+0x279/0x710 [kvm]\n   __x64_sys_ioctl+0x83/0xb0\n   do_syscall_64+0x3b/0xc0\n   entry_SYSCALL_64_after_hwframe+0x44/0xae\n  RIP: 0033:0x7fd39797350b\nThis can be triggered by not exposing tsc-deadline mode and doing a reboot in\nthe guest. The lapic_shutdown() function which is called in sys_reboot path\nwill not disarm the flying timer, it just masks LVTT. lapic_shutdown() clears\nAPIC state w/ LVT_MASKED and timer-mode bit is 0, this can trigger timer-mode\nswitch between tsc-deadline and oneshot/periodic, which can result in preemption\ntimer be cancelled in apic_update_lvtt(). However, We can't depend on this when\nnot exposing tsc-deadline mode and oneshot/periodic modes emulated by preemption\ntimer. Qemu will synchronise states around reset, let's cancel preemption timer\nunder KVM_SET_LAPIC.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/35fe7cfbab2e81f1afb23fc4212210b1de6d9633"
          },
          {
            "url": "https://git.kernel.org/stable/c/54b3439c8e70e0bcfea59aeef9dd98908cbbf655"
          },
          {
            "url": "https://git.kernel.org/stable/c/ce55f63f6cea4cab8ae9212f73285648a5baa30d"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48766",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:14.617",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/amd/display: Wrap dcn301_calculate_wm_and_dlg for FPU.\nMirrors the logic for dcn30. Cue lots of WARNs and some\nkernel panics without this fix.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/25f1488bdbba63415239ff301fe61a8546140d9f"
          },
          {
            "url": "https://git.kernel.org/stable/c/456ba2433844a6483cc4c933aa8f43d24575e341"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48767",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:14.703",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nceph: properly put ceph_string reference after async create attempt\nThe reference acquired by try_prep_async_create is currently leaked.\nEnsure we put it.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/36d433ae3242aa714176378850e6d1a5a3e78f18"
          },
          {
            "url": "https://git.kernel.org/stable/c/932a9b5870d38b87ba0a9923c804b1af7d3605b9"
          },
          {
            "url": "https://git.kernel.org/stable/c/a0c22e970cd78b81c94691e6cb09713e8074d580"
          },
          {
            "url": "https://git.kernel.org/stable/c/e7be12ca7d3947765b0d7c1c7e0537e748da993a"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48768",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:14.783",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ntracing/histogram: Fix a potential memory leak for kstrdup()\nkfree() is missing on an error path to free the memory allocated by\nkstrdup():\n  p = param = kstrdup(data->params[i], GFP_KERNEL);\nSo it is better to free it via kfree(p).",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/8a8878ebb596281f50fc0b9a6e1f23f0d7f154e8"
          },
          {
            "url": "https://git.kernel.org/stable/c/d71b06aa995007eafd247626d0669b9364c42ad7"
          },
          {
            "url": "https://git.kernel.org/stable/c/df86e2fe808c3536a9dba353cc2bebdfea00d0cf"
          },
          {
            "url": "https://git.kernel.org/stable/c/e33fa4a46ee22de88a700e2e3d033da8214a5175"
          },
          {
            "url": "https://git.kernel.org/stable/c/e629e7b525a179e29d53463d992bdee759c950fb"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48769",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:14.870",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nefi: runtime: avoid EFIv2 runtime services on Apple x86 machines\nAditya reports [0] that his recent MacbookPro crashes in the firmware\nwhen using the variable services at runtime. The culprit appears to be a\ncall to QueryVariableInfo(), which we did not use to call on Apple x86\nmachines in the past as they only upgraded from EFI v1.10 to EFI v2.40\nfirmware fairly recently, and QueryVariableInfo() (along with\nUpdateCapsule() et al) was added in EFI v2.00.\nThe only runtime service introduced in EFI v2.00 that we actually use in\nLinux is QueryVariableInfo(), as the capsule based ones are optional,\ngenerally not used at runtime (all the LVFS/fwupd firmware update\ninfrastructure uses helper EFI programs that invoke capsule update at\nboot time, not runtime), and not implemented by Apple machines in the\nfirst place. QueryVariableInfo() is used to 'safely' set variables,\ni.e., only when there is enough space. This prevents machines with buggy\nfirmwares from corrupting their NVRAMs when they run out of space.\nGiven that Apple machines have been using EFI v1.10 services only for\nthe longest time (the EFI v2.0 spec was released in 2006, and Linux\nsupport for the newly introduced runtime services was added in 2011, but\nthe MacbookPro12,1 released in 2015 still claims to be EFI v1.10 only),\nlet's avoid the EFI v2.0 ones on all Apple x86 machines.\n[0] https://lore.kernel.org/all/6D757C75-65B1-468B-842D-10410081A8E4@live.com/",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3df52448978802ae15dcebf66beba1029df957b4"
          },
          {
            "url": "https://git.kernel.org/stable/c/a4085859411c825c321c9b55b8a9dc5a128a6684"
          },
          {
            "url": "https://git.kernel.org/stable/c/b0f1cc093bc2493ac259c53766fd2b800e085807"
          },
          {
            "url": "https://git.kernel.org/stable/c/f5390cd0b43c2e54c7cf5506c7da4a37c5cef746"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48770",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:14.953",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbpf: Guard against accessing NULL pt_regs in bpf_get_task_stack()\ntask_pt_regs() can return NULL on powerpc for kernel threads. This is\nthen used in __bpf_get_stack() to check for user mode, resulting in a\nkernel oops. Guard against this by checking return value of\ntask_pt_regs() before trying to obtain the call chain.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0bcd484587b3b3092e448d27dc369e347e1810c3"
          },
          {
            "url": "https://git.kernel.org/stable/c/b82ef4985a6d05e80f604624332430351df7b79a"
          },
          {
            "url": "https://git.kernel.org/stable/c/b992f01e66150fc5e90be4a96f5eb8e634c8249e"
          },
          {
            "url": "https://git.kernel.org/stable/c/ff6bdc205fd0a83bd365405d4e31fb5905826996"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2022-48771",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:15.043",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/vmwgfx: Fix stale file descriptors on failed usercopy\nA failing usercopy of the fence_rep object will lead to a stale entry in\nthe file descriptor table as put_unused_fd() won't release it. This\nenables userland to refer to a dangling 'file' object through that still\nvalid file descriptor, leading to all kinds of use-after-free\nexploitation scenarios.\nFix this by deferring the call to fd_install() until after the usercopy\nhas succeeded.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0008a0c78fc33a84e2212a7c04e6b21a36ca6f4d"
          },
          {
            "url": "https://git.kernel.org/stable/c/1d833b27fb708d6fdf5de9f6b3a8be4bd4321565"
          },
          {
            "url": "https://git.kernel.org/stable/c/6066977961fc6f437bc064f628cf9b0e4571c56c"
          },
          {
            "url": "https://git.kernel.org/stable/c/84b1259fe36ae0915f3d6ddcea6377779de48b82"
          },
          {
            "url": "https://git.kernel.org/stable/c/a0f90c8815706981c483a652a6aefca51a5e191c"
          },
          {
            "url": "https://git.kernel.org/stable/c/ae2b20f27732fe92055d9e7b350abc5cdf3e2414"
          },
          {
            "url": "https://git.kernel.org/stable/c/e8d092a62449dcfc73517ca43963d2b8f44d0516"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2023-52883",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-06-20T12:15:15.140",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/amdgpu: Fix possible null pointer dereference\nabo->tbo.resource may be NULL in amdgpu_vm_bo_update.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/51b79f33817544e3b4df838d86e8e8e4388ff684"
          },
          {
            "url": "https://git.kernel.org/stable/c/fefac8c4686fd81fde6830c6dae32f9001d2ac28"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-6183",
        "sourceIdentifier": "cna@vuldb.com",
        "published": "2024-06-20T12:15:15.233",
        "lastModified": "2024-06-20T16:15:14.903",
        "baseScore": 4.3,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 2.8,
        "impactScore": 1.4,
        "description": "A vulnerability classified as problematic has been found in EZ-Suite EZ-Partner 5. Affected is an unknown function of the component Forgot Password Handler. The manipulation leads to basic cross site scripting. It is possible to launch the attack remotely. VDB-269154 is the identifier assigned to this vulnerability. NOTE: The vendor was contacted early about this disclosure but did not respond in any way.",
        "cweIds": [
          {
            "id": "CWE-80",
            "description": "Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS)"
          }
        ],
        "references": [
          {
            "url": "https://vuldb.com/?ctiid.269154"
          },
          {
            "url": "https://vuldb.com/?id.269154"
          },
          {
            "url": "https://vuldb.com/?submit.353713"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-6184",
        "sourceIdentifier": "cna@vuldb.com",
        "published": "2024-06-20T12:15:15.560",
        "lastModified": "2024-06-20T14:15:11.953",
        "baseScore": 6.3,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 2.8,
        "impactScore": 3.4,
        "description": "A vulnerability classified as critical was found in Ruijie RG-UAC 1.0. Affected by this vulnerability is an unknown functionality of the file /view/systemConfig/reboot/reboot_commit.php. The manipulation of the argument servicename leads to os command injection. The attack can be launched remotely. The exploit has been disclosed to the public and may be used. The associated identifier of this vulnerability is VDB-269155. NOTE: The vendor was contacted early about this disclosure but did not respond in any way.",
        "cweIds": [
          {
            "id": "CWE-78",
            "description": "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
          }
        ],
        "references": [
          {
            "url": "https://github.com/L1OudFd8cl09/CVE/blob/main/11_06_2024_a.md"
          },
          {
            "url": "https://vuldb.com/?ctiid.269155"
          },
          {
            "url": "https://vuldb.com/?id.269155"
          },
          {
            "url": "https://vuldb.com/?submit.354119"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-6185",
        "sourceIdentifier": "cna@vuldb.com",
        "published": "2024-06-20T12:15:15.873",
        "lastModified": "2024-06-20T12:43:25.663",
        "baseScore": 6.3,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 2.8,
        "impactScore": 3.4,
        "description": "A vulnerability, which was classified as critical, has been found in Ruijie RG-UAC 1.0. Affected by this issue is the function get_ip_addr_details of the file /view/dhcp/dhcpConfig/commit.php. The manipulation of the argument ethname leads to os command injection. The attack may be launched remotely. The exploit has been disclosed to the public and may be used. The identifier of this vulnerability is VDB-269156. NOTE: The vendor was contacted early about this disclosure but did not respond in any way.",
        "cweIds": [
          {
            "id": "CWE-78",
            "description": "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
          }
        ],
        "references": [
          {
            "url": "https://github.com/L1OudFd8cl09/CVE/blob/main/11_06_2024_b.md"
          },
          {
            "url": "https://vuldb.com/?ctiid.269156"
          },
          {
            "url": "https://vuldb.com/?id.269156"
          },
          {
            "url": "https://vuldb.com/?submit.354121"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2023-49110",
        "sourceIdentifier": "551230f0-3615-47bd-b7cc-93e92e730bbf",
        "published": "2024-06-20T13:15:49.250",
        "lastModified": "2024-06-20T16:07:50.417",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "When the Kiuwan Local Analyzer uploads the scan results to the Kiuwan SAST web \napplication (either on-premises or cloud/SaaS solution), the transmitted data \nconsists of a ZIP archive containing several files, some of them in the \nXML file format. During Kiuwan's server-side processing of these XML \nfiles, it resolves external XML entities, resulting in a XML external \nentity injection attack.An attacker with privileges to scan \nsource code within the \"Code Security\" module is able to extract any \nfiles of the operating system with the rights of the application server \nuser and is potentially able to gain sensitive files, such as \nconfiguration and passwords. Furthermore, this vulnerability also allows\n an attacker to initiate connections to internal systems, e.g. for port \nscans or accessing other internal functions / applications such as the \nWildfly admin console of Kiuwan.\nThis issue affects Kiuwan SAST: <master.1808.p685.q13371",
        "cweIds": [
          {
            "id": "CWE-611",
            "description": "Improper Restriction of XML External Entity Reference"
          }
        ],
        "references": [
          {
            "url": "https://r.sec-consult.com/kiuwan"
          },
          {
            "url": "https://www.kiuwan.com/docs/display/K5/%5B2024-05-30%5D+Change+Log"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2023-49111",
        "sourceIdentifier": "551230f0-3615-47bd-b7cc-93e92e730bbf",
        "published": "2024-06-20T13:15:49.380",
        "lastModified": "2024-06-20T16:07:50.417",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "For Kiuwan installations with SSO (single sign-on) enabled, an \nunauthenticated reflected cross-site scripting attack can be performed \non the login page \"login.html\". This is possible due to the request parameter \"message\" values\n being directly included in a JavaScript block in the response. This is \nespecially critical in business environments using AD SSO \nauthentication, e.g. via ADFS, where attackers could potentially steal \nAD passwords.\nThis issue affects Kiuwan SAST: <master.1808.p685.q13371",
        "cweIds": [
          {
            "id": "CWE-79",
            "description": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
          }
        ],
        "references": [
          {
            "url": "https://r.sec-consult.com/kiuwan"
          },
          {
            "url": "https://www.kiuwan.com/docs/display/K5/%5B2024-05-30%5D+Change+Log"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2023-49112",
        "sourceIdentifier": "551230f0-3615-47bd-b7cc-93e92e730bbf",
        "published": "2024-06-20T13:15:49.480",
        "lastModified": "2024-06-20T16:07:50.417",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "Kiuwan provides an API endpoint\n/saas/rest/v1/info/application\nto get information about any \napplication, providing only its name via the \"application\" parameter. This endpoint lacks proper access \ncontrol mechanisms, allowing other authenticated users to read \ninformation about applications, even though they have not been granted \nthe necessary rights to do so.\nThis issue affects Kiuwan SAST: <master.1808.p685.q13371",
        "cweIds": null,
        "references": [
          {
            "url": "https://r.sec-consult.com/kiuwan"
          },
          {
            "url": "https://www.kiuwan.com/docs/display/K5/%5B2024-05-30%5D+Change+Log"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2023-49113",
        "sourceIdentifier": "551230f0-3615-47bd-b7cc-93e92e730bbf",
        "published": "2024-06-20T13:15:49.560",
        "lastModified": "2024-06-20T16:07:50.417",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "The Kiuwan Local Analyzer (KLA) Java scanning application contains several \nhard-coded secrets in plain text format. In some cases, this can \npotentially compromise the confidentiality of the scan results.Several credentials were found in the JAR files of the Kiuwan Local Analyzer.\nThe\n JAR file \"lib.engine/insight/optimyth-insight.jar\" contains the file \n\"InsightServicesConfig.properties\", which has the configuration tokens \n\"insight.github.user\" as well as \"insight.github.password\" prefilled \nwith credentials. At least the specified username corresponds to a valid\n GitHub account.The\n JAR file \"lib.engine/insight/optimyth-insight.jar\" also contains the \nfile \"es/als/security/Encryptor.properties\", in which the key used for \nencrypting the results of any performed scan.\nThis issue affects Kiuwan SAST: <master.1808.p685.q13371",
        "cweIds": [
          {
            "id": "CWE-312",
            "description": "Cleartext Storage of Sensitive Information"
          }
        ],
        "references": [
          {
            "url": "https://r.sec-consult.com/kiuwan"
          },
          {
            "url": "https://www.kiuwan.com/docs/display/K5/%5B2024-05-30%5D+Change+Log"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-6186",
        "sourceIdentifier": "cna@vuldb.com",
        "published": "2024-06-20T13:15:50.007",
        "lastModified": "2024-06-20T16:07:50.417",
        "baseScore": 6.3,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 2.8,
        "impactScore": 3.4,
        "description": "A vulnerability, which was classified as critical, was found in Ruijie RG-UAC 1.0. This affects an unknown part of the file /view/userAuthentication/SSO/commit.php. The manipulation of the argument ad_log_name leads to os command injection. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used. The identifier VDB-269157 was assigned to this vulnerability. NOTE: The vendor was contacted early about this disclosure but did not respond in any way.",
        "cweIds": [
          {
            "id": "CWE-78",
            "description": "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
          }
        ],
        "references": [
          {
            "url": "https://github.com/L1OudFd8cl09/CVE/blob/main/11_06_2024_c.md"
          },
          {
            "url": "https://vuldb.com/?ctiid.269157"
          },
          {
            "url": "https://vuldb.com/?id.269157"
          },
          {
            "url": "https://vuldb.com/?submit.354122"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-6187",
        "sourceIdentifier": "cna@vuldb.com",
        "published": "2024-06-20T13:15:50.320",
        "lastModified": "2024-06-20T19:15:50.553",
        "baseScore": 6.3,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 2.8,
        "impactScore": 3.4,
        "description": "A vulnerability has been found in Ruijie RG-UAC 1.0 and classified as critical. This vulnerability affects unknown code of the file /view/vpn/autovpn/sub_commit.php. The manipulation of the argument key leads to os command injection. The attack can be initiated remotely. The exploit has been disclosed to the public and may be used. VDB-269158 is the identifier assigned to this vulnerability. NOTE: The vendor was contacted early about this disclosure but did not respond in any way.",
        "cweIds": [
          {
            "id": "CWE-78",
            "description": "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
          }
        ],
        "references": [
          {
            "url": "https://github.com/L1OudFd8cl09/CVE/blob/main/11_06_2024_d.md"
          },
          {
            "url": "https://vuldb.com/?ctiid.269158"
          },
          {
            "url": "https://vuldb.com/?id.269158"
          },
          {
            "url": "https://vuldb.com/?submit.354125"
          }
        ]
      }
    }
  ]
}