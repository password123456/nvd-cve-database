{
  "totalResults": 86,
  "datePublished": "2024-05-25T01:00:08.322139Z",
  "vulnerabilities": [
    {
      "cve": {
        "id": "CVE-2024-35591",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-05-24T14:15:17.153",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "An arbitrary file upload vulnerability in O2OA v8.3.8 allows attackers to execute arbitrary code via uploading a crafted PDF file.",
        "cweIds": null,
        "references": [
          {
            "url": "https://github.com/o2oa/o2oa/issues/156"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35592",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-05-24T14:15:17.287",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "An arbitrary file upload vulnerability in the Upload function of Box-IM v2.0 allows attackers to execute arbitrary code via uploading a crafted PDF file.",
        "cweIds": null,
        "references": [
          {
            "url": "https://github.com/Joying-C/Cross-site-scripting-vulnerability/blob/main/BOX-IM_Cross_site%20_scripting%20_vulnerability/BOX-IM_Cross_site%20_scripting%20_vulnerability.pdf"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35593",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-05-24T14:15:17.390",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "An arbitrary file upload vulnerability in the File preview function of Raingad IM v4.1.4 allows attackers to execute arbitrary code via uploading a crafted PDF file.",
        "cweIds": null,
        "references": [
          {
            "url": "https://github.com/Joying-C/Cross-site-scripting-vulnerability/tree/main/Raingad-IM_Cross_site%20_scripting%20_vulnerability"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35595",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-05-24T14:15:17.487",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "An arbitrary file upload vulnerability in the File Preview function of Xintongda OA v2023.12.30.1 allows attackers to execute arbitrary code via uploading a crafted PDF file.",
        "cweIds": null,
        "references": [
          {
            "url": "https://github.com/Joying-C/Cross-site-scripting-vulnerability/blob/main/Xintongda-OA_Cross_site%20_scripting%20_vulnerability/Xintongda-OA_Cross_site%20_scripting%20_vulnerability.pdf"
          },
          {
            "url": "https://github.com/Joying-C/Cross-site-scripting-vulnerability/tree/main/Xintongda-OA_Cross_site%20_scripting%20_vulnerability"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-5273",
        "sourceIdentifier": "jenkinsci-cert@googlegroups.com",
        "published": "2024-05-24T14:15:17.823",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "Jenkins Report Info Plugin 1.2 and earlier does not perform path validation of the workspace directory while serving report files, allowing attackers with Item/Configure permission to retrieve Surefire failures, PMD violations, Findbugs bugs, and Checkstyle errors on the controller file system by editing the workspace path.",
        "cweIds": null,
        "references": [
          {
            "url": "https://www.jenkins.io/security/advisory/2024-05-24/#SECURITY-3070"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47499",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:09.607",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\niio: accel: kxcjk-1013: Fix possible memory leak in probe and remove\nWhen ACPI type is ACPI_SMO8500, the data->dready_trig will not be set, the\nmemory allocated by iio_triggered_buffer_setup() will not be freed, and cause\nmemory leak as follows:\nunreferenced object 0xffff888009551400 (size 512):\n  comm \"i2c-SMO8500-125\", pid 911, jiffies 4294911787 (age 83.852s)\n  hex dump (first 32 bytes):\n    02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n    00 00 00 00 00 00 00 00 20 e2 e5 c0 ff ff ff ff  ........ .......\n  backtrace:\n    [<0000000041ce75ee>] kmem_cache_alloc_trace+0x16d/0x360\n    [<000000000aeb17b0>] iio_kfifo_allocate+0x41/0x130 [kfifo_buf]\n    [<000000004b40c1f5>] iio_triggered_buffer_setup_ext+0x2c/0x210 [industrialio_triggered_buffer]\n    [<000000004375b15f>] kxcjk1013_probe+0x10c3/0x1d81 [kxcjk_1013]\nFix it by remove data->dready_trig condition in probe and remove.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/14508fe13b1c578b3d2ba574f1d48b351975860c"
          },
          {
            "url": "https://git.kernel.org/stable/c/3899700ddacbf7aaafadf44464fff3ff0d4e3307"
          },
          {
            "url": "https://git.kernel.org/stable/c/60a55b9d91ba99eb8cf015bc46dc2de05e168a15"
          },
          {
            "url": "https://git.kernel.org/stable/c/70c9774e180d151abaab358108e3510a8e615215"
          },
          {
            "url": "https://git.kernel.org/stable/c/8c163a14277115ca962103910ab4cce55e862ffb"
          },
          {
            "url": "https://git.kernel.org/stable/c/8c1d43f3a3fc7184c42d7398bdf59a2a2903e4fc"
          },
          {
            "url": "https://git.kernel.org/stable/c/a3730f74159ad00a28960c0efe2a931fe6fe6b45"
          },
          {
            "url": "https://git.kernel.org/stable/c/ee86d0bad80bdcd11a87e188a596727f41b62320"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47500",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:09.900",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\niio: mma8452: Fix trigger reference couting\nThe mma8452 driver directly assigns a trigger to the struct iio_dev. The\nIIO core when done using this trigger will call `iio_trigger_put()` to drop\nthe reference count by 1.\nWithout the matching `iio_trigger_get()` in the driver the reference count\ncan reach 0 too early, the trigger gets freed while still in use and a\nuse-after-free occurs.\nFix this by getting a reference to the trigger before assigning it to the\nIIO device.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/094d513b78b1714113bc016684b8142382e071ba"
          },
          {
            "url": "https://git.kernel.org/stable/c/794c0898f6bf39a458655d5fb4af70ec43a5cfcb"
          },
          {
            "url": "https://git.kernel.org/stable/c/acf0088ac073ca6e7f4cad6acac112177e08df5e"
          },
          {
            "url": "https://git.kernel.org/stable/c/c43517071dfc9fce34f8f69dbb98a86017f6b739"
          },
          {
            "url": "https://git.kernel.org/stable/c/cd0082235783f814241a1c9483fb89e405f4f892"
          },
          {
            "url": "https://git.kernel.org/stable/c/db12d95085367de8b0223929d1332731024441f1"
          },
          {
            "url": "https://git.kernel.org/stable/c/f5deab10ced368c807866283f8b79144c4823be8"
          },
          {
            "url": "https://git.kernel.org/stable/c/fb75cc4740d81264cd5bcb0e17d961d018a8be96"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47501",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:10.150",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ni40e: Fix NULL pointer dereference in i40e_dbg_dump_desc\nWhen trying to dump VFs VSI RX/TX descriptors\nusing debugfs there was a crash\ndue to NULL pointer dereference in i40e_dbg_dump_desc.\nAdded a check to i40e_dbg_dump_desc that checks if\nVSI type is correct for dumping RX/TX descriptors.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/16431e442db248ecd8aa9457cf0a656f1885f56e"
          },
          {
            "url": "https://git.kernel.org/stable/c/23ec111bf3549aae37140330c31a16abfc172421"
          },
          {
            "url": "https://git.kernel.org/stable/c/e5b7fb2198abc50058f1a29c395b004f76ab1c83"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47502",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:10.350",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nASoC: codecs: wcd934x: handle channel mappping list correctly\nCurrently each channel is added as list to dai channel list, however\nthere is danger of adding same channel to multiple dai channel list\nwhich endups corrupting the other list where its already added.\nThis patch ensures that the channel is actually free before adding to\nthe dai channel list and also ensures that the channel is on the list\nbefore deleting it.\nThis check was missing previously, and we did not hit this issue as\nwe were testing very simple usecases with sequence of amixer commands.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1089dac26c6b4b833323ae6c0ceab29fb30ede72"
          },
          {
            "url": "https://git.kernel.org/stable/c/23ba28616d3063bd4c4953598ed5e439ca891101"
          },
          {
            "url": "https://git.kernel.org/stable/c/339ffb5b56005582aacc860524d2d208604049d1"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47503",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:10.567",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nscsi: pm80xx: Do not call scsi_remove_host() in pm8001_alloc()\nCalling scsi_remove_host() before scsi_add_host() results in a crash:\n BUG: kernel NULL pointer dereference, address: 0000000000000108\n RIP: 0010:device_del+0x63/0x440\n Call Trace:\n  device_unregister+0x17/0x60\n  scsi_remove_host+0xee/0x2a0\n  pm8001_pci_probe+0x6ef/0x1b90 [pm80xx]\n  local_pci_probe+0x3f/0x90\nWe cannot call scsi_remove_host() in pm8001_alloc() because scsi_add_host()\nhas not been called yet at that point in time.\nFunction call tree:\n  pm8001_pci_probe()\n  |\n  `- pm8001_pci_alloc()\n  |  |\n  |  `- pm8001_alloc()\n  |     |\n  |     `- scsi_remove_host()\n  |\n  `- scsi_add_host()",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1e434d2687e8bc0b3cdc9dd093c0e9047c0b4add"
          },
          {
            "url": "https://git.kernel.org/stable/c/653926205741add87a6cf452e21950eebc6ac10b"
          },
          {
            "url": "https://git.kernel.org/stable/c/f8dccc1bdea7e21b5ec06c957aef8831c772661c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47504",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:10.773",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nio_uring: ensure task_work gets run as part of cancelations\nIf we successfully cancel a work item but that work item needs to be\nprocessed through task_work, then we can be sleeping uninterruptibly\nin io_uring_cancel_generic() and never process it. Hence we don't\nmake forward progress and we end up with an uninterruptible sleep\nwarning.\nWhile in there, correct a comment that should be IFF, not IIF.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/78a780602075d8b00c98070fa26e389b3b3efa72"
          },
          {
            "url": "https://git.kernel.org/stable/c/8e12976c0c19ebc14b60046b1348c516a74c25a2"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47505",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:11.000",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\naio: fix use-after-free due to missing POLLFREE handling\nsignalfd_poll() and binder_poll() are special in that they use a\nwaitqueue whose lifetime is the current task, rather than the struct\nfile as is normally the case.  This is okay for blocking polls, since a\nblocking poll occurs within one task; however, non-blocking polls\nrequire another solution.  This solution is for the queue to be cleared\nbefore it is freed, by sending a POLLFREE notification to all waiters.\nUnfortunately, only eventpoll handles POLLFREE.  A second type of\nnon-blocking poll, aio poll, was added in kernel v4.18, and it doesn't\nhandle POLLFREE.  This allows a use-after-free to occur if a signalfd or\nbinder fd is polled with aio poll, and the waitqueue gets freed.\nFix this by making aio poll handle POLLFREE.\nA patch by Ramji Jiyani <ramjiyani@google.com>\n(https://lore.kernel.org/r/20211027011834.2497484-1-ramjiyani@google.com)\ntried to do this by making aio_poll_wake() always complete the request\ninline if POLLFREE is seen.  However, that solution had two bugs.\nFirst, it introduced a deadlock, as it unconditionally locked the aio\ncontext while holding the waitqueue lock, which inverts the normal\nlocking order.  Second, it didn't consider that POLLFREE notifications\nare missed while the request has been temporarily de-queued.\nThe second problem was solved by my previous patch.  This patch then\nproperly fixes the use-after-free by handling POLLFREE in a\ndeadlock-free way.  It does this by taking advantage of the fact that\nfreeing of the waitqueue is RCU-delayed, similar to what eventpoll does.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/321fba81ec034f88aea4898993c1bf15605c023f"
          },
          {
            "url": "https://git.kernel.org/stable/c/4105e6a128e8a98455dfc9e6dbb2ab0c33c4497f"
          },
          {
            "url": "https://git.kernel.org/stable/c/47ffefd88abfffe8a040bcc1dd0554d4ea6f7689"
          },
          {
            "url": "https://git.kernel.org/stable/c/50252e4b5e989ce64555c7aef7516bdefc2fea72"
          },
          {
            "url": "https://git.kernel.org/stable/c/60d311f9e6381d779d7d53371f87285698ecee24"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47506",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:11.197",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnfsd: fix use-after-free due to delegation race\nA delegation break could arrive as soon as we've called vfs_setlease.  A\ndelegation break runs a callback which immediately (in\nnfsd4_cb_recall_prepare) adds the delegation to del_recall_lru.  If we\nthen exit nfs4_set_delegation without hashing the delegation, it will be\nfreed as soon as the callback is done with it, without ever being\nremoved from del_recall_lru.\nSymptoms show up later as use-after-free or list corruption warnings,\nusually in the laundromat thread.\nI suspect aba2072f4523 \"nfsd: grant read delegations to clients holding\nwrites\" made this bug easier to hit, but I looked as far back as v3.0\nand it looks to me it already had the same problem.  So I'm not sure\nwhere the bug was introduced; it may have been there from the beginning.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/04a8d07f3d58308b92630045560799a3faa3ebce"
          },
          {
            "url": "https://git.kernel.org/stable/c/148c816f10fd11df27ca6a9b3238cdd42fa72cd3"
          },
          {
            "url": "https://git.kernel.org/stable/c/2becaa990b93cbd2928292c0b669d3abb6cf06d4"
          },
          {
            "url": "https://git.kernel.org/stable/c/33645d3e22720cac1e4548f8fef57bf0649536ee"
          },
          {
            "url": "https://git.kernel.org/stable/c/348714018139c39533c55661a0c7c990671396b4"
          },
          {
            "url": "https://git.kernel.org/stable/c/548ec0805c399c65ed66c6641be467f717833ab5"
          },
          {
            "url": "https://git.kernel.org/stable/c/e0759696de6851d7536efddfdd2dfed4c4df1f09"
          },
          {
            "url": "https://git.kernel.org/stable/c/eeb0711801f5e19ef654371b627682aed3b11373"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47507",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:11.400",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnfsd: Fix nsfd startup race (again)\nCommit bd5ae9288d64 (\"nfsd: register pernet ops last, unregister first\")\nhas re-opened rpc_pipefs_event() race against nfsd_net_id registration\n(register_pernet_subsys()) which has been fixed by commit bb7ffbf29e76\n(\"nfsd: fix nsfd startup race triggering BUG_ON\").\nRestore the order of register_pernet_subsys() vs register_cld_notifier().\nAdd WARN_ON() to prevent a future regression.\nCrash info:\nUnable to handle kernel NULL pointer dereference at virtual address 0000000000000012\nCPU: 8 PID: 345 Comm: mount Not tainted 5.4.144-... #1\npc : rpc_pipefs_event+0x54/0x120 [nfsd]\nlr : rpc_pipefs_event+0x48/0x120 [nfsd]\nCall trace:\n rpc_pipefs_event+0x54/0x120 [nfsd]\n blocking_notifier_call_chain\n rpc_fill_super\n get_tree_keyed\n rpc_fs_get_tree\n vfs_get_tree\n do_mount\n ksys_mount\n __arm64_sys_mount\n el0_svc_handler\n el0_svc",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/8bf902fee5893cfc2f04a698abab47629699ae9a"
          },
          {
            "url": "https://git.kernel.org/stable/c/b10252c7ae9c9d7c90552f88b544a44ee773af64"
          },
          {
            "url": "https://git.kernel.org/stable/c/c520943a00ad5015704969ad3304c956bcd49d25"
          },
          {
            "url": "https://git.kernel.org/stable/c/f5734b1714ca355703e9ea8fb61d04beff1790b9"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47508",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:11.573",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbtrfs: free exchange changeset on failures\nFstests runs on my VMs have show several kmemleak reports like the following.\n  unreferenced object 0xffff88811ae59080 (size 64):\n    comm \"xfs_io\", pid 12124, jiffies 4294987392 (age 6.368s)\n    hex dump (first 32 bytes):\n      00 c0 1c 00 00 00 00 00 ff cf 1c 00 00 00 00 00  ................\n      90 97 e5 1a 81 88 ff ff 90 97 e5 1a 81 88 ff ff  ................\n    backtrace:\n      [<00000000ac0176d2>] ulist_add_merge+0x60/0x150 [btrfs]\n      [<0000000076e9f312>] set_state_bits+0x86/0xc0 [btrfs]\n      [<0000000014fe73d6>] set_extent_bit+0x270/0x690 [btrfs]\n      [<000000004f675208>] set_record_extent_bits+0x19/0x20 [btrfs]\n      [<00000000b96137b1>] qgroup_reserve_data+0x274/0x310 [btrfs]\n      [<0000000057e9dcbb>] btrfs_check_data_free_space+0x5c/0xa0 [btrfs]\n      [<0000000019c4511d>] btrfs_delalloc_reserve_space+0x1b/0xa0 [btrfs]\n      [<000000006d37e007>] btrfs_dio_iomap_begin+0x415/0x970 [btrfs]\n      [<00000000fb8a74b8>] iomap_iter+0x161/0x1e0\n      [<0000000071dff6ff>] __iomap_dio_rw+0x1df/0x700\n      [<000000002567ba53>] iomap_dio_rw+0x5/0x20\n      [<0000000072e555f8>] btrfs_file_write_iter+0x290/0x530 [btrfs]\n      [<000000005eb3d845>] new_sync_write+0x106/0x180\n      [<000000003fb505bf>] vfs_write+0x24d/0x2f0\n      [<000000009bb57d37>] __x64_sys_pwrite64+0x69/0xa0\n      [<000000003eba3fdf>] do_syscall_64+0x43/0x90\nIn case brtfs_qgroup_reserve_data() or btrfs_delalloc_reserve_metadata()\nfail the allocated extent_changeset will not be freed.\nSo in btrfs_check_data_free_space() and btrfs_delalloc_reserve_space()\nfree the allocated extent_changeset to get rid of the allocated memory.\nThe issue currently only happens in the direct IO write path, but only\nafter 65b3c08606e5 (\"btrfs: fix ENOSPC failure when attempting direct IO\nwrite into NOCOW range\"), and also at defrag_one_locked_target(). Every\nother place is always calling extent_changeset_free() even if its call\nto btrfs_delalloc_reserve_space() or btrfs_check_data_free_space() has\nfailed.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/ca06c5cb1b6dbfe67655b33c02fc394d65824519"
          },
          {
            "url": "https://git.kernel.org/stable/c/da5e817d9d75422eaaa05490d0b9a5e328fc1a51"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47509",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:11.780",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nALSA: pcm: oss: Limit the period size to 16MB\nSet the practical limit to the period size (the fragment shift in OSS)\ninstead of a full 31bit; a too large value could lead to the exhaust\nof memory as we allocate temporary buffers of the period size, too.\nAs of this patch, we set to 16MB limit, which should cover all use\ncases.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2e54cf6794bf82a54aaefc78da13819aea9cd28a"
          },
          {
            "url": "https://git.kernel.org/stable/c/35a3e511032146941085f87dd9fb5b82ea5c00a2"
          },
          {
            "url": "https://git.kernel.org/stable/c/76f19e4cbb548e28547f8c328aa0bfb3a10222d3"
          },
          {
            "url": "https://git.kernel.org/stable/c/8839c8c0f77ab8fc0463f4ab8b37fca3f70677c2"
          },
          {
            "url": "https://git.kernel.org/stable/c/ad45babf7886e7a212ee1d5eda9ef49f696db43c"
          },
          {
            "url": "https://git.kernel.org/stable/c/b02a41eebcc36d4f07196780f2e165ca2c499257"
          },
          {
            "url": "https://git.kernel.org/stable/c/be55f306396cd62c6889286a7194fd8b53363aeb"
          },
          {
            "url": "https://git.kernel.org/stable/c/d1bb703ad050de9095f10b2d3416c32921ac6bcc"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47510",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:12.000",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbtrfs: fix re-dirty process of tree-log nodes\nThere is a report of a transaction abort of -EAGAIN with the following\nscript.\n  #!/bin/sh\n  for d in sda sdb; do\n          mkfs.btrfs -d single -m single -f /dev/\\${d}\n  done\n  mount /dev/sda /mnt/test\n  mount /dev/sdb /mnt/scratch\n  for dir in test scratch; do\n          echo 3 >/proc/sys/vm/drop_caches\n          fio --directory=/mnt/\\${dir} --name=fio.\\${dir} --rw=read --size=50G --bs=64m \\\n                  --numjobs=$(nproc) --time_based --ramp_time=5 --runtime=480 \\\n                  --group_reporting |& tee /dev/shm/fio.\\${dir}\n          echo 3 >/proc/sys/vm/drop_caches\n  done\n  for d in sda sdb; do\n          umount /dev/\\${d}\n  done\nThe stack trace is shown in below.\n  [3310.967991] BTRFS: error (device sda) in btrfs_commit_transaction:2341: errno=-11 unknown (Error while writing out transaction)\n  [3310.968060] BTRFS info (device sda): forced readonly\n  [3310.968064] BTRFS warning (device sda): Skipping commit of aborted transaction.\n  [3310.968065] ------------[ cut here ]------------\n  [3310.968066] BTRFS: Transaction aborted (error -11)\n  [3310.968074] WARNING: CPU: 14 PID: 1684 at fs/btrfs/transaction.c:1946 btrfs_commit_transaction.cold+0x209/0x2c8\n  [3310.968131] CPU: 14 PID: 1684 Comm: fio Not tainted 5.14.10-300.fc35.x86_64 #1\n  [3310.968135] Hardware name: DIAWAY Tartu/Tartu, BIOS V2.01.B10 04/08/2021\n  [3310.968137] RIP: 0010:btrfs_commit_transaction.cold+0x209/0x2c8\n  [3310.968144] RSP: 0018:ffffb284ce393e10 EFLAGS: 00010282\n  [3310.968147] RAX: 0000000000000026 RBX: ffff973f147b0f60 RCX: 0000000000000027\n  [3310.968149] RDX: ffff974ecf098a08 RSI: 0000000000000001 RDI: ffff974ecf098a00\n  [3310.968150] RBP: ffff973f147b0f08 R08: 0000000000000000 R09: ffffb284ce393c48\n  [3310.968151] R10: ffffb284ce393c40 R11: ffffffff84f47468 R12: ffff973f101bfc00\n  [3310.968153] R13: ffff971f20cf2000 R14: 00000000fffffff5 R15: ffff973f147b0e58\n  [3310.968154] FS:  00007efe65468740(0000) GS:ffff974ecf080000(0000) knlGS:0000000000000000\n  [3310.968157] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  [3310.968158] CR2: 000055691bcbe260 CR3: 000000105cfa4001 CR4: 0000000000770ee0\n  [3310.968160] PKRU: 55555554\n  [3310.968161] Call Trace:\n  [3310.968167]  ? dput+0xd4/0x300\n  [3310.968174]  btrfs_sync_file+0x3f1/0x490\n  [3310.968180]  __x64_sys_fsync+0x33/0x60\n  [3310.968185]  do_syscall_64+0x3b/0x90\n  [3310.968190]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n  [3310.968194] RIP: 0033:0x7efe6557329b\n  [3310.968200] RSP: 002b:00007ffe0236ebc0 EFLAGS: 00000293 ORIG_RAX: 000000000000004a\n  [3310.968203] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007efe6557329b\n  [3310.968204] RDX: 0000000000000000 RSI: 00007efe58d77010 RDI: 0000000000000006\n  [3310.968205] RBP: 0000000004000000 R08: 0000000000000000 R09: 00007efe58d77010\n  [3310.968207] R10: 0000000016cacc0c R11: 0000000000000293 R12: 00007efe5ce95980\n  [3310.968208] R13: 0000000000000000 R14: 00007efe6447c790 R15: 0000000c80000000\n  [3310.968212] ---[ end trace 1a346f4d3c0d96ba ]---\n  [3310.968214] BTRFS: error (device sda) in cleanup_transaction:1946: errno=-11 unknown\nThe abort occurs because of a write hole while writing out freeing tree\nnodes of a tree-log tree. For zoned btrfs, we re-dirty a freed tree\nnode to ensure btrfs can write the region and does not leave a hole on\nwrite on a zoned device. The current code fails to re-dirty a node\nwhen the tree-log tree's depth is greater or equal to 2. That leads to\na transaction abort with -EAGAIN.\nFix the issue by properly re-dirtying a node on walking up the tree.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/477675049ca803aa95ff77468ffbddd966b415b0"
          },
          {
            "url": "https://git.kernel.org/stable/c/84c25448929942edacba905cecc0474e91114e7a"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47511",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:12.237",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nALSA: pcm: oss: Fix negative period/buffer sizes\nThe period size calculation in OSS layer may receive a negative value\nas an error, but the code there assumes only the positive values and\nhandle them with size_t.  Due to that, a too big value may be passed\nto the lower layers.\nThis patch changes the code to handle with ssize_t and adds the proper\nerror checks appropriately.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/00a860678098fcd9fa8db2b5fb9d2ddf4776d4cc"
          },
          {
            "url": "https://git.kernel.org/stable/c/02b2b691b77cd7b951fa7b6c9d44d4e472cdc823"
          },
          {
            "url": "https://git.kernel.org/stable/c/502e1146873d870f87da3b8f93d6bf2de5f38d0c"
          },
          {
            "url": "https://git.kernel.org/stable/c/8af815ab052eaf74addbbfb556d63ce2137c0e1b"
          },
          {
            "url": "https://git.kernel.org/stable/c/9d2479c960875ca1239bcb899f386970c13d9cfe"
          },
          {
            "url": "https://git.kernel.org/stable/c/be8869d388593e57223ad39297c8e54be632f2f2"
          },
          {
            "url": "https://git.kernel.org/stable/c/f12c8a7515f641885677960af450082569a87243"
          },
          {
            "url": "https://git.kernel.org/stable/c/f96c0959c1ee92adc911c10d6ec209af50105049"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47512",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:12.487",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/sched: fq_pie: prevent dismantle issue\nFor some reason, fq_pie_destroy() did not copy\nworking code from pie_destroy() and other qdiscs,\nthus causing elusive bug.\nBefore calling del_timer_sync(&q->adapt_timer),\nwe need to ensure timer will not rearm itself.\nrcu: INFO: rcu_preempt self-detected stall on CPU\nrcu:    0-....: (4416 ticks this GP) idle=60d/1/0x4000000000000000 softirq=10433/10434 fqs=2579\n        (t=10501 jiffies g=13085 q=3989)\nNMI backtrace for cpu 0\nCPU: 0 PID: 13 Comm: ksoftirqd/0 Not tainted 5.16.0-rc4-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nCall Trace:\n <IRQ>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106\n nmi_cpu_backtrace.cold+0x47/0x144 lib/nmi_backtrace.c:111\n nmi_trigger_cpumask_backtrace+0x1b3/0x230 lib/nmi_backtrace.c:62\n trigger_single_cpu_backtrace include/linux/nmi.h:164 [inline]\n rcu_dump_cpu_stacks+0x25e/0x3f0 kernel/rcu/tree_stall.h:343\n print_cpu_stall kernel/rcu/tree_stall.h:627 [inline]\n check_cpu_stall kernel/rcu/tree_stall.h:711 [inline]\n rcu_pending kernel/rcu/tree.c:3878 [inline]\n rcu_sched_clock_irq.cold+0x9d/0x746 kernel/rcu/tree.c:2597\n update_process_times+0x16d/0x200 kernel/time/timer.c:1785\n tick_sched_handle+0x9b/0x180 kernel/time/tick-sched.c:226\n tick_sched_timer+0x1b0/0x2d0 kernel/time/tick-sched.c:1428\n __run_hrtimer kernel/time/hrtimer.c:1685 [inline]\n __hrtimer_run_queues+0x1c0/0xe50 kernel/time/hrtimer.c:1749\n hrtimer_interrupt+0x31c/0x790 kernel/time/hrtimer.c:1811\n local_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1086 [inline]\n __sysvec_apic_timer_interrupt+0x146/0x530 arch/x86/kernel/apic/apic.c:1103\n sysvec_apic_timer_interrupt+0x8e/0xc0 arch/x86/kernel/apic/apic.c:1097\n </IRQ>\n <TASK>\n asm_sysvec_apic_timer_interrupt+0x12/0x20 arch/x86/include/asm/idtentry.h:638\nRIP: 0010:write_comp_data kernel/kcov.c:221 [inline]\nRIP: 0010:__sanitizer_cov_trace_const_cmp1+0x1d/0x80 kernel/kcov.c:273\nCode: 54 c8 20 48 89 10 c3 66 0f 1f 44 00 00 53 41 89 fb 41 89 f1 bf 03 00 00 00 65 48 8b 0c 25 40 70 02 00 48 89 ce 4c 8b 54 24 08 <e8> 4e f7 ff ff 84 c0 74 51 48 8b 81 88 15 00 00 44 8b 81 84 15 00\nRSP: 0018:ffffc90000d27b28 EFLAGS: 00000246\nRAX: 0000000000000000 RBX: ffff888064bf1bf0 RCX: ffff888011928000\nRDX: ffff888011928000 RSI: ffff888011928000 RDI: 0000000000000003\nRBP: ffff888064bf1c28 R08: 0000000000000000 R09: 0000000000000000\nR10: ffffffff875d8295 R11: 0000000000000000 R12: 0000000000000000\nR13: ffff8880783dd300 R14: 0000000000000000 R15: 0000000000000000\n pie_calculate_probability+0x405/0x7c0 net/sched/sch_pie.c:418\n fq_pie_timer+0x170/0x2a0 net/sched/sch_fq_pie.c:383\n call_timer_fn+0x1a5/0x6b0 kernel/time/timer.c:1421\n expire_timers kernel/time/timer.c:1466 [inline]\n __run_timers.part.0+0x675/0xa20 kernel/time/timer.c:1734\n __run_timers kernel/time/timer.c:1715 [inline]\n run_timer_softirq+0xb3/0x1d0 kernel/time/timer.c:1747\n __do_softirq+0x29b/0x9c2 kernel/softirq.c:558\n run_ksoftirqd kernel/softirq.c:921 [inline]\n run_ksoftirqd+0x2d/0x60 kernel/softirq.c:913\n smpboot_thread_fn+0x645/0x9c0 kernel/smpboot.c:164\n kthread+0x405/0x4f0 kernel/kthread.c:327\n ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:295\n </TASK>",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2a51edaf5cc563574878b93d7ef3d5955dda7030"
          },
          {
            "url": "https://git.kernel.org/stable/c/61c2402665f1e10c5742033fce18392e369931d7"
          },
          {
            "url": "https://git.kernel.org/stable/c/d86216dfda7c98375f809e26a30bfdaaba21d46e"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47513",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:12.713",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: dsa: felix: Fix memory leak in felix_setup_mmio_filtering\nAvoid a memory leak if there is not a CPU port defined.\nAddresses-Coverity-ID: 1492897 (\"Resource leak\")\nAddresses-Coverity-ID: 1492899 (\"Resource leak\")",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/973a0373e88cc19129bd6ef0ec193040535397d9"
          },
          {
            "url": "https://git.kernel.org/stable/c/e8b1d7698038e76363859fb47ae0a262080646f5"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47514",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:12.790",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndevlink: fix netns refcount leak in devlink_nl_cmd_reload()\nWhile preparing my patch series adding netns refcount tracking,\nI spotted bugs in devlink_nl_cmd_reload()\nSome error paths forgot to release a refcount on a netns.\nTo fix this, we can reduce the scope of get_net()/put_net()\nsection around the call to devlink_reload().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4b7e90672af8e0c78205db006f1b0a20ebd07f5f"
          },
          {
            "url": "https://git.kernel.org/stable/c/4dbb0dad8e63fcd0b5a117c2861d2abe7ff5f186"
          },
          {
            "url": "https://git.kernel.org/stable/c/fe30b70ca84da9c4aca85c03ad86e7a9b89c5ded"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47515",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:12.937",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nseg6: fix the iif in the IPv6 socket control block\nWhen an IPv4 packet is received, the ip_rcv_core(...) sets the receiving\ninterface index into the IPv4 socket control block (v5.16-rc4,\nnet/ipv4/ip_input.c line 510):\n    IPCB(skb)->iif = skb->skb_iif;\nIf that IPv4 packet is meant to be encapsulated in an outer IPv6+SRH\nheader, the seg6_do_srh_encap(...) performs the required encapsulation.\nIn this case, the seg6_do_srh_encap function clears the IPv6 socket control\nblock (v5.16-rc4 net/ipv6/seg6_iptunnel.c line 163):\n    memset(IP6CB(skb), 0, sizeof(*IP6CB(skb)));\nThe memset(...) was introduced in commit ef489749aae5 (\"ipv6: sr: clear\nIP6CB(skb) on SRH ip4ip6 encapsulation\") a long time ago (2019-01-29).\nSince the IPv6 socket control block and the IPv4 socket control block share\nthe same memory area (skb->cb), the receiving interface index info is lost\n(IP6CB(skb)->iif is set to zero).\nAs a side effect, that condition triggers a NULL pointer dereference if\ncommit 0857d6f8c759 (\"ipv6: When forwarding count rx stats on the orig\nnetdev\") is applied.\nTo fix that issue, we set the IP6CB(skb)->iif with the index of the\nreceiving interface once again.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/6431e71093f3da586a00c6d931481ffb0dc2db0e"
          },
          {
            "url": "https://git.kernel.org/stable/c/666521b3852d2b2f52d570f9122b1e4b50d96831"
          },
          {
            "url": "https://git.kernel.org/stable/c/98adb2bbfa407c9290bda299d4c6f7a1c4ebd5e1"
          },
          {
            "url": "https://git.kernel.org/stable/c/ae68d93354e5bf5191ee673982251864ea24dd5c"
          },
          {
            "url": "https://git.kernel.org/stable/c/b16d412e5f79734033df04e97d7ea2f50a8e9fe3"
          },
          {
            "url": "https://git.kernel.org/stable/c/ef8804e47c0a44ae106ead1740408af5ea6c6ee9"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47516",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:13.130",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnfp: Fix memory leak in nfp_cpp_area_cache_add()\nIn line 800 (#1), nfp_cpp_area_alloc() allocates and initializes a\nCPP area structure. But in line 807 (#2), when the cache is allocated\nfailed, this CPP area structure is not freed, which will result in\nmemory leak.\nWe can fix it by freeing the CPP area when the cache is allocated\nfailed (#2).\n792 int nfp_cpp_area_cache_add(struct nfp_cpp *cpp, size_t size)\n793 {\n794 \tstruct nfp_cpp_area_cache *cache;\n795 \tstruct nfp_cpp_area *area;\n800\tarea = nfp_cpp_area_alloc(cpp, NFP_CPP_ID(7, NFP_CPP_ACTION_RW, 0),\n801 \t\t\t\t  0, size);\n\t// #1: allocates and initializes\n802 \tif (!area)\n803 \t\treturn -ENOMEM;\n805 \tcache = kzalloc(sizeof(*cache), GFP_KERNEL);\n806 \tif (!cache)\n807 \t\treturn -ENOMEM; // #2: missing free\n817\treturn 0;\n818 }",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2e0e072e62fdaf7816220af08e05c020f0fcb77a"
          },
          {
            "url": "https://git.kernel.org/stable/c/3e93abcdcec0436fbf0b6a88ae806902426895a2"
          },
          {
            "url": "https://git.kernel.org/stable/c/484069b5de9d223cc1c64c6f80389a99cfef51f1"
          },
          {
            "url": "https://git.kernel.org/stable/c/c56c96303e9289cc34716b1179597b6f470833de"
          },
          {
            "url": "https://git.kernel.org/stable/c/eb51f639ef3fd5498b7def290ed8681b6aadd9a7"
          },
          {
            "url": "https://git.kernel.org/stable/c/f707820c09239d6f67699d9b2ff57863cc7905b0"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47517",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:13.347",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nethtool: do not perform operations on net devices being unregistered\nThere is a short period between a net device starts to be unregistered\nand when it is actually gone. In that time frame ethtool operations\ncould still be performed, which might end up in unwanted or undefined\nbehaviours[1].\nDo not allow ethtool operations after a net device starts its\nunregistration. This patch targets the netlink part as the ioctl one\nisn't affected: the reference to the net device is taken and the\noperation is executed within an rtnl lock section and the net device\nwon't be found after unregister.\n[1] For example adding Tx queues after unregister ends up in NULL\n    pointer exceptions and UaFs, such as:\n      BUG: KASAN: use-after-free in kobject_get+0x14/0x90\n      Read of size 1 at addr ffff88801961248c by task ethtool/755\n      CPU: 0 PID: 755 Comm: ethtool Not tainted 5.15.0-rc6+ #778\n      Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-4.fc34 04/014\n      Call Trace:\n       dump_stack_lvl+0x57/0x72\n       print_address_description.constprop.0+0x1f/0x140\n       kasan_report.cold+0x7f/0x11b\n       kobject_get+0x14/0x90\n       kobject_add_internal+0x3d1/0x450\n       kobject_init_and_add+0xba/0xf0\n       netdev_queue_update_kobjects+0xcf/0x200\n       netif_set_real_num_tx_queues+0xb4/0x310\n       veth_set_channels+0x1c3/0x550\n       ethnl_set_channels+0x524/0x610",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/7c26da3be1e9843a15b5318f90db8a564479d2ac"
          },
          {
            "url": "https://git.kernel.org/stable/c/cfd719f04267108f5f5bf802b9d7de69e99a99f9"
          },
          {
            "url": "https://git.kernel.org/stable/c/dde91ccfa25fd58f64c397d91b81a4b393100ffa"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47518",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:13.557",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnfc: fix potential NULL pointer deref in nfc_genl_dump_ses_done\nThe done() netlink callback nfc_genl_dump_ses_done() should check if\nreceived argument is non-NULL, because its allocation could fail earlier\nin dumpit() (nfc_genl_dump_ses()).",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3b861a40325eac9c4c13b6c53874ad90617e944d"
          },
          {
            "url": "https://git.kernel.org/stable/c/48fcd08fdbe05e35b650a252ec2a2d96057a1c7a"
          },
          {
            "url": "https://git.kernel.org/stable/c/4cd8371a234d051f9c9557fcbb1f8c523b1c0d10"
          },
          {
            "url": "https://git.kernel.org/stable/c/69bb79a8f5bb9f436b6f1434ca9742591b7bbe18"
          },
          {
            "url": "https://git.kernel.org/stable/c/811a7576747760bcaf60502f096d1e6e91d566fa"
          },
          {
            "url": "https://git.kernel.org/stable/c/83ea620a1be840bf05089a5061fb8323ca42f38c"
          },
          {
            "url": "https://git.kernel.org/stable/c/87cdb8789c38e44ae5454aafe277997c950d00ed"
          },
          {
            "url": "https://git.kernel.org/stable/c/fae9705d281091254d4a81fa2da9d22346097dca"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47519",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:13.783",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ncan: m_can: m_can_read_fifo: fix memory leak in error branch\nIn m_can_read_fifo(), if the second call to m_can_fifo_read() fails,\nthe function jump to the out_fail label and returns without calling\nm_can_receive_skb(). This means that the skb previously allocated by\nalloc_can_skb() is not freed. In other terms, this is a memory leak.\nThis patch adds a goto label to destroy the skb if an error occurs.\nIssue was found with GCC -fanalyzer, please follow the link below for\ndetails.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/31cb32a590d62b18f69a9a6d433f4e69c74fdd56"
          },
          {
            "url": "https://git.kernel.org/stable/c/75a422165477dd12d2d20aa7c9ee7c9a281c9908"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47520",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:14.003",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ncan: pch_can: pch_can_rx_normal: fix use after free\nAfter calling netif_receive_skb(skb), dereferencing skb is unsafe.\nEspecially, the can_frame cf which aliases skb memory is dereferenced\njust after the call netif_receive_skb(skb).\nReordering the lines solves the issue.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3a3c46e2eff0577454860a203be1a8295f4acb76"
          },
          {
            "url": "https://git.kernel.org/stable/c/3e193ef4e0a3f5bf92ede83ef214cb09d01b00aa"
          },
          {
            "url": "https://git.kernel.org/stable/c/6c73fc931658d8cbc8a1714b326cb31eb71d16a7"
          },
          {
            "url": "https://git.kernel.org/stable/c/703dde112021c93d6e89443c070e7dbd4dea612e"
          },
          {
            "url": "https://git.kernel.org/stable/c/94cddf1e9227a171b27292509d59691819c458db"
          },
          {
            "url": "https://git.kernel.org/stable/c/abb4eff3dcd2e583060082a18a8dbf31f02689d4"
          },
          {
            "url": "https://git.kernel.org/stable/c/affbad02bf80380a7403885b9fe4a1587d1bb4f3"
          },
          {
            "url": "https://git.kernel.org/stable/c/bafe343a885c70dddf358379cf0b2a1c07355d8d"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47521",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:14.203",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ncan: sja1000: fix use after free in ems_pcmcia_add_card()\nIf the last channel is not available then \"dev\" is freed.  Fortunately,\nwe can just use \"pdev->irq\" instead.\nAlso we should check if at least one channel was set up.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1a295fea90e1acbe80c6d4940f5ff856edcd6bec"
          },
          {
            "url": "https://git.kernel.org/stable/c/1dd5b819f7e406dc15bbc7670596ff25261aaa2a"
          },
          {
            "url": "https://git.kernel.org/stable/c/3ec6ca6b1a8e64389f0212b5a1b0f6fed1909e45"
          },
          {
            "url": "https://git.kernel.org/stable/c/474f9a8534f5f89841240a7e978bafd6e1e039ce"
          },
          {
            "url": "https://git.kernel.org/stable/c/923f4dc5df679f678e121c20bf2fd70f7bf3e288"
          },
          {
            "url": "https://git.kernel.org/stable/c/c8718026ba287168ff9ad0ccc4f9a413062cba36"
          },
          {
            "url": "https://git.kernel.org/stable/c/cbd86110546f7f730a1f5d7de56c944a336c15c4"
          },
          {
            "url": "https://git.kernel.org/stable/c/ccf070183e4655824936c0f96c4a2bcca93419aa"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47522",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:14.540",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nHID: bigbenff: prevent null pointer dereference\nWhen emulating the device through uhid, there is a chance we don't have\noutput reports and so report_field is null.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/58f15f5ae7786c824868f3a7e093859b74669ce7"
          },
          {
            "url": "https://git.kernel.org/stable/c/6272b17001e6fdcf7b4a16206287010a1523fa6e"
          },
          {
            "url": "https://git.kernel.org/stable/c/8e0ceff632f48175ec7fb4706129c55ca8a7c7bd"
          },
          {
            "url": "https://git.kernel.org/stable/c/918aa1ef104d286d16b9e7ef139a463ac7a296f0"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47523",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:14.743",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nIB/hfi1: Fix leak of rcvhdrtail_dummy_kvaddr\nThis buffer is currently allocated in hfi1_init():\n\tif (reinit)\n\t\tret = init_after_reset(dd);\n\telse\n\t\tret = loadtime_init(dd);\n\tif (ret)\n\t\tgoto done;\n\t/* allocate dummy tail memory for all receive contexts */\n\tdd->rcvhdrtail_dummy_kvaddr = dma_alloc_coherent(&dd->pcidev->dev,\n\t\t\t\t\t\t\t sizeof(u64),\n\t\t\t\t\t\t\t &dd->rcvhdrtail_dummy_dma,\n\t\t\t\t\t\t\t GFP_KERNEL);\n\tif (!dd->rcvhdrtail_dummy_kvaddr) {\n\t\tdd_dev_err(dd, \"cannot allocate dummy tail memory\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\nThe reinit triggered path will overwrite the old allocation and leak it.\nFix by moving the allocation to hfi1_alloc_devdata() and the deallocation\nto hfi1_free_devdata().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2c08271f4ed0e24633b3f81ceff61052b9d45efc"
          },
          {
            "url": "https://git.kernel.org/stable/c/60a8b5a1611b4a26de4839ab9c1fc2a9cf3e17c1"
          },
          {
            "url": "https://git.kernel.org/stable/c/834d0fb978643eaf09da425de197cc16a7c2761b"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47524",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:14.973",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nserial: liteuart: fix minor-number leak on probe errors\nMake sure to release the allocated minor number before returning on\nprobe errors.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/888fc81107cacd2a4f681bac7bb785cef868214f"
          },
          {
            "url": "https://git.kernel.org/stable/c/dd5e90b16cca8a697cbe17b72e2a5f49291cabb2"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47525",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:15.167",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nserial: liteuart: fix use-after-free and memleak on unbind\nDeregister the port when unbinding the driver to prevent it from being\nused after releasing the driver data and leaking memory allocated by\nserial core.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/05f929b395dec8957b636ff14e66b277ed022ed9"
          },
          {
            "url": "https://git.kernel.org/stable/c/602824cf9aa9db8830ffe5cfb2cd54365cada4fe"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47526",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:15.383",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nserial: liteuart: Fix NULL pointer dereference in ->remove()\ndrvdata has to be set in _probe() - otherwise platform_get_drvdata()\ncauses null pointer dereference BUG in _remove().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0f55f89d98c8b3e12b4f55f71c127a173e29557c"
          },
          {
            "url": "https://git.kernel.org/stable/c/189c99c629bbf85916c02c153f904649cc0a9d7f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47527",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:15.580",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nserial: core: fix transmit-buffer reset and memleak\nCommit 761ed4a94582 (\"tty: serial_core: convert uart_close to use\ntty_port_close\") converted serial core to use tty_port_close() but\nfailed to notice that the transmit buffer still needs to be freed on\nfinal close.\nNot freeing the transmit buffer means that the buffer is no longer\ncleared on next open so that any ioctl() waiting for the buffer to drain\nmight wait indefinitely (e.g. on termios changes) or that stale data can\nend up being transmitted in case tx is restarted.\nFurthermore, the buffer of any port that has been opened would leak on\ndriver unbind.\nNote that the port lock is held when clearing the buffer pointer due to\nthe ldisc race worked around by commit a5ba1d95e46e (\"uart: fix race\nbetween uart_put_char() and uart_shutdown()\").\nAlso note that the tty-port shutdown() callback is not called for\nconsole ports so it is not strictly necessary to free the buffer page\nafter releasing the lock (cf. d72402145ace (\"tty/serial: do not free\ntrasnmit buffer page under port lock\")).",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/00de977f9e0aa9760d9a79d1e41ff780f74e3424"
          },
          {
            "url": "https://git.kernel.org/stable/c/011f6c92b5bf6e1fbfdedc8b5232f64c1c493206"
          },
          {
            "url": "https://git.kernel.org/stable/c/1179b168fa3f3a6aae3bd140000455a0e58457db"
          },
          {
            "url": "https://git.kernel.org/stable/c/64e491c1634b73d3bddc081d08620bdc92ab2c12"
          },
          {
            "url": "https://git.kernel.org/stable/c/c5da8aa441053958594f94254592bb41264bdfbf"
          },
          {
            "url": "https://git.kernel.org/stable/c/e1722acf4f0d4d67b60f57e08ce16f8b66cd4b8f"
          },
          {
            "url": "https://git.kernel.org/stable/c/e74d9663fd57640fc3394abb5c76fa95b9cc2f2e"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47528",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:15.763",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nusb: cdnsp: Fix a NULL pointer dereference in cdnsp_endpoint_init()\nIn cdnsp_endpoint_init(), cdnsp_ring_alloc() is assigned to pep->ring\nand there is a dereference of it in cdnsp_endpoint_init(), which could\nlead to a NULL pointer dereference on failure of cdnsp_ring_alloc().\nFix this bug by adding a check of pep->ring.\nThis bug was found by a static analyzer. The analysis employs\ndifferential checking to identify inconsistent security operations\n(e.g., checks or kfrees) between two code paths and confirms that the\ninconsistent operations are not recovered in the current function or\nthe callers, so they constitute bugs.\nNote that, as a bug found by static analysis, it can be a false\npositive or hard to trigger. Multiple researchers have cross-reviewed\nthe bug.\nBuilds with CONFIG_USB_CDNSP_GADGET=y show no new warnings,\nand our static analyzer no longer warns about this code.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/37307f7020ab38dde0892a578249bf63d00bca64"
          },
          {
            "url": "https://git.kernel.org/stable/c/7d94bc8e335cb33918e52efdbe192c36707bfa24"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47529",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:15.967",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\niwlwifi: Fix memory leaks in error handling path\nShould an error occur (invalid TLV len or memory allocation failure), the\nmemory already allocated in 'reduce_power_data' should be freed before\nreturning, otherwise it is leaking.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4768935c25403ba96e7a745645df24a51a774b7e"
          },
          {
            "url": "https://git.kernel.org/stable/c/a571bc28326d9f3e13f5f2d9cda2883e0631b0ce"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47530",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:16.147",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/msm: Fix wait_fence submitqueue leak\nWe weren't dropping the submitqueue reference in all paths.  In\nparticular, when the fence has already been signalled. Split out\na helper to simplify handling this in the various different return\npaths.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4c3cdbf2540319ea674f1f3c54f31f14c6f39647"
          },
          {
            "url": "https://git.kernel.org/stable/c/ea0006d390a28012f8187717aea61498b2b341e5"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47531",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:16.357",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/msm: Fix mmap to include VM_IO and VM_DONTDUMP\nIn commit 510410bfc034 (\"drm/msm: Implement mmap as GEM object\nfunction\") we switched to a new/cleaner method of doing things. That's\ngood, but we missed a little bit.\nBefore that commit, we used to _first_ run through the\ndrm_gem_mmap_obj() case where `obj->funcs->mmap()` was NULL. That meant\nthat we ran:\n  vma->vm_flags |= VM_IO | VM_PFNMAP | VM_DONTEXPAND | VM_DONTDUMP;\n  vma->vm_page_prot = pgprot_writecombine(vm_get_page_prot(vma->vm_flags));\n  vma->vm_page_prot = pgprot_decrypted(vma->vm_page_prot);\n...and _then_ we modified those mappings with our own. Now that\n`obj->funcs->mmap()` is no longer NULL we don't run the default\ncode. It looks like the fact that the vm_flags got VM_IO / VM_DONTDUMP\nwas important because we're now getting crashes on Chromebooks that\nuse ARC++ while logging out. Specifically a crash that looks like this\n(this is on a 5.10 kernel w/ relevant backports but also seen on a\n5.15 kernel):\n  Unable to handle kernel paging request at virtual address ffffffc008000000\n  Mem abort info:\n    ESR = 0x96000006\n    EC = 0x25: DABT (current EL), IL = 32 bits\n    SET = 0, FnV = 0\n    EA = 0, S1PTW = 0\n  Data abort info:\n    ISV = 0, ISS = 0x00000006\n    CM = 0, WnR = 0\n  swapper pgtable: 4k pages, 39-bit VAs, pgdp=000000008293d000\n  [ffffffc008000000] pgd=00000001002b3003, p4d=00000001002b3003,\n                     pud=00000001002b3003, pmd=0000000000000000\n  Internal error: Oops: 96000006 [#1] PREEMPT SMP\n  [...]\n  CPU: 7 PID: 15734 Comm: crash_dump64 Tainted: G W 5.10.67 #1 [...]\n  Hardware name: Qualcomm Technologies, Inc. sc7280 IDP SKU2 platform (DT)\n  pstate: 80400009 (Nzcv daif +PAN -UAO -TCO BTYPE=--)\n  pc : __arch_copy_to_user+0xc0/0x30c\n  lr : copyout+0xac/0x14c\n  [...]\n  Call trace:\n   __arch_copy_to_user+0xc0/0x30c\n   copy_page_to_iter+0x1a0/0x294\n   process_vm_rw_core+0x240/0x408\n   process_vm_rw+0x110/0x16c\n   __arm64_sys_process_vm_readv+0x30/0x3c\n   el0_svc_common+0xf8/0x250\n   do_el0_svc+0x30/0x80\n   el0_svc+0x10/0x1c\n   el0_sync_handler+0x78/0x108\n   el0_sync+0x184/0x1c0\n  Code: f8408423 f80008c3 910020c6 36100082 (b8404423)\nLet's add the two flags back in.\nWhile we're at it, the fact that we aren't running the default means\nthat we _don't_ need to clear out VM_PFNMAP, so remove that and save\nan instruction.\nNOTE: it was confirmed that VM_IO was the important flag to fix the\nproblem I was seeing, but adding back VM_DONTDUMP seems like a sane\nthing to do so I'm doing that too.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3466d9e217b337bf473ee629c608e53f9f3ab786"
          },
          {
            "url": "https://git.kernel.org/stable/c/8e2b7fe5e8a4be5e571561d9afcfbd92097288ba"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47532",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:16.567",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/msm/devfreq: Fix OPP refcnt leak",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/59ba1b2b4825342676300f66d785764be3fcb093"
          },
          {
            "url": "https://git.kernel.org/stable/c/a4eb55901df1dce8c6944438bbdf57caf08911e2"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47533",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:16.773",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/vc4: kms: Clear the HVS FIFO commit pointer once done\nCommit 9ec03d7f1ed3 (\"drm/vc4: kms: Wait on previous FIFO users before a\ncommit\") introduced a wait on the previous commit done on a given HVS\nFIFO.\nHowever, we never cleared that pointer once done. Since\ndrm_crtc_commit_put can free the drm_crtc_commit structure directly if\nwe were the last user, this means that it can lead to a use-after free\nif we were to duplicate the state, and that stale pointer would even be\ncopied to the new state.\nSet the pointer to NULL once we're done with the wait so that we don't\ncarry over a pointer to a free'd structure.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2931db9a5ed219546cf2ae0546698faf78281b89"
          },
          {
            "url": "https://git.kernel.org/stable/c/d134c5ff71c7f2320fc7997f2fbbdedf0c76889a"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47534",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:16.940",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/vc4: kms: Add missing drm_crtc_commit_put\nCommit 9ec03d7f1ed3 (\"drm/vc4: kms: Wait on previous FIFO users before a\ncommit\") introduced a global state for the HVS, with each FIFO storing\nthe current CRTC commit so that we can properly synchronize commits.\nHowever, the refcounting was off and we thus ended up leaking the\ndrm_crtc_commit structure every commit. Add a drm_crtc_commit_put to\nprevent the leakage.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/049cfff8d53a30cae3349ff71a4c01b7d9981bc2"
          },
          {
            "url": "https://git.kernel.org/stable/c/53f9601e908d42481addd67cdb01a9288c611124"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47535",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:17.120",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/msm/a6xx: Allocate enough space for GMU registers\nIn commit 142639a52a01 (\"drm/msm/a6xx: fix crashstate capture for\nA650\") we changed a6xx_get_gmu_registers() to read 3 sets of\nregisters. Unfortunately, we didn't change the memory allocation for\nthe array. That leads to a KASAN warning (this was on the chromeos-5.4\nkernel, which has the problematic commit backported to it):\n  BUG: KASAN: slab-out-of-bounds in _a6xx_get_gmu_registers+0x144/0x430\n  Write of size 8 at addr ffffff80c89432b0 by task A618-worker/209\n  CPU: 5 PID: 209 Comm: A618-worker Tainted: G        W         5.4.156-lockdep #22\n  Hardware name: Google Lazor Limozeen without Touchscreen (rev5 - rev8) (DT)\n  Call trace:\n   dump_backtrace+0x0/0x248\n   show_stack+0x20/0x2c\n   dump_stack+0x128/0x1ec\n   print_address_description+0x88/0x4a0\n   __kasan_report+0xfc/0x120\n   kasan_report+0x10/0x18\n   __asan_report_store8_noabort+0x1c/0x24\n   _a6xx_get_gmu_registers+0x144/0x430\n   a6xx_gpu_state_get+0x330/0x25d4\n   msm_gpu_crashstate_capture+0xa0/0x84c\n   recover_worker+0x328/0x838\n   kthread_worker_fn+0x32c/0x574\n   kthread+0x2dc/0x39c\n   ret_from_fork+0x10/0x18\n  Allocated by task 209:\n   __kasan_kmalloc+0xfc/0x1c4\n   kasan_kmalloc+0xc/0x14\n   kmem_cache_alloc_trace+0x1f0/0x2a0\n   a6xx_gpu_state_get+0x164/0x25d4\n   msm_gpu_crashstate_capture+0xa0/0x84c\n   recover_worker+0x328/0x838\n   kthread_worker_fn+0x32c/0x574\n   kthread+0x2dc/0x39c\n   ret_from_fork+0x10/0x18",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/83e54fcf0b14ca2d869dd37abe1bb6542805f538"
          },
          {
            "url": "https://git.kernel.org/stable/c/b4d25abf9720b69a03465b09d0d62d1998ed6708"
          },
          {
            "url": "https://git.kernel.org/stable/c/d646856a600e8635ba498f20b194219b158626e8"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47536",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:17.317",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/smc: fix wrong list_del in smc_lgr_cleanup_early\nsmc_lgr_cleanup_early() meant to delete the link\ngroup from the link group list, but it deleted\nthe list head by mistake.\nThis may cause memory corruption since we didn't\nremove the real link group from the list and later\nmemseted the link group structure.\nWe got a list corruption panic when testing:\n[  231.277259] list_del corruption. prev->next should be ffff8881398a8000, but was 0000000000000000\n[  231.278222] ------------[ cut here ]------------\n[  231.278726] kernel BUG at lib/list_debug.c:53!\n[  231.279326] invalid opcode: 0000 [#1] SMP NOPTI\n[  231.279803] CPU: 0 PID: 5 Comm: kworker/0:0 Not tainted 5.10.46+ #435\n[  231.280466] Hardware name: Alibaba Cloud ECS, BIOS 8c24b4c 04/01/2014\n[  231.281248] Workqueue: events smc_link_down_work\n[  231.281732] RIP: 0010:__list_del_entry_valid+0x70/0x90\n[  231.282258] Code: 4c 60 82 e8 7d cc 6a 00 0f 0b 48 89 fe 48 c7 c7 88 4c\n60 82 e8 6c cc 6a 00 0f 0b 48 89 fe 48 c7 c7 c0 4c 60 82 e8 5b cc 6a 00 <0f>\n0b 48 89 fe 48 c7 c7 00 4d 60 82 e8 4a cc 6a 00 0f 0b cc cc cc\n[  231.284146] RSP: 0018:ffffc90000033d58 EFLAGS: 00010292\n[  231.284685] RAX: 0000000000000054 RBX: ffff8881398a8000 RCX: 0000000000000000\n[  231.285415] RDX: 0000000000000001 RSI: ffff88813bc18040 RDI: ffff88813bc18040\n[  231.286141] RBP: ffffffff8305ad40 R08: 0000000000000003 R09: 0000000000000001\n[  231.286873] R10: ffffffff82803da0 R11: ffffc90000033b90 R12: 0000000000000001\n[  231.287606] R13: 0000000000000000 R14: ffff8881398a8000 R15: 0000000000000003\n[  231.288337] FS:  0000000000000000(0000) GS:ffff88813bc00000(0000) knlGS:0000000000000000\n[  231.289160] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  231.289754] CR2: 0000000000e72058 CR3: 000000010fa96006 CR4: 00000000003706f0\n[  231.290485] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  231.291211] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  231.291940] Call Trace:\n[  231.292211]  smc_lgr_terminate_sched+0x53/0xa0\n[  231.292677]  smc_switch_conns+0x75/0x6b0\n[  231.293085]  ? update_load_avg+0x1a6/0x590\n[  231.293517]  ? ttwu_do_wakeup+0x17/0x150\n[  231.293907]  ? update_load_avg+0x1a6/0x590\n[  231.294317]  ? newidle_balance+0xca/0x3d0\n[  231.294716]  smcr_link_down+0x50/0x1a0\n[  231.295090]  ? __wake_up_common_lock+0x77/0x90\n[  231.295534]  smc_link_down_work+0x46/0x60\n[  231.295933]  process_one_work+0x18b/0x350",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/77731fede297a23d26f2d169b4269466b2c82529"
          },
          {
            "url": "https://git.kernel.org/stable/c/789b6cc2a5f9123b9c549b886fdc47c865cfe0ba"
          },
          {
            "url": "https://git.kernel.org/stable/c/95518fe354d712dca6f431cf2a11b8f63bc9a66c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47537",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:17.543",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nocteontx2-af: Fix a memleak bug in rvu_mbox_init()\nIn rvu_mbox_init(), mbox_regions is not freed or passed out\nunder the switch-default region, which could lead to a memory leak.\nFix this bug by changing 'return err' to 'goto free_regions'.\nThis bug was found by a static analyzer. The analysis employs\ndifferential checking to identify inconsistent security operations\n(e.g., checks or kfrees) between two code paths and confirms that the\ninconsistent operations are not recovered in the current function or\nthe callers, so they constitute bugs.\nNote that, as a bug found by static analysis, it can be a false\npositive or hard to trigger. Multiple researchers have cross-reviewed\nthe bug.\nBuilds with CONFIG_OCTEONTX2_AF=y show no new warnings,\nand our static analyzer no longer warns about this code.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1c0ddef45b7e3dbe3ed073695d20faa572b7056a"
          },
          {
            "url": "https://git.kernel.org/stable/c/e07a097b4986afb8f925d0bb32612e1d3e88ce15"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47538",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:17.750",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nrxrpc: Fix rxrpc_local leak in rxrpc_lookup_peer()\nNeed to call rxrpc_put_local() for peer candidate before kfree() as it\nholds a ref to rxrpc_local.\n[DH: v2: Changed to abstract the peer freeing code out into a function]",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3e70e3a72d80b16094faccbe438cd53761c3503a"
          },
          {
            "url": "https://git.kernel.org/stable/c/60f0b9c42cb80833a03ca57c1c8b078d716e71d1"
          },
          {
            "url": "https://git.kernel.org/stable/c/913c24af2d13a3fd304462916ee98e298d56bdce"
          },
          {
            "url": "https://git.kernel.org/stable/c/9469273e616ca8f1b6e3773c5019f21b4c8d828c"
          },
          {
            "url": "https://git.kernel.org/stable/c/beacff50edbd6c9659a6f15fc7f6126909fade29"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47539",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:17.963",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nrxrpc: Fix rxrpc_peer leak in rxrpc_look_up_bundle()\nNeed to call rxrpc_put_peer() for bundle candidate before kfree() as it\nholds a ref to rxrpc_peer.\n[DH: v2: Changed to abstract out the bundle freeing code into a function]",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/35b40f724c4ef0f683d94dab3af9ab38261d782b"
          },
          {
            "url": "https://git.kernel.org/stable/c/bc97458620e38961af9505cc060ad4cf5c9e4af7"
          },
          {
            "url": "https://git.kernel.org/stable/c/ca77fba821351190777b236ce749d7c4d353102e"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47540",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:18.147",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmt76: mt7915: fix NULL pointer dereference in mt7915_get_phy_mode\nFix the following NULL pointer dereference in mt7915_get_phy_mode\nroutine adding an ibss interface to the mt7915 driver.\n[  101.137097] wlan0: Trigger new scan to find an IBSS to join\n[  102.827039] wlan0: Creating new IBSS network, BSSID 26:a4:50:1a:6e:69\n[  103.064756] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000\n[  103.073670] Mem abort info:\n[  103.076520]   ESR = 0x96000005\n[  103.079614]   EC = 0x25: DABT (current EL), IL = 32 bits\n[  103.084934]   SET = 0, FnV = 0\n[  103.088042]   EA = 0, S1PTW = 0\n[  103.091215] Data abort info:\n[  103.094104]   ISV = 0, ISS = 0x00000005\n[  103.098041]   CM = 0, WnR = 0\n[  103.101044] user pgtable: 4k pages, 39-bit VAs, pgdp=00000000460b1000\n[  103.107565] [0000000000000000] pgd=0000000000000000, p4d=0000000000000000, pud=0000000000000000\n[  103.116590] Internal error: Oops: 96000005 [#1] SMP\n[  103.189066] CPU: 1 PID: 333 Comm: kworker/u4:3 Not tainted 5.10.75 #0\n[  103.195498] Hardware name: MediaTek MT7622 RFB1 board (DT)\n[  103.201124] Workqueue: phy0 ieee80211_iface_work [mac80211]\n[  103.206695] pstate: 20000005 (nzCv daif -PAN -UAO -TCO BTYPE=--)\n[  103.212705] pc : mt7915_get_phy_mode+0x68/0x120 [mt7915e]\n[  103.218103] lr : mt7915_mcu_add_bss_info+0x11c/0x760 [mt7915e]\n[  103.223927] sp : ffffffc011cdb9e0\n[  103.227235] x29: ffffffc011cdb9e0 x28: ffffff8006563098\n[  103.232545] x27: ffffff8005f4da22 x26: ffffff800685ac40\n[  103.237855] x25: 0000000000000001 x24: 000000000000011f\n[  103.243165] x23: ffffff8005f4e260 x22: ffffff8006567918\n[  103.248475] x21: ffffff8005f4df80 x20: ffffff800685ac58\n[  103.253785] x19: ffffff8006744400 x18: 0000000000000000\n[  103.259094] x17: 0000000000000000 x16: 0000000000000001\n[  103.264403] x15: 000899c3a2d9d2e4 x14: 000899bdc3c3a1c8\n[  103.269713] x13: 0000000000000000 x12: 0000000000000000\n[  103.275024] x11: ffffffc010e30c20 x10: 0000000000000000\n[  103.280333] x9 : 0000000000000050 x8 : ffffff8006567d88\n[  103.285642] x7 : ffffff8006563b5c x6 : ffffff8006563b44\n[  103.290952] x5 : 0000000000000002 x4 : 0000000000000001\n[  103.296262] x3 : 0000000000000001 x2 : 0000000000000001\n[  103.301572] x1 : 0000000000000000 x0 : 0000000000000011\n[  103.306882] Call trace:\n[  103.309328]  mt7915_get_phy_mode+0x68/0x120 [mt7915e]\n[  103.314378]  mt7915_bss_info_changed+0x198/0x200 [mt7915e]\n[  103.319941]  ieee80211_bss_info_change_notify+0x128/0x290 [mac80211]\n[  103.326360]  __ieee80211_sta_join_ibss+0x308/0x6c4 [mac80211]\n[  103.332171]  ieee80211_sta_create_ibss+0x8c/0x10c [mac80211]\n[  103.337895]  ieee80211_ibss_work+0x3dc/0x614 [mac80211]\n[  103.343185]  ieee80211_iface_work+0x388/0x3f0 [mac80211]\n[  103.348495]  process_one_work+0x288/0x690\n[  103.352499]  worker_thread+0x70/0x464\n[  103.356157]  kthread+0x144/0x150\n[  103.359380]  ret_from_fork+0x10/0x18\n[  103.362952] Code: 394008c3 52800220 394000e4 7100007f (39400023)",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/14b03b8cebdf18ff13c39d58501b625411314de2"
          },
          {
            "url": "https://git.kernel.org/stable/c/6e53d6d26920d5221d3f4d4f5ffdd629ea69aa5c"
          },
          {
            "url": "https://git.kernel.org/stable/c/932b338f4e5c4cb0c2ed640da3bced1e63620198"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47541",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:18.330",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/mlx4_en: Fix an use-after-free bug in mlx4_en_try_alloc_resources()\nIn mlx4_en_try_alloc_resources(), mlx4_en_copy_priv() is called and\ntmp->tx_cq will be freed on the error path of mlx4_en_copy_priv().\nAfter that mlx4_en_alloc_resources() is called and there is a dereference\nof &tmp->tx_cq[t][i] in mlx4_en_alloc_resources(), which could lead to\na use after free problem on failure of mlx4_en_copy_priv().\nFix this bug by adding a check of mlx4_en_copy_priv()\nThis bug was found by a static analyzer. The analysis employs\ndifferential checking to identify inconsistent security operations\n(e.g., checks or kfrees) between two code paths and confirms that the\ninconsistent operations are not recovered in the current function or\nthe callers, so they constitute bugs.\nNote that, as a bug found by static analysis, it can be a false\npositive or hard to trigger. Multiple researchers have cross-reviewed\nthe bug.\nBuilds with CONFIG_MLX4_EN=m show no new warnings,\nand our static analyzer no longer warns about this code.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/676dc7d9b15bf8733233a2db1ec3f9091ab34275"
          },
          {
            "url": "https://git.kernel.org/stable/c/75917372eef0dbfb290ae45474314d35f97aea18"
          },
          {
            "url": "https://git.kernel.org/stable/c/addad7643142f500080417dd7272f49b7a185570"
          },
          {
            "url": "https://git.kernel.org/stable/c/be12572c5ddc8ad7453bada4eec8fa46967dc757"
          },
          {
            "url": "https://git.kernel.org/stable/c/e461a9816a1ac5b4aeb61621b817225b61e46a68"
          },
          {
            "url": "https://git.kernel.org/stable/c/f1d43efa59f1edd3e7eca0e94559b4c6b1cd4e2b"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47542",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:18.550",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: qlogic: qlcnic: Fix a NULL pointer dereference in qlcnic_83xx_add_rings()\nIn qlcnic_83xx_add_rings(), the indirect function of\nahw->hw_ops->alloc_mbx_args will be called to allocate memory for\ncmd.req.arg, and there is a dereference of it in qlcnic_83xx_add_rings(),\nwhich could lead to a NULL pointer dereference on failure of the\nindirect function like qlcnic_83xx_alloc_mbx_args().\nFix this bug by adding a check of alloc_mbx_args(), this patch\nimitates the logic of mbx_cmd()'s failure handling.\nThis bug was found by a static analyzer. The analysis employs\ndifferential checking to identify inconsistent security operations\n(e.g., checks or kfrees) between two code paths and confirms that the\ninconsistent operations are not recovered in the current function or\nthe callers, so they constitute bugs.\nNote that, as a bug found by static analysis, it can be a false\npositive or hard to trigger. Multiple researchers have cross-reviewed\nthe bug.\nBuilds with CONFIG_QLCNIC=m show no new warnings, and our\nstatic analyzer no longer warns about this code.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/15fa12c119f869173f9b710cbe6a4a14071d2105"
          },
          {
            "url": "https://git.kernel.org/stable/c/3a061d54e260b701b538873b43e399d9b8b83e03"
          },
          {
            "url": "https://git.kernel.org/stable/c/550658a2d61e4eaf522c8ebc7fad76dc376bfb45"
          },
          {
            "url": "https://git.kernel.org/stable/c/57af54a56024435d83e44c78449513b414eb6edf"
          },
          {
            "url": "https://git.kernel.org/stable/c/b4f217d6fcc00c3fdc0921a7691f30be7490b073"
          },
          {
            "url": "https://git.kernel.org/stable/c/bbeb0325a7460ebf1e03f5e0bfc5c652fba9519f"
          },
          {
            "url": "https://git.kernel.org/stable/c/c5ef33c1489b2cd74368057fa00b5d2183bb5853"
          },
          {
            "url": "https://git.kernel.org/stable/c/e2dabc4f7e7b60299c20a36d6a7b24ed9bf8e572"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47543",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:18.777",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nperf report: Fix memory leaks around perf_tip()\nperf_tip() may allocate memory or use a literal, this means memory\nwasn't freed if allocated. Change the API so that literals aren't used.\nAt the same time add missing frees for system_path. These issues were\nspotted using leak sanitizer.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/71e284dcebecb9fd204ff11097469cc547723ad1"
          },
          {
            "url": "https://git.kernel.org/stable/c/d9fc706108c15f8bc2d4ccccf8e50f74830fabd9"
          },
          {
            "url": "https://git.kernel.org/stable/c/df5990db088d4c7fea9a2f9b8195a7859e1768c4"
          },
          {
            "url": "https://git.kernel.org/stable/c/ff061b5bda73c4f785b4703eeb0848fd99e5608a"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47544",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:18.983",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ntcp: fix page frag corruption on page fault\nSteffen reported a TCP stream corruption for HTTP requests\nserved by the apache web-server using a cifs mount-point\nand memory mapping the relevant file.\nThe root cause is quite similar to the one addressed by\ncommit 20eb4f29b602 (\"net: fix sk_page_frag() recursion from\nmemory reclaim\"). Here the nested access to the task page frag\nis caused by a page fault on the (mmapped) user-space memory\nbuffer coming from the cifs file.\nThe page fault handler performs an smb transaction on a different\nsocket, inside the same process context. Since sk->sk_allaction\nfor such socket does not prevent the usage for the task_frag,\nthe nested allocation modify \"under the hood\" the page frag\nin use by the outer sendmsg call, corrupting the stream.\nThe overall relevant stack trace looks like the following:\nhttpd 78268 [001] 3461630.850950:      probe:tcp_sendmsg_locked:\n        ffffffff91461d91 tcp_sendmsg_locked+0x1\n        ffffffff91462b57 tcp_sendmsg+0x27\n        ffffffff9139814e sock_sendmsg+0x3e\n        ffffffffc06dfe1d smb_send_kvec+0x28\n        [...]\n        ffffffffc06cfaf8 cifs_readpages+0x213\n        ffffffff90e83c4b read_pages+0x6b\n        ffffffff90e83f31 __do_page_cache_readahead+0x1c1\n        ffffffff90e79e98 filemap_fault+0x788\n        ffffffff90eb0458 __do_fault+0x38\n        ffffffff90eb5280 do_fault+0x1a0\n        ffffffff90eb7c84 __handle_mm_fault+0x4d4\n        ffffffff90eb8093 handle_mm_fault+0xc3\n        ffffffff90c74f6d __do_page_fault+0x1ed\n        ffffffff90c75277 do_page_fault+0x37\n        ffffffff9160111e page_fault+0x1e\n        ffffffff9109e7b5 copyin+0x25\n        ffffffff9109eb40 _copy_from_iter_full+0xe0\n        ffffffff91462370 tcp_sendmsg_locked+0x5e0\n        ffffffff91462370 tcp_sendmsg_locked+0x5e0\n        ffffffff91462b57 tcp_sendmsg+0x27\n        ffffffff9139815c sock_sendmsg+0x4c\n        ffffffff913981f7 sock_write_iter+0x97\n        ffffffff90f2cc56 do_iter_readv_writev+0x156\n        ffffffff90f2dff0 do_iter_write+0x80\n        ffffffff90f2e1c3 vfs_writev+0xa3\n        ffffffff90f2e27c do_writev+0x5c\n        ffffffff90c042bb do_syscall_64+0x5b\n        ffffffff916000ad entry_SYSCALL_64_after_hwframe+0x65\nThe cifs filesystem rightfully sets sk_allocations to GFP_NOFS,\nwe can avoid the nesting using the sk page frag for allocation\nlacking the __GFP_FS flag. Do not define an additional mm-helper\nfor that, as this is strictly tied to the sk page frag usage.\nv1 -> v2:\n - use a stricted sk_page_frag() check instead of reordering the\n   code (Eric)",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/5a9afcd827cafe14a95c9fcbded2c2d104f18dfc"
          },
          {
            "url": "https://git.kernel.org/stable/c/c6f340a331fb72e5ac23a083de9c780e132ca3ae"
          },
          {
            "url": "https://git.kernel.org/stable/c/dacb5d8875cc6cd3a553363b4d6f06760fcbe70c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47545",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:19.200",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nperf hist: Fix memory leak of a perf_hpp_fmt\nperf_hpp__column_unregister() removes an entry from a list but doesn't\nfree the memory causing a memory leak spotted by leak sanitizer.\nAdd the free while at the same time reducing the scope of the function\nto static.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0ca1f534a776cc7d42f2c33da4732b74ec2790cd"
          },
          {
            "url": "https://git.kernel.org/stable/c/24a139c105fa0f7f99888cf328bf6a02fc841675"
          },
          {
            "url": "https://git.kernel.org/stable/c/5b5c6f57a1f81499db4c8ea597898cb1b87de0b6"
          },
          {
            "url": "https://git.kernel.org/stable/c/a4c17ebdd6249cb4e061358d3693383f6628e069"
          },
          {
            "url": "https://git.kernel.org/stable/c/b380d09e44e8479e71e3ae8446b515a5b3166244"
          },
          {
            "url": "https://git.kernel.org/stable/c/c5c8a26c0dc69a400553245e92d741fe55f91095"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47546",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:19.450",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nipv6: fix memory leak in fib6_rule_suppress\nThe kernel leaks memory when a `fib` rule is present in IPv6 nftables\nfirewall rules and a suppress_prefix rule is present in the IPv6 routing\nrules (used by certain tools such as wg-quick). In such scenarios, every\nincoming packet will leak an allocation in `ip6_dst_cache` slab cache.\nAfter some hours of `bpftrace`-ing and source code reading, I tracked\ndown the issue to ca7a03c41753 (\"ipv6: do not free rt if\nFIB_LOOKUP_NOREF is set on suppress rule\").\nThe problem with that change is that the generic `args->flags` always have\n`FIB_LOOKUP_NOREF` set[1][2] but the IPv6-specific flag\n`RT6_LOOKUP_F_DST_NOREF` might not be, leading to `fib6_rule_suppress` not\ndecreasing the refcount when needed.\nHow to reproduce:\n - Add the following nftables rule to a prerouting chain:\n     meta nfproto ipv6 fib saddr . mark . iif oif missing drop\n   This can be done with:\n     sudo nft create table inet test\n     sudo nft create chain inet test test_chain '{ type filter hook prerouting priority filter + 10; policy accept; }'\n     sudo nft add rule inet test test_chain meta nfproto ipv6 fib saddr . mark . iif oif missing drop\n - Run:\n     sudo ip -6 rule add table main suppress_prefixlength 0\n - Watch `sudo slabtop -o | grep ip6_dst_cache` to see memory usage increase\n   with every incoming ipv6 packet.\nThis patch exposes the protocol-specific flags to the protocol\nspecific `suppress` function, and check the protocol-specific `flags`\nargument for RT6_LOOKUP_F_DST_NOREF instead of the generic\nFIB_LOOKUP_NOREF when decreasing the refcount, like this.\n[1]: https://github.com/torvalds/linux/blob/ca7a03c4175366a92cee0ccc4fec0038c3266e26/net/ipv6/fib6_rules.c#L71\n[2]: https://github.com/torvalds/linux/blob/ca7a03c4175366a92cee0ccc4fec0038c3266e26/net/ipv6/fib6_rules.c#L99",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/209d35ee34e25f9668c404350a1c86d914c54ffa"
          },
          {
            "url": "https://git.kernel.org/stable/c/8ef8a76a340ebdb2c2eea3f6fb0ebbed09a16383"
          },
          {
            "url": "https://git.kernel.org/stable/c/cdef485217d30382f3bf6448c54b4401648fe3f1"
          },
          {
            "url": "https://git.kernel.org/stable/c/ee38eb8cf9a7323884c2b8e0adbbeb2192d31e29"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47547",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:19.570",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: tulip: de4x5: fix the problem that the array 'lp->phy[8]' may be out of bound\nIn line 5001, if all id in the array 'lp->phy[8]' is not 0, when the\n'for' end, the 'k' is 8.\nAt this time, the array 'lp->phy[8]' may be out of bound.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/12f907cb11576b8cd0b1d95a16d1f10ed5bb7237"
          },
          {
            "url": "https://git.kernel.org/stable/c/142ead3dc70411bd5977e8c47a6d8bf22287b3f8"
          },
          {
            "url": "https://git.kernel.org/stable/c/2c1a6a9a011d622a7c61324a97a49801ba425eff"
          },
          {
            "url": "https://git.kernel.org/stable/c/61217be886b5f7402843677e4be7e7e83de9cb41"
          },
          {
            "url": "https://git.kernel.org/stable/c/77ff166909458646e66450e42909e0adacc99049"
          },
          {
            "url": "https://git.kernel.org/stable/c/d3dedaa5a601107cfedda087209772c76e364d58"
          },
          {
            "url": "https://git.kernel.org/stable/c/ec5bd0aef1cec96830d0c7e06d3597d9e786cc98"
          },
          {
            "url": "https://git.kernel.org/stable/c/f059fa40f0fcc6bc7a12e0f2a2504e9a4ff74f1f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47548",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:19.693",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nethernet: hisilicon: hns: hns_dsaf_misc: fix a possible array overflow in hns_dsaf_ge_srst_by_port()\nThe if statement:\n  if (port >= DSAF_GE_NUM)\n        return;\nlimits the value of port less than DSAF_GE_NUM (i.e., 8).\nHowever, if the value of port is 6 or 7, an array overflow could occur:\n  port_rst_off = dsaf_dev->mac_cb[port]->port_rst_off;\nbecause the length of dsaf_dev->mac_cb is DSAF_MAX_PORT_NUM (i.e., 6).\nTo fix this possible array overflow, we first check port and if it is\ngreater than or equal to DSAF_MAX_PORT_NUM, the function returns.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/22519eff7df2d88adcc2568d86046ce1e2b52803"
          },
          {
            "url": "https://git.kernel.org/stable/c/948968f8747650447c8f21c9fdba0e1973be040b"
          },
          {
            "url": "https://git.kernel.org/stable/c/99bb25cb6753beaf2c2bc37927c2ecc0ceff3f6d"
          },
          {
            "url": "https://git.kernel.org/stable/c/a66998e0fbf213d47d02813b9679426129d0d114"
          },
          {
            "url": "https://git.kernel.org/stable/c/abbd5faa0748d0aa95d5191d56ff7a17a6275bd1"
          },
          {
            "url": "https://git.kernel.org/stable/c/dd07f8971b81ad98cc754b179b331b57f35aa1ff"
          },
          {
            "url": "https://git.kernel.org/stable/c/fc7ffa7f10b9454a86369405d9814bf141b30627"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47549",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:19.773",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nsata_fsl: fix UAF in sata_fsl_port_stop when rmmod sata_fsl\nWhen the `rmmod sata_fsl.ko` command is executed in the PPC64 GNU/Linux,\na bug is reported:\n ==================================================================\n BUG: Unable to handle kernel data access on read at 0x80000800805b502c\n Oops: Kernel access of bad area, sig: 11 [#1]\n NIP [c0000000000388a4] .ioread32+0x4/0x20\n LR [80000000000c6034] .sata_fsl_port_stop+0x44/0xe0 [sata_fsl]\n Call Trace:\n  .free_irq+0x1c/0x4e0 (unreliable)\n  .ata_host_stop+0x74/0xd0 [libata]\n  .release_nodes+0x330/0x3f0\n  .device_release_driver_internal+0x178/0x2c0\n  .driver_detach+0x64/0xd0\n  .bus_remove_driver+0x70/0xf0\n  .driver_unregister+0x38/0x80\n  .platform_driver_unregister+0x14/0x30\n  .fsl_sata_driver_exit+0x18/0xa20 [sata_fsl]\n  .__se_sys_delete_module+0x1ec/0x2d0\n  .system_call_exception+0xfc/0x1f0\n  system_call_common+0xf8/0x200\n ==================================================================\nThe triggering of the BUG is shown in the following stack:\ndriver_detach\n  device_release_driver_internal\n    __device_release_driver\n      drv->remove(dev) --> platform_drv_remove/platform_remove\n        drv->remove(dev) --> sata_fsl_remove\n          iounmap(host_priv->hcr_base);\t\t\t<---- unmap\n          kfree(host_priv);                             <---- free\n      devres_release_all\n        release_nodes\n          dr->node.release(dev, dr->data) --> ata_host_stop\n            ap->ops->port_stop(ap) --> sata_fsl_port_stop\n                ioread32(hcr_base + HCONTROL)           <---- UAF\n            host->ops->host_stop(host)\nThe iounmap(host_priv->hcr_base) and kfree(host_priv) functions should\nnot be executed in drv->remove. These functions should be executed in\nhost_stop after port_stop. Therefore, we move these functions to the\nnew function sata_fsl_host_stop and bind the new function to host_stop.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0769449b0a5eabc3545337217ae690e46673e73a"
          },
          {
            "url": "https://git.kernel.org/stable/c/325ea49fc43cbc03a5e1e37de8f0ca6357ced4b1"
          },
          {
            "url": "https://git.kernel.org/stable/c/4a46b2f5dce02539e88a300800812bd24a45e097"
          },
          {
            "url": "https://git.kernel.org/stable/c/6c8ad7e8cf29eb55836e7a0215f967746ab2b504"
          },
          {
            "url": "https://git.kernel.org/stable/c/77393806c76b6b44f1c44bd957788c8bd9152c45"
          },
          {
            "url": "https://git.kernel.org/stable/c/91ba94d3f7afca195b224f77a72044fbde1389ce"
          },
          {
            "url": "https://git.kernel.org/stable/c/adf098e2a8a1e1fc075d6a5ba2edd13cf7189082"
          },
          {
            "url": "https://git.kernel.org/stable/c/cdcd80292106df5cda325426e96495503e41f947"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47550",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:19.857",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/amd/amdgpu: fix potential memleak\nIn function amdgpu_get_xgmi_hive, when kobject_init_and_add failed\nThere is a potential memleak if not call kobject_put.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/27dfaedc0d321b4ea4e10c53e4679d6911ab17aa"
          },
          {
            "url": "https://git.kernel.org/stable/c/75752ada77e0726327adf68018b9f50ae091baeb"
          },
          {
            "url": "https://git.kernel.org/stable/c/c746945fb6bcbe3863c9ea6369c7ef376e38e5eb"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47551",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:19.927",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/amd/amdkfd: Fix kernel panic when reset failed and been triggered again\nIn SRIOV configuration, the reset may failed to bring asic back to normal but stop cpsch\nalready been called, the start_cpsch will not be called since there is no resume in this\ncase.  When reset been triggered again, driver should avoid to do uninitialization again.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/06c6f8f86ec243b89e52f0c3dc7062bcb9de74df"
          },
          {
            "url": "https://git.kernel.org/stable/c/2cf49e00d40d5132e3d067b5aa6d84791929ab15"
          },
          {
            "url": "https://git.kernel.org/stable/c/74aafe99efb68f15e50be9f7032c2168512f98a8"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47552",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:20.000",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nblk-mq: cancel blk-mq dispatch work in both blk_cleanup_queue and disk_release()\nFor avoiding to slow down queue destroy, we don't call\nblk_mq_quiesce_queue() in blk_cleanup_queue(), instead of delaying to\ncancel dispatch work in blk_release_queue().\nHowever, this way has caused kernel oops[1], reported by Changhui. The log\nshows that scsi_device can be freed before running blk_release_queue(),\nwhich is expected too since scsi_device is released after the scsi disk\nis closed and the scsi_device is removed.\nFixes the issue by canceling blk-mq dispatch work in both blk_cleanup_queue()\nand disk_release():\n1) when disk_release() is run, the disk has been closed, and any sync\ndispatch activities have been done, so canceling dispatch work is enough to\nquiesce filesystem I/O dispatch activity.\n2) in blk_cleanup_queue(), we only focus on passthrough request, and\npassthrough request is always explicitly allocated & freed by\nits caller, so once queue is frozen, all sync dispatch activity\nfor passthrough request has been done, then it is enough to just cancel\ndispatch work for avoiding any dispatch activity.\n[1] kernel panic log\n[12622.769416] BUG: kernel NULL pointer dereference, address: 0000000000000300\n[12622.777186] #PF: supervisor read access in kernel mode\n[12622.782918] #PF: error_code(0x0000) - not-present page\n[12622.788649] PGD 0 P4D 0\n[12622.791474] Oops: 0000 [#1] PREEMPT SMP PTI\n[12622.796138] CPU: 10 PID: 744 Comm: kworker/10:1H Kdump: loaded Not tainted 5.15.0+ #1\n[12622.804877] Hardware name: Dell Inc. PowerEdge R730/0H21J3, BIOS 1.5.4 10/002/2015\n[12622.813321] Workqueue: kblockd blk_mq_run_work_fn\n[12622.818572] RIP: 0010:sbitmap_get+0x75/0x190\n[12622.823336] Code: 85 80 00 00 00 41 8b 57 08 85 d2 0f 84 b1 00 00 00 45 31 e4 48 63 cd 48 8d 1c 49 48 c1 e3 06 49 03 5f 10 4c 8d 6b 40 83 f0 01 <48> 8b 33 44 89 f2 4c 89 ef 0f b6 c8 e8 fa f3 ff ff 83 f8 ff 75 58\n[12622.844290] RSP: 0018:ffffb00a446dbd40 EFLAGS: 00010202\n[12622.850120] RAX: 0000000000000001 RBX: 0000000000000300 RCX: 0000000000000004\n[12622.858082] RDX: 0000000000000006 RSI: 0000000000000082 RDI: ffffa0b7a2dfe030\n[12622.866042] RBP: 0000000000000004 R08: 0000000000000001 R09: ffffa0b742721334\n[12622.874003] R10: 0000000000000008 R11: 0000000000000008 R12: 0000000000000000\n[12622.881964] R13: 0000000000000340 R14: 0000000000000000 R15: ffffa0b7a2dfe030\n[12622.889926] FS:  0000000000000000(0000) GS:ffffa0baafb40000(0000) knlGS:0000000000000000\n[12622.898956] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[12622.905367] CR2: 0000000000000300 CR3: 0000000641210001 CR4: 00000000001706e0\n[12622.913328] Call Trace:\n[12622.916055]  <TASK>\n[12622.918394]  scsi_mq_get_budget+0x1a/0x110\n[12622.922969]  __blk_mq_do_dispatch_sched+0x1d4/0x320\n[12622.928404]  ? pick_next_task_fair+0x39/0x390\n[12622.933268]  __blk_mq_sched_dispatch_requests+0xf4/0x140\n[12622.939194]  blk_mq_sched_dispatch_requests+0x30/0x60\n[12622.944829]  __blk_mq_run_hw_queue+0x30/0xa0\n[12622.949593]  process_one_work+0x1e8/0x3c0\n[12622.954059]  worker_thread+0x50/0x3b0\n[12622.958144]  ? rescuer_thread+0x370/0x370\n[12622.962616]  kthread+0x158/0x180\n[12622.966218]  ? set_kthread_struct+0x40/0x40\n[12622.970884]  ret_from_fork+0x22/0x30\n[12622.974875]  </TASK>\n[12622.977309] Modules linked in: scsi_debug rpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver nfs lockd grace fscache netfs sunrpc dm_multipath intel_rapl_msr intel_rapl_common dell_wmi_descriptor sb_edac rfkill video x86_pkg_temp_thermal intel_powerclamp dcdbas coretemp kvm_intel kvm mgag200 irqbypass i2c_algo_bit rapl drm_kms_helper ipmi_ssif intel_cstate intel_uncore syscopyarea sysfillrect sysimgblt fb_sys_fops pcspkr cec mei_me lpc_ich mei ipmi_si ipmi_devintf ipmi_msghandler acpi_power_meter drm fuse xfs libcrc32c sr_mod cdrom sd_mod t10_pi sg ixgbe ahci libahci crct10dif_pclmul crc32_pclmul crc32c_intel libata megaraid_sas ghash_clmulni_intel tg3 wdat_w\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2a19b28f7929866e1cec92a3619f4de9f2d20005"
          },
          {
            "url": "https://git.kernel.org/stable/c/e03513f58919d9e2bc6df765ca2c9da863d03d90"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47553",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:20.080",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nsched/scs: Reset task stack state in bringup_cpu()\nTo hot unplug a CPU, the idle task on that CPU calls a few layers of C\ncode before finally leaving the kernel. When KASAN is in use, poisoned\nshadow is left around for each of the active stack frames, and when\nshadow call stacks are in use. When shadow call stacks (SCS) are in use\nthe task's saved SCS SP is left pointing at an arbitrary point within\nthe task's shadow call stack.\nWhen a CPU is offlined than onlined back into the kernel, this stale\nstate can adversely affect execution. Stale KASAN shadow can alias new\nstackframes and result in bogus KASAN warnings. A stale SCS SP is\neffectively a memory leak, and prevents a portion of the shadow call\nstack being used. Across a number of hotplug cycles the idle task's\nentire shadow call stack can become unusable.\nWe previously fixed the KASAN issue in commit:\n  e1b77c92981a5222 (\"sched/kasan: remove stale KASAN poison after hotplug\")\n... by removing any stale KASAN stack poison immediately prior to\nonlining a CPU.\nSubsequently in commit:\n  f1a0a376ca0c4ef1 (\"sched/core: Initialize the idle task with preemption disabled\")\n... the refactoring left the KASAN and SCS cleanup in one-time idle\nthread initialization code rather than something invoked prior to each\nCPU being onlined, breaking both as above.\nWe fixed SCS (but not KASAN) in commit:\n  63acd42c0d4942f7 (\"sched/scs: Reset the shadow stack when idle_task_exit\")\n... but as this runs in the context of the idle task being offlined it's\npotentially fragile.\nTo fix these consistently and more robustly, reset the SCS SP and KASAN\nshadow of a CPU's idle task immediately before we online that CPU in\nbringup_cpu(). This ensures the idle task always has a consistent state\nwhen it is running, and removes the need to so so when exiting an idle\ntask.\nWhenever any thread is created, dup_task_struct() will give the task a\nstack which is free of KASAN shadow, and initialize the task's SCS SP,\nso there's no need to specially initialize either for idle thread within\ninit_idle(), as this was only necessary to handle hotplug cycles.\nI've tested this on arm64 with:\n* gcc 11.1.0, defconfig +KASAN_INLINE, KASAN_STACK\n* clang 12.0.0, defconfig +KASAN_INLINE, KASAN_STACK, SHADOW_CALL_STACK\n... offlining and onlining CPUS with:\n| while true; do\n|   for C in /sys/devices/system/cpu/cpu*/online; do\n|     echo 0 > $C;\n|     echo 1 > $C;\n|   done\n| done",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/229c555260cb9c1ccdab861e16f0410f1718f302"
          },
          {
            "url": "https://git.kernel.org/stable/c/dce1ca0525bfdc8a69a9343bc714fbc19a2f04b3"
          },
          {
            "url": "https://git.kernel.org/stable/c/e6ee7abd6bfe559ad9989004b34c320fd638c526"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47554",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:20.160",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nvdpa_sim: avoid putting an uninitialized iova_domain\nThe system will crash if we put an uninitialized iova_domain, this\ncould happen when an error occurs before initializing the iova_domain\nin vdpasim_create().\nBUG: kernel NULL pointer dereference, address: 0000000000000000\n...\nRIP: 0010:__cpuhp_state_remove_instance+0x96/0x1c0\n...\nCall Trace:\n <TASK>\n put_iova_domain+0x29/0x220\n vdpasim_free+0xd1/0x120 [vdpa_sim]\n vdpa_release_dev+0x21/0x40 [vdpa]\n device_release+0x33/0x90\n kobject_release+0x63/0x160\n vdpasim_create+0x127/0x2a0 [vdpa_sim]\n vdpasim_net_dev_add+0x7d/0xfe [vdpa_sim_net]\n vdpa_nl_cmd_dev_add_set_doit+0xe1/0x1a0 [vdpa]\n genl_family_rcv_msg_doit+0x112/0x140\n genl_rcv_msg+0xdf/0x1d0\n ...\nSo we must make sure the iova_domain is already initialized before\nput it.\nIn addition, we may get the following warning in this case:\nWARNING: ... drivers/iommu/iova.c:344 iova_cache_put+0x58/0x70\nSo we must make sure the iova_cache_put() is invoked only if the\niova_cache_get() is already invoked. Let's fix it together.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/bb93ce4b150dde79f58e34103cbd1fe829796649"
          },
          {
            "url": "https://git.kernel.org/stable/c/e4d58ac67e63727aa45a4a26185876f598e8b3dd"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47555",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:20.237",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: vlan: fix underflow for the real_dev refcnt\nInject error before dev_hold(real_dev) in register_vlan_dev(),\nand execute the following testcase:\nip link add dev dummy1 type dummy\nip link add name dummy1.100 link dummy1 type vlan id 100\nip link del dev dummy1\nWhen the dummy netdevice is removed, we will get a WARNING as following:\n=======================================================================\nrefcount_t: decrement hit 0; leaking memory.\nWARNING: CPU: 2 PID: 0 at lib/refcount.c:31 refcount_warn_saturate+0xbf/0x1e0\nand an endless loop of:\n=======================================================================\nunregister_netdevice: waiting for dummy1 to become free. Usage count = -1073741824\nThat is because dev_put(real_dev) in vlan_dev_free() be called without\ndev_hold(real_dev) in register_vlan_dev(). It makes the refcnt of real_dev\nunderflow.\nMove the dev_hold(real_dev) to vlan_dev_init() which is the call-back of\nndo_init(). That makes dev_hold() and dev_put() for vlan's real_dev\nsymmetrical.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/01d9cc2dea3fde3bad6d27f464eff463496e2b00"
          },
          {
            "url": "https://git.kernel.org/stable/c/5e44178864b38dd70b877985abd7d86fdb95f27d"
          },
          {
            "url": "https://git.kernel.org/stable/c/6e800ee43218a56acc93676bbb3d93b74779e555"
          },
          {
            "url": "https://git.kernel.org/stable/c/f7fc72a508cf115c273a7a29350069def1041890"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47556",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:20.320",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nethtool: ioctl: fix potential NULL deref in ethtool_set_coalesce()\nethtool_set_coalesce() now uses both the .get_coalesce() and\n.set_coalesce() callbacks. But the check for their availability is\nbuggy, so changing the coalesce settings on a device where the driver\nprovides only _one_ of the callbacks results in a NULL pointer\ndereference instead of an -EOPNOTSUPP.\nFix the condition so that the availability of both callbacks is\nensured. This also matches the netlink code.\nNote that reproducing this requires some effort - it only affects the\nlegacy ioctl path, and needs a specific combination of driver options:\n- have .get_coalesce() and .coalesce_supported but no\n .set_coalesce(), or\n- have .set_coalesce() but no .get_coalesce(). Here eg. ethtool doesn't\n  cause the crash as it first attempts to call ethtool_get_coalesce()\n  and bails out on error.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0276af2176c78771da7f311621a25d7608045827"
          },
          {
            "url": "https://git.kernel.org/stable/c/abfdd9e2f0f9699015d72317f74154d3e53664e6"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47557",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:20.393",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/sched: sch_ets: don't peek at classes beyond 'nbands'\nwhen the number of DRR classes decreases, the round-robin active list can\ncontain elements that have already been freed in ets_qdisc_change(). As a\nconsequence, it's possible to see a NULL dereference crash, caused by the\nattempt to call cl->qdisc->ops->peek(cl->qdisc) when cl->qdisc is NULL:\n BUG: kernel NULL pointer dereference, address: 0000000000000018\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n PGD 0 P4D 0\n Oops: 0000 [#1] PREEMPT SMP NOPTI\n CPU: 1 PID: 910 Comm: mausezahn Not tainted 5.16.0-rc1+ #475\n Hardware name: Red Hat KVM, BIOS 1.11.1-4.module+el8.1.0+4066+0f1aadab 04/01/2014\n RIP: 0010:ets_qdisc_dequeue+0x129/0x2c0 [sch_ets]\n Code: c5 01 41 39 ad e4 02 00 00 0f 87 18 ff ff ff 49 8b 85 c0 02 00 00 49 39 c4 0f 84 ba 00 00 00 49 8b ad c0 02 00 00 48 8b 7d 10 <48> 8b 47 18 48 8b 40 38 0f ae e8 ff d0 48 89 c3 48 85 c0 0f 84 9d\n RSP: 0000:ffffbb36c0b5fdd8 EFLAGS: 00010287\n RAX: ffff956678efed30 RBX: 0000000000000000 RCX: 0000000000000000\n RDX: 0000000000000002 RSI: ffffffff9b938dc9 RDI: 0000000000000000\n RBP: ffff956678efed30 R08: e2f3207fe360129c R09: 0000000000000000\n R10: 0000000000000001 R11: 0000000000000001 R12: ffff956678efeac0\n R13: ffff956678efe800 R14: ffff956611545000 R15: ffff95667ac8f100\n FS:  00007f2aa9120740(0000) GS:ffff95667b800000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000000000018 CR3: 000000011070c000 CR4: 0000000000350ee0\n Call Trace:\n  <TASK>\n  qdisc_peek_dequeued+0x29/0x70 [sch_ets]\n  tbf_dequeue+0x22/0x260 [sch_tbf]\n  __qdisc_run+0x7f/0x630\n  net_tx_action+0x290/0x4c0\n  __do_softirq+0xee/0x4f8\n  irq_exit_rcu+0xf4/0x130\n  sysvec_apic_timer_interrupt+0x52/0xc0\n  asm_sysvec_apic_timer_interrupt+0x12/0x20\n RIP: 0033:0x7f2aa7fc9ad4\n Code: b9 ff ff 48 8b 54 24 18 48 83 c4 08 48 89 ee 48 89 df 5b 5d e9 ed fc ff ff 0f 1f 00 66 2e 0f 1f 84 00 00 00 00 00 f3 0f 1e fa <53> 48 83 ec 10 48 8b 05 10 64 33 00 48 8b 00 48 85 c0 0f 85 84 00\n RSP: 002b:00007ffe5d33fab8 EFLAGS: 00000202\n RAX: 0000000000000002 RBX: 0000561f72c31460 RCX: 0000561f72c31720\n RDX: 0000000000000002 RSI: 0000561f72c31722 RDI: 0000561f72c31720\n RBP: 000000000000002a R08: 00007ffe5d33fa40 R09: 0000000000000014\n R10: 0000000000000000 R11: 0000000000000246 R12: 0000561f7187e380\n R13: 0000000000000000 R14: 0000000000000000 R15: 0000561f72c31460\n  </TASK>\n Modules linked in: sch_ets sch_tbf dummy rfkill iTCO_wdt intel_rapl_msr iTCO_vendor_support intel_rapl_common joydev virtio_balloon lpc_ich i2c_i801 i2c_smbus pcspkr ip_tables xfs libcrc32c crct10dif_pclmul crc32_pclmul crc32c_intel ahci libahci ghash_clmulni_intel serio_raw libata virtio_blk virtio_console virtio_net net_failover failover sunrpc dm_mirror dm_region_hash dm_log dm_mod\n CR2: 0000000000000018\nEnsuring that 'alist' was never zeroed [1] was not sufficient, we need to\nremove from the active list those elements that are no more SP nor DRR.\n[1] https://lore.kernel.org/netdev/60d274838bf09777f0371253416e8af71360bc08.1633609148.git.dcaratti@redhat.com/\nv3: fix race between ets_qdisc_change() and ets_qdisc_dequeue() delisting\n    DRR classes beyond 'nbands' in ets_qdisc_change() with the qdisc lock\n    acquired, thanks to Cong Wang.\nv2: when a NULL qdisc is found in the DRR active list, try to dequeue skb\n    from the next list item.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/ae2659d2c670252759ee9c823c4e039c0e05a6f2"
          },
          {
            "url": "https://git.kernel.org/stable/c/de6d25924c2a8c2988c6a385990cafbe742061bf"
          },
          {
            "url": "https://git.kernel.org/stable/c/e25bdbc7e951ae5728fee1f4c09485df113d013c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47558",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:20.467",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: stmmac: Disable Tx queues when reconfiguring the interface\nThe Tx queues were not disabled in situations where the driver needed to\nstop the interface to apply a new configuration. This could result in a\nkernel panic when doing any of the 3 following actions:\n* reconfiguring the number of queues (ethtool -L)\n* reconfiguring the size of the ring buffers (ethtool -G)\n* installing/removing an XDP program (ip l set dev ethX xdp)\nPrevent the panic by making sure netif_tx_disable is called when stopping\nan interface.\nWithout this patch, the following kernel panic can be observed when doing\nany of the actions above:\nUnable to handle kernel paging request at virtual address ffff80001238d040\n[....]\n Call trace:\n  dwmac4_set_addr+0x8/0x10\n  dev_hard_start_xmit+0xe4/0x1ac\n  sch_direct_xmit+0xe8/0x39c\n  __dev_queue_xmit+0x3ec/0xaf0\n  dev_queue_xmit+0x14/0x20\n[...]\n[ end trace 0000000000000002 ]---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/a92f0eebb8dc008b9e8c51c6f7b8c93b27a29a43"
          },
          {
            "url": "https://git.kernel.org/stable/c/b270bfe697367776eca2e6759a71d700fb8d82a2"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47559",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:20.537",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/smc: Fix NULL pointer dereferencing in smc_vlan_by_tcpsk()\nCoverity reports a possible NULL dereferencing problem:\nin smc_vlan_by_tcpsk():\n6. returned_null: netdev_lower_get_next returns NULL (checked 29 out of 30 times).\n7. var_assigned: Assigning: ndev = NULL return value from netdev_lower_get_next.\n1623                ndev = (struct net_device *)netdev_lower_get_next(ndev, &lower);\nCID 1468509 (#1 of 1): Dereference null return value (NULL_RETURNS)\n8. dereference: Dereferencing a pointer that might be NULL ndev when calling is_vlan_dev.\n1624                if (is_vlan_dev(ndev)) {\nRemove the manual implementation and use netdev_walk_all_lower_dev() to\niterate over the lower devices. While on it remove an obsolete function\nparameter comment.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/587acad41f1bc48e16f42bb2aca63bf323380be8"
          },
          {
            "url": "https://git.kernel.org/stable/c/bb851d0fb02547d03cd40106b5f2391c4fed6ed1"
          },
          {
            "url": "https://git.kernel.org/stable/c/c94cbd262b6aa3b54d73a1ed1f9c0d19df57f4ff"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47560",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:20.613",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmlxsw: spectrum: Protect driver from buggy firmware\nWhen processing port up/down events generated by the device's firmware,\nthe driver protects itself from events reported for non-existent local\nports, but not the CPU port (local port 0), which exists, but lacks a\nnetdev.\nThis can result in a NULL pointer dereference when calling\nnetif_carrier_{on,off}().\nFix this by bailing early when processing an event reported for the CPU\nport. Problem was only observed when running on top of a buggy emulator.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/63b08b1f6834bbb0b4f7783bf63b80c8c8e9a047"
          },
          {
            "url": "https://git.kernel.org/stable/c/90d0736876c50ecde1a3275636a06b9ddb1cace9"
          },
          {
            "url": "https://git.kernel.org/stable/c/da4d70199e5d82da664a80077508d6c18f5e76df"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47561",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:20.690",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ni2c: virtio: disable timeout handling\nIf a timeout is hit, it can result is incorrect data on the I2C bus\nand/or memory corruptions in the guest since the device can still be\noperating on the buffers it was given while the guest has freed them.\nHere is, for example, the start of a slub_debug splat which was\ntriggered on the next transfer after one transfer was forced to timeout\nby setting a breakpoint in the backend (rust-vmm/vhost-device):\n BUG kmalloc-1k (Not tainted): Poison overwritten\n First byte 0x1 instead of 0x6b\n Allocated in virtio_i2c_xfer+0x65/0x35c age=350 cpu=0 pid=29\n \t__kmalloc+0xc2/0x1c9\n \tvirtio_i2c_xfer+0x65/0x35c\n \t__i2c_transfer+0x429/0x57d\n \ti2c_transfer+0x115/0x134\n \ti2cdev_ioctl_rdwr+0x16a/0x1de\n \ti2cdev_ioctl+0x247/0x2ed\n \tvfs_ioctl+0x21/0x30\n \tsys_ioctl+0xb18/0xb41\n Freed in virtio_i2c_xfer+0x32e/0x35c age=244 cpu=0 pid=29\n \tkfree+0x1bd/0x1cc\n \tvirtio_i2c_xfer+0x32e/0x35c\n \t__i2c_transfer+0x429/0x57d\n \ti2c_transfer+0x115/0x134\n \ti2cdev_ioctl_rdwr+0x16a/0x1de\n \ti2cdev_ioctl+0x247/0x2ed\n \tvfs_ioctl+0x21/0x30\n \tsys_ioctl+0xb18/0xb41\nThere is no simple fix for this (the driver would have to always create\nbounce buffers and hold on to them until the device eventually returns\nthe buffers), so just disable the timeout support for now.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/84e1d0bf1d7121759622dabf8fbef4c99ad597c5"
          },
          {
            "url": "https://git.kernel.org/stable/c/cc432b0727ce404cc13e8f6b5ce29f412c3f9f1f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47562",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:20.797",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nice: fix vsi->txq_map sizing\nThe approach of having XDP queue per CPU regardless of user's setting\nexposed a hidden bug that could occur in case when Rx queue count differ\nfrom Tx queue count. Currently vsi->txq_map's size is equal to the\ndoubled vsi->alloc_txq, which is not correct due to the fact that XDP\nrings were previously based on the Rx queue count. Below splat can be\nseen when ethtool -L is used and XDP rings are configured:\n[  682.875339] BUG: kernel NULL pointer dereference, address: 000000000000000f\n[  682.883403] #PF: supervisor read access in kernel mode\n[  682.889345] #PF: error_code(0x0000) - not-present page\n[  682.895289] PGD 0 P4D 0\n[  682.898218] Oops: 0000 [#1] PREEMPT SMP PTI\n[  682.903055] CPU: 42 PID: 2878 Comm: ethtool Tainted: G           OE     5.15.0-rc5+ #1\n[  682.912214] Hardware name: Intel Corp. GRANTLEY/GRANTLEY, BIOS GRRFCRB1.86B.0276.D07.1605190235 05/19/2016\n[  682.923380] RIP: 0010:devres_remove+0x44/0x130\n[  682.928527] Code: 49 89 f4 55 48 89 fd 4c 89 ff 53 48 83 ec 10 e8 92 b9 49 00 48 8b 9d a8 02 00 00 48 8d 8d a0 02 00 00 49 89 c2 48 39 cb 74 0f <4c> 3b 63 10 74 25 48 8b 5b 08 48 39 cb 75 f1 4c 89 ff 4c 89 d6 e8\n[  682.950237] RSP: 0018:ffffc90006a679f0 EFLAGS: 00010002\n[  682.956285] RAX: 0000000000000286 RBX: ffffffffffffffff RCX: ffff88908343a370\n[  682.964538] RDX: 0000000000000001 RSI: ffffffff81690d60 RDI: 0000000000000000\n[  682.972789] RBP: ffff88908343a0d0 R08: 0000000000000000 R09: 0000000000000000\n[  682.981040] R10: 0000000000000286 R11: 3fffffffffffffff R12: ffffffff81690d60\n[  682.989282] R13: ffffffff81690a00 R14: ffff8890819807a8 R15: ffff88908343a36c\n[  682.997535] FS:  00007f08c7bfa740(0000) GS:ffff88a03fd00000(0000) knlGS:0000000000000000\n[  683.006910] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  683.013557] CR2: 000000000000000f CR3: 0000001080a66003 CR4: 00000000003706e0\n[  683.021819] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  683.030075] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  683.038336] Call Trace:\n[  683.041167]  devm_kfree+0x33/0x50\n[  683.045004]  ice_vsi_free_arrays+0x5e/0xc0 [ice]\n[  683.050380]  ice_vsi_rebuild+0x4c8/0x750 [ice]\n[  683.055543]  ice_vsi_recfg_qs+0x9a/0x110 [ice]\n[  683.060697]  ice_set_channels+0x14f/0x290 [ice]\n[  683.065962]  ethnl_set_channels+0x333/0x3f0\n[  683.070807]  genl_family_rcv_msg_doit+0xea/0x150\n[  683.076152]  genl_rcv_msg+0xde/0x1d0\n[  683.080289]  ? channels_prepare_data+0x60/0x60\n[  683.085432]  ? genl_get_cmd+0xd0/0xd0\n[  683.089667]  netlink_rcv_skb+0x50/0xf0\n[  683.094006]  genl_rcv+0x24/0x40\n[  683.097638]  netlink_unicast+0x239/0x340\n[  683.102177]  netlink_sendmsg+0x22e/0x470\n[  683.106717]  sock_sendmsg+0x5e/0x60\n[  683.110756]  __sys_sendto+0xee/0x150\n[  683.114894]  ? handle_mm_fault+0xd0/0x2a0\n[  683.119535]  ? do_user_addr_fault+0x1f3/0x690\n[  683.134173]  __x64_sys_sendto+0x25/0x30\n[  683.148231]  do_syscall_64+0x3b/0xc0\n[  683.161992]  entry_SYSCALL_64_after_hwframe+0x44/0xae\nFix this by taking into account the value that num_possible_cpus()\nyields in addition to vsi->alloc_txq instead of doubling the latter.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1eb5395add786613c7c5579d3947aa0b8f0ec241"
          },
          {
            "url": "https://git.kernel.org/stable/c/792b2086584f25d84081a526beee80d103c2a913"
          },
          {
            "url": "https://git.kernel.org/stable/c/992ba40a67638dfe2772b84dfc8168dc328d5c4c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47563",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:21.033",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nice: avoid bpf_prog refcount underflow\nIce driver has the routines for managing XDP resources that are shared\nbetween ndo_bpf op and VSI rebuild flow. The latter takes place for\nexample when user changes queue count on an interface via ethtool's\nset_channels().\nThere is an issue around the bpf_prog refcounting when VSI is being\nrebuilt - since ice_prepare_xdp_rings() is called with vsi->xdp_prog as\nan argument that is used later on by ice_vsi_assign_bpf_prog(), same\nbpf_prog pointers are swapped with each other. Then it is also\ninterpreted as an 'old_prog' which in turn causes us to call\nbpf_prog_put on it that will decrement its refcount.\nBelow splat can be interpreted in a way that due to zero refcount of a\nbpf_prog it is wiped out from the system while kernel still tries to\nrefer to it:\n[  481.069429] BUG: unable to handle page fault for address: ffffc9000640f038\n[  481.077390] #PF: supervisor read access in kernel mode\n[  481.083335] #PF: error_code(0x0000) - not-present page\n[  481.089276] PGD 100000067 P4D 100000067 PUD 1001cb067 PMD 106d2b067 PTE 0\n[  481.097141] Oops: 0000 [#1] PREEMPT SMP PTI\n[  481.101980] CPU: 12 PID: 3339 Comm: sudo Tainted: G           OE     5.15.0-rc5+ #1\n[  481.110840] Hardware name: Intel Corp. GRANTLEY/GRANTLEY, BIOS GRRFCRB1.86B.0276.D07.1605190235 05/19/2016\n[  481.122021] RIP: 0010:dev_xdp_prog_id+0x25/0x40\n[  481.127265] Code: 80 00 00 00 00 0f 1f 44 00 00 89 f6 48 c1 e6 04 48 01 fe 48 8b 86 98 08 00 00 48 85 c0 74 13 48 8b 50 18 31 c0 48 85 d2 74 07 <48> 8b 42 38 8b 40 20 c3 48 8b 96 90 08 00 00 eb e8 66 2e 0f 1f 84\n[  481.148991] RSP: 0018:ffffc90007b63868 EFLAGS: 00010286\n[  481.155034] RAX: 0000000000000000 RBX: ffff889080824000 RCX: 0000000000000000\n[  481.163278] RDX: ffffc9000640f000 RSI: ffff889080824010 RDI: ffff889080824000\n[  481.171527] RBP: ffff888107af7d00 R08: 0000000000000000 R09: ffff88810db5f6e0\n[  481.179776] R10: 0000000000000000 R11: ffff8890885b9988 R12: ffff88810db5f4bc\n[  481.188026] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\n[  481.196276] FS:  00007f5466d5bec0(0000) GS:ffff88903fb00000(0000) knlGS:0000000000000000\n[  481.205633] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  481.212279] CR2: ffffc9000640f038 CR3: 000000014429c006 CR4: 00000000003706e0\n[  481.220530] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  481.228771] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  481.237029] Call Trace:\n[  481.239856]  rtnl_fill_ifinfo+0x768/0x12e0\n[  481.244602]  rtnl_dump_ifinfo+0x525/0x650\n[  481.249246]  ? __alloc_skb+0xa5/0x280\n[  481.253484]  netlink_dump+0x168/0x3c0\n[  481.257725]  netlink_recvmsg+0x21e/0x3e0\n[  481.262263]  ____sys_recvmsg+0x87/0x170\n[  481.266707]  ? __might_fault+0x20/0x30\n[  481.271046]  ? _copy_from_user+0x66/0xa0\n[  481.275591]  ? iovec_from_user+0xf6/0x1c0\n[  481.280226]  ___sys_recvmsg+0x82/0x100\n[  481.284566]  ? sock_sendmsg+0x5e/0x60\n[  481.288791]  ? __sys_sendto+0xee/0x150\n[  481.293129]  __sys_recvmsg+0x56/0xa0\n[  481.297267]  do_syscall_64+0x3b/0xc0\n[  481.301395]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[  481.307238] RIP: 0033:0x7f5466f39617\n[  481.311373] Code: 0c 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb bd 0f 1f 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 2f 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 51 c3 48 83 ec 28 89 54 24 1c 48 89 74 24 10\n[  481.342944] RSP: 002b:00007ffedc7f4308 EFLAGS: 00000246 ORIG_RAX: 000000000000002f\n[  481.361783] RAX: ffffffffffffffda RBX: 00007ffedc7f5460 RCX: 00007f5466f39617\n[  481.380278] RDX: 0000000000000000 RSI: 00007ffedc7f5360 RDI: 0000000000000003\n[  481.398500] RBP: 00007ffedc7f53f0 R08: 0000000000000000 R09: 000055d556f04d50\n[  481.416463] R10: 0000000000000077 R11: 0000000000000246 R12: 00007ffedc7f5360\n[  481.434131] R13: 00007ffedc7f5350 R14: 00007ffedc7f5344 R15: 0000000000000e98\n[  481.451520] Modules linked in: ice\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1f10b09ccc832698ef4624a6ab9a213b6ccbda76"
          },
          {
            "url": "https://git.kernel.org/stable/c/e65a8707b4cd756d26d246bb2b9fab06eebafac1"
          },
          {
            "url": "https://git.kernel.org/stable/c/f65ee535df775a13a1046c0a0b2d72db342f8a5b"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47564",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:21.263",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: marvell: prestera: fix double free issue on err path\nfix error path handling in prestera_bridge_port_join() that\ncases prestera driver to crash (see below).\n Trace:\n   Internal error: Oops: 96000044 [#1] SMP\n   Modules linked in: prestera_pci prestera uio_pdrv_genirq\n   CPU: 1 PID: 881 Comm: ip Not tainted 5.15.0 #1\n   pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n   pc : prestera_bridge_destroy+0x2c/0xb0 [prestera]\n   lr : prestera_bridge_port_join+0x2cc/0x350 [prestera]\n   sp : ffff800011a1b0f0\n   ...\n   x2 : ffff000109ca6c80 x1 : dead000000000100 x0 : dead000000000122\n    Call trace:\n   prestera_bridge_destroy+0x2c/0xb0 [prestera]\n   prestera_bridge_port_join+0x2cc/0x350 [prestera]\n   prestera_netdev_port_event.constprop.0+0x3c4/0x450 [prestera]\n   prestera_netdev_event_handler+0xf4/0x110 [prestera]\n   raw_notifier_call_chain+0x54/0x80\n   call_netdevice_notifiers_info+0x54/0xa0\n   __netdev_upper_dev_link+0x19c/0x380",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/03e5203d2161a00afe4d97d206d2293e40b2f253"
          },
          {
            "url": "https://git.kernel.org/stable/c/5dca8eff4627315df98feec09fff9dfe3356325e"
          },
          {
            "url": "https://git.kernel.org/stable/c/e8d032507cb7912baf1d3e0af54516f823befefd"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47565",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:21.443",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nscsi: mpt3sas: Fix kernel panic during drive powercycle test\nWhile looping over shost's sdev list it is possible that one\nof the drives is getting removed and its sas_target object is\nfreed but its sdev object remains intact.\nConsequently, a kernel panic can occur while the driver is trying to access\nthe sas_address field of sas_target object without also checking the\nsas_target object for NULL.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0d4b29eaadc1f59cec0c7e85eae77d08fcca9824"
          },
          {
            "url": "https://git.kernel.org/stable/c/0ee4ba13e09c9d9c1cb6abb59da8295d9952328b"
          },
          {
            "url": "https://git.kernel.org/stable/c/2bf9c5a5039c8f4b037236aed505e6a25c1d5f7b"
          },
          {
            "url": "https://git.kernel.org/stable/c/58ef2c7a6de13721865d84b80eecf56d6cba0937"
          },
          {
            "url": "https://git.kernel.org/stable/c/5d4d50b1f159a5ebab7617f47121b4370aa58afe"
          },
          {
            "url": "https://git.kernel.org/stable/c/7e324f734a914957b8cc3ff4b4c9f0409558adb5"
          },
          {
            "url": "https://git.kernel.org/stable/c/8485649a7655e791a6e4e9f15b4d30fdae937184"
          },
          {
            "url": "https://git.kernel.org/stable/c/dd035ca0e7a142870a970d46b1d19276cfe2bc8c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47566",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:21.637",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nproc/vmcore: fix clearing user buffer by properly using clear_user()\nTo clear a user buffer we cannot simply use memset, we have to use\nclear_user().  With a virtio-mem device that registers a vmcore_cb and\nhas some logically unplugged memory inside an added Linux memory block,\nI can easily trigger a BUG by copying the vmcore via \"cp\":\n  systemd[1]: Starting Kdump Vmcore Save Service...\n  kdump[420]: Kdump is using the default log level(3).\n  kdump[453]: saving to /sysroot/var/crash/127.0.0.1-2021-11-11-14:59:22/\n  kdump[458]: saving vmcore-dmesg.txt to /sysroot/var/crash/127.0.0.1-2021-11-11-14:59:22/\n  kdump[465]: saving vmcore-dmesg.txt complete\n  kdump[467]: saving vmcore\n  BUG: unable to handle page fault for address: 00007f2374e01000\n  #PF: supervisor write access in kernel mode\n  #PF: error_code(0x0003) - permissions violation\n  PGD 7a523067 P4D 7a523067 PUD 7a528067 PMD 7a525067 PTE 800000007048f867\n  Oops: 0003 [#1] PREEMPT SMP NOPTI\n  CPU: 0 PID: 468 Comm: cp Not tainted 5.15.0+ #6\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.14.0-27-g64f37cc530f1-prebuilt.qemu.org 04/01/2014\n  RIP: 0010:read_from_oldmem.part.0.cold+0x1d/0x86\n  Code: ff ff ff e8 05 ff fe ff e9 b9 e9 7f ff 48 89 de 48 c7 c7 38 3b 60 82 e8 f1 fe fe ff 83 fd 08 72 3c 49 8d 7d 08 4c 89 e9 89 e8 <49> c7 45 00 00 00 00 00 49 c7 44 05 f8 00 00 00 00 48 83 e7 f81\n  RSP: 0018:ffffc9000073be08 EFLAGS: 00010212\n  RAX: 0000000000001000 RBX: 00000000002fd000 RCX: 00007f2374e01000\n  RDX: 0000000000000001 RSI: 00000000ffffdfff RDI: 00007f2374e01008\n  RBP: 0000000000001000 R08: 0000000000000000 R09: ffffc9000073bc50\n  R10: ffffc9000073bc48 R11: ffffffff829461a8 R12: 000000000000f000\n  R13: 00007f2374e01000 R14: 0000000000000000 R15: ffff88807bd421e8\n  FS:  00007f2374e12140(0000) GS:ffff88807f000000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00007f2374e01000 CR3: 000000007a4aa000 CR4: 0000000000350eb0\n  Call Trace:\n   read_vmcore+0x236/0x2c0\n   proc_reg_read+0x55/0xa0\n   vfs_read+0x95/0x190\n   ksys_read+0x4f/0xc0\n   do_syscall_64+0x3b/0x90\n   entry_SYSCALL_64_after_hwframe+0x44/0xae\nSome x86-64 CPUs have a CPU feature called \"Supervisor Mode Access\nPrevention (SMAP)\", which is used to detect wrong access from the kernel\nto user buffers like this: SMAP triggers a permissions violation on\nwrong access.  In the x86-64 variant of clear_user(), SMAP is properly\nhandled via clac()+stac().\nTo fix, properly use clear_user() when we're dealing with a user buffer.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/33a7d698f30fa0b99d50569e9909d3baa65d8f6a"
          },
          {
            "url": "https://git.kernel.org/stable/c/7b3a34f08d11e7f05cd00b8e09adaa15192f0ad1"
          },
          {
            "url": "https://git.kernel.org/stable/c/99d348b82bcb36171f24411d3f1a15706a2a937a"
          },
          {
            "url": "https://git.kernel.org/stable/c/9ef384ed300d1bcfb23d0ab0b487d544444d4b52"
          },
          {
            "url": "https://git.kernel.org/stable/c/a8a917058faf4abaec9fb614bb6d5f8fe3529ec6"
          },
          {
            "url": "https://git.kernel.org/stable/c/a9e164bd160be8cbee1df70acb379129e3cd2e7c"
          },
          {
            "url": "https://git.kernel.org/stable/c/c1e63117711977cc4295b2ce73de29dd17066c82"
          },
          {
            "url": "https://git.kernel.org/stable/c/fd7974c547abfb03072a4ee706d3a6f182266f89"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47567",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:21.837",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\npowerpc/32: Fix hardlockup on vmap stack overflow\nSince the commit c118c7303ad5 (\"powerpc/32: Fix vmap stack - Do not\nactivate MMU before reading task struct\") a vmap stack overflow\nresults in a hard lockup. This is because emergency_ctx is still\naddressed with its virtual address allthough data MMU is not active\nanymore at that time.\nFix it by using a physical address instead.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/5bb60ea611db1e04814426ed4bd1c95d1487678e"
          },
          {
            "url": "https://git.kernel.org/stable/c/c4e3ff8b8b1d54f0c755670174c453b06e17114b"
          },
          {
            "url": "https://git.kernel.org/stable/c/dfe906da9a1abebdebe8b15bb3e66a2578f6c4c7"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47568",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:22.007",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nksmbd: fix memleak in get_file_stream_info()\nFix memleak in get_file_stream_info()",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/11e659827c3a2facb3a04e08cc97ff14d5091f51"
          },
          {
            "url": "https://git.kernel.org/stable/c/178ca6f85aa3231094467691f5ea1ff2f398aa8d"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47569",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:22.203",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nio_uring: fail cancellation for EXITING tasks\nWARNING: CPU: 1 PID: 20 at fs/io_uring.c:6269 io_try_cancel_userdata+0x3c5/0x640 fs/io_uring.c:6269\nCPU: 1 PID: 20 Comm: kworker/1:0 Not tainted 5.16.0-rc1-syzkaller #0\nWorkqueue: events io_fallback_req_func\nRIP: 0010:io_try_cancel_userdata+0x3c5/0x640 fs/io_uring.c:6269\nCall Trace:\n <TASK>\n io_req_task_link_timeout+0x6b/0x1e0 fs/io_uring.c:6886\n io_fallback_req_func+0xf9/0x1ae fs/io_uring.c:1334\n process_one_work+0x9b2/0x1690 kernel/workqueue.c:2298\n worker_thread+0x658/0x11f0 kernel/workqueue.c:2445\n kthread+0x405/0x4f0 kernel/kthread.c:327\n ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:295\n </TASK>\nWe need original task's context to do cancellations, so if it's dying\nand the callback is executed in a fallback mode, fail the cancellation\nattempt.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3d2a1e68fd9904fdc1b02f2e7d40ca47df7ba39f"
          },
          {
            "url": "https://git.kernel.org/stable/c/617a89484debcd4e7999796d693cf0b77d2519de"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47570",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:22.410",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nstaging: r8188eu: fix a memory leak in rtw_wx_read32()\nFree \"ptmp\" before returning -EINVAL.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/be4ea8f383551b9dae11b8dfff1f38b3b5436e9a"
          },
          {
            "url": "https://git.kernel.org/stable/c/c8d3775745adacf9784a7a80a82d047051752573"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47571",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:22.607",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nstaging: rtl8192e: Fix use after free in _rtl92e_pci_disconnect()\nThe free_rtllib() function frees the \"dev\" pointer so there is use\nafter free on the next line.  Re-arrange things to avoid that.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2e1ec01af2c7139c6a600bbfaea1a018b35094b6"
          },
          {
            "url": "https://git.kernel.org/stable/c/8d0163cec7de995f9eb9c3128c83fb84f0cb1c64"
          },
          {
            "url": "https://git.kernel.org/stable/c/9186680382934b0e7529d3d70dcc0a21d087683b"
          },
          {
            "url": "https://git.kernel.org/stable/c/b535917c51acc97fb0761b1edec85f1f3d02bda4"
          },
          {
            "url": "https://git.kernel.org/stable/c/bca19bb2dc2d89ce60c4a4a6e59609d4cf2e13ef"
          },
          {
            "url": "https://git.kernel.org/stable/c/c0ef0e75a858cbd8618b473f22fbca36106dcf82"
          },
          {
            "url": "https://git.kernel.org/stable/c/d43aecb694b10db9a4228ce2d38b5ae8de374443"
          },
          {
            "url": "https://git.kernel.org/stable/c/e27ee2f607fe6a9b923ef1fc65461c0613c97594"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47572",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-24T15:15:22.887",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: nexthop: fix null pointer dereference when IPv6 is not enabled\nWhen we try to add an IPv6 nexthop and IPv6 is not enabled\n(!CONFIG_IPV6) we'll hit a NULL pointer dereference[1] in the error path\nof nh_create_ipv6() due to calling ipv6_stub->fib6_nh_release. The bug\nhas been present since the beginning of IPv6 nexthop gateway support.\nCommit 1aefd3de7bc6 (\"ipv6: Add fib6_nh_init and release to stubs\") tells\nus that only fib6_nh_init has a dummy stub because fib6_nh_release should\nnot be called if fib6_nh_init returns an error, but the commit below added\na call to ipv6_stub->fib6_nh_release in its error path. To fix it return\nthe dummy stub's -EAFNOSUPPORT error directly without calling\nipv6_stub->fib6_nh_release in nh_create_ipv6()'s error path.\n[1]\n Output is a bit truncated, but it clearly shows the error.\n BUG: kernel NULL pointer dereference, address: 000000000000000000\n #PF: supervisor instruction fetch in kernel modede\n #PF: error_code(0x0010) - not-present pagege\n PGD 0 P4D 0\n Oops: 0010 [#1] PREEMPT SMP NOPTI\n CPU: 4 PID: 638 Comm: ip Kdump: loaded Not tainted 5.16.0-rc1+ #446\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-4.fc34 04/01/2014\n RIP: 0010:0x0\n Code: Unable to access opcode bytes at RIP 0xffffffffffffffd6.\n RSP: 0018:ffff888109f5b8f0 EFLAGS: 00010286^Ac\n RAX: 0000000000000000 RBX: ffff888109f5ba28 RCX: 0000000000000000\n RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff8881008a2860\n RBP: ffff888109f5b9d8 R08: 0000000000000000 R09: 0000000000000000\n R10: ffff888109f5b978 R11: ffff888109f5b948 R12: 00000000ffffff9f\n R13: ffff8881008a2a80 R14: ffff8881008a2860 R15: ffff8881008a2840\n FS:  00007f98de70f100(0000) GS:ffff88822bf00000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: ffffffffffffffd6 CR3: 0000000100efc000 CR4: 00000000000006e0\n Call Trace:\n  <TASK>\n  nh_create_ipv6+0xed/0x10c\n  rtm_new_nexthop+0x6d7/0x13f3\n  ? check_preemption_disabled+0x3d/0xf2\n  ? lock_is_held_type+0xbe/0xfd\n  rtnetlink_rcv_msg+0x23f/0x26a\n  ? check_preemption_disabled+0x3d/0xf2\n  ? rtnl_calcit.isra.0+0x147/0x147\n  netlink_rcv_skb+0x61/0xb2\n  netlink_unicast+0x100/0x187\n  netlink_sendmsg+0x37f/0x3a0\n  ? netlink_unicast+0x187/0x187\n  sock_sendmsg_nosec+0x67/0x9b\n  ____sys_sendmsg+0x19d/0x1f9\n  ? copy_msghdr_from_user+0x4c/0x5e\n  ? rcu_read_lock_any_held+0x2a/0x78\n  ___sys_sendmsg+0x6c/0x8c\n  ? asm_sysvec_apic_timer_interrupt+0x12/0x20\n  ? lockdep_hardirqs_on+0xd9/0x102\n  ? sockfd_lookup_light+0x69/0x99\n  __sys_sendmsg+0x50/0x6e\n  do_syscall_64+0xcb/0xf2\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\n RIP: 0033:0x7f98dea28914\n Code: 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b5 0f 1f 80 00 00 00 00 48 8d 05 e9 5d 0c 00 8b 00 85 c0 75 13 b8 2e 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 54 c3 0f 1f 00 41 54 41 89 d4 55 48 89 f5 53\n RSP: 002b:00007fff859f5e68 EFLAGS: 00000246 ORIG_RAX: 000000000000002e2e\n RAX: ffffffffffffffda RBX: 00000000619cb810 RCX: 00007f98dea28914\n RDX: 0000000000000000 RSI: 00007fff859f5ed0 RDI: 0000000000000003\n RBP: 0000000000000000 R08: 0000000000000001 R09: 0000000000000008\n R10: fffffffffffffce6 R11: 0000000000000246 R12: 0000000000000001\n R13: 000055c0097ae520 R14: 000055c0097957fd R15: 00007fff859f63a0\n </TASK>\n Modules linked in: bridge stp llc bonding virtio_net",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1c743127cc54b112b155f434756bd4b5fa565a99"
          },
          {
            "url": "https://git.kernel.org/stable/c/39509d76a9a3d02f379d52cb4b1449469c56c0e0"
          },
          {
            "url": "https://git.kernel.org/stable/c/7b6f44856da5ba0b1aa61403eb9fddd272156503"
          },
          {
            "url": "https://git.kernel.org/stable/c/b70ff391deeec35cdd8a05f5f63f5fe28bc4f225"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-22588",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-05-24T15:15:23.377",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "Kwik commit 745fd4e2 does not discard unused encryption keys.",
        "cweIds": null,
        "references": [
          {
            "url": "https://gist.github.com/QUICTester/29a1851c2b2a406411f688735526fe2e"
          },
          {
            "url": "https://github.com/ptrd/kwik/issues/31"
          },
          {
            "url": "https://www.rfc-editor.org/rfc/rfc9001#name-discarding-unused-keys"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-31510",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-05-24T15:15:23.587",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "An issue in Open Quantum Safe liboqs v.10.0 allows a remote attacker to escalate privileges via the crypto_sign_signature parameter in the /pqcrystals-dilithium-standard_ml-dsa-44-ipd_avx2/sign.c component.",
        "cweIds": null,
        "references": [
          {
            "url": "https://gist.github.com/liang-junkai/a9fc693f8bdf176e9d9f56773bf20703"
          },
          {
            "url": "https://github.com/liang-junkai/Fault-injection-of-ML-DSA"
          },
          {
            "url": "https://github.com/open-quantum-safe/liboqs"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-33470",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-05-24T15:15:23.807",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "An issue in the SMTP Email Settings of AVTECH Room Alert 4E v4.4.0 allows attackers to gain access to credentials in plaintext via a passback attack. NOTE: This vulnerability only affects products that are no longer supported by the maintainer.",
        "cweIds": null,
        "references": [
          {
            "url": "https://avtech.com/articles/27443/security-advisory-smtp-password-disclosure-in-dom/"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-33809",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-05-24T15:15:24.040",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "PingCAP TiDB v7.5.1 was discovered to contain a buffer overflow vulnerability, which could lead to database crashes and denial of service attacks.",
        "cweIds": null,
        "references": [
          {
            "url": "https://gist.github.com/GaranR/f17b53fe3dd0a834c3acd288ed19b622"
          },
          {
            "url": "https://github.com/pingcap/tidb/issues/52159"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35339",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-05-24T15:15:24.260",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "Tenda FH1206 V1.2.0.8(8155) was discovered to contain a command injection vulnerability via the mac parameter at ip/goform/WriteFacMac.",
        "cweIds": null,
        "references": [
          {
            "url": "https://palm-vertebra-fe9.notion.site/formWriteFacMac_RCE-d70cf636739e4a769b1f919ffed4a2a0"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35340",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-05-24T15:15:24.467",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "Tenda FH1206 V1.2.0.8(8155) was discovered to contain a command injection vulnerability via the cmdinput parameter at ip/goform/formexeCommand.",
        "cweIds": null,
        "references": [
          {
            "url": "https://palm-vertebra-fe9.notion.site/formexeCommand_RCE-91a5f12ae23a42b4a25f5d1d4de308da"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35618",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-05-24T15:15:24.670",
        "lastModified": "2024-05-24T18:09:20.027",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "PingCAP TiDB v7.5.1 was discovered to contain a NULL pointer dereference via the component SortedRowContainer.",
        "cweIds": null,
        "references": [
          {
            "url": "https://gist.github.com/GaranR/0b75c6f2c0215db39c910022daf6522c"
          },
          {
            "url": "https://github.com/pingcap/tidb/issues/52768"
          }
        ]
      }
    }
  ]
}