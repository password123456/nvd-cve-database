{
  "totalResults": 30,
  "datePublished": "2024-05-19T21:00:11.025805Z",
  "vulnerabilities": [
    {
      "cve": {
        "id": "CVE-2023-52699",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:47.507",
        "lastModified": "2024-05-19T11:15:47.507",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nsysv: don't call sb_bread() with pointers_lock held\nsyzbot is reporting sleep in atomic context in SysV filesystem [1], for\nsb_bread() is called with rw_spinlock held.\nA \"write_lock(&pointers_lock) => read_lock(&pointers_lock) deadlock\" bug\nand a \"sb_bread() with write_lock(&pointers_lock)\" bug were introduced by\n\"Replace BKL for chain locking with sysvfs-private rwlock\" in Linux 2.5.12.\nThen, \"[PATCH] err1-40: sysvfs locking fix\" in Linux 2.6.8 fixed the\nformer bug by moving pointers_lock lock to the callers, but instead\nintroduced a \"sb_bread() with read_lock(&pointers_lock)\" bug (which made\nthis problem easier to hit).\nAl Viro suggested that why not to do like get_branch()/get_block()/\nfind_shared() in Minix filesystem does. And doing like that is almost a\nrevert of \"[PATCH] err1-40: sysvfs locking fix\" except that get_branch()\n from with find_shared() is called without write_lock(&pointers_lock).",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/13b33feb2ebddc2b1aa607f553566b18a4af1d76"
          },
          {
            "url": "https://git.kernel.org/stable/c/1b4fe801b5bedec2b622ddb18e5c9bf26c63d79f"
          },
          {
            "url": "https://git.kernel.org/stable/c/53cb1e52c9db618c08335984d1ca80db220ccf09"
          },
          {
            "url": "https://git.kernel.org/stable/c/674c1c4229e743070e09db63a23442950ff000d1"
          },
          {
            "url": "https://git.kernel.org/stable/c/89e8524135a3902e7563a5a59b7b5ec1bf4904ac"
          },
          {
            "url": "https://git.kernel.org/stable/c/a69224223746ab96d43e5db9d22d136827b7e2d3"
          },
          {
            "url": "https://git.kernel.org/stable/c/f123dc86388cb669c3d6322702dc441abc35c31e"
          },
          {
            "url": "https://git.kernel.org/stable/c/fd203d2c671bdee9ab77090ff394d3b71b627927"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35918",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:48.223",
        "lastModified": "2024-05-19T11:15:48.223",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nrandomize_kstack: Improve entropy diffusion\nThe kstack_offset variable was really only ever using the low bits for\nkernel stack offset entropy. Add a ror32() to increase bit diffusion.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/300a2b9c2b28282974ee300bb5d5025cbbb1f64c"
          },
          {
            "url": "https://git.kernel.org/stable/c/6be74b1e21f8de4c48af772c2f658b464bfe6145"
          },
          {
            "url": "https://git.kernel.org/stable/c/9c573cd313433f6c1f7236fe64b9b743500c1628"
          },
          {
            "url": "https://git.kernel.org/stable/c/dfb2ce952143de60dd756ed666901236c76cb3fa"
          },
          {
            "url": "https://git.kernel.org/stable/c/e80b4980af2688d8ff69c157ffa773dd1f1eb02c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35919",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:48.303",
        "lastModified": "2024-05-19T11:15:48.303",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmedia: mediatek: vcodec: adding lock to protect encoder context list\nAdd a lock for the ctx_list, to avoid accessing a NULL pointer\nwithin the 'vpu_enc_ipi_handler' function when the ctx_list has\nbeen deleted due to an unexpected behavior on the SCP IP block.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/41671f0c0182b2bae74ca7e3b0f155559e3e2fc5"
          },
          {
            "url": "https://git.kernel.org/stable/c/51c84a8aac6e3b59af2b0e92ba63cabe2e641a2d"
          },
          {
            "url": "https://git.kernel.org/stable/c/afaaf3a0f647a24a7bf6a2145d8ade37baaf75ad"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35920",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:48.373",
        "lastModified": "2024-05-19T11:15:48.373",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmedia: mediatek: vcodec: adding lock to protect decoder context list\nAdd a lock for the ctx_list, to avoid accessing a NULL pointer\nwithin the 'vpu_dec_ipi_handler' function when the ctx_list has\nbeen deleted due to an unexpected behavior on the SCP IP block.\nHardware name: Google juniper sku16 board (DT)\npstate: 20400005 (nzCv daif +PAN -UAO -TCO BTYPE=--)\npc : vpu_dec_ipi_handler+0x58/0x1f8 [mtk_vcodec_dec]\nlr : scp_ipi_handler+0xd0/0x194 [mtk_scp]\nsp : ffffffc0131dbbd0\nx29: ffffffc0131dbbd0 x28: 0000000000000000\nx27: ffffff9bb277f348 x26: ffffff9bb242ad00\nx25: ffffffd2d440d3b8 x24: ffffffd2a13ff1d4\nx23: ffffff9bb7fe85a0 x22: ffffffc0133fbdb0\nx21: 0000000000000010 x20: ffffff9b050ea328\nx19: ffffffc0131dbc08 x18: 0000000000001000\nx17: 0000000000000000 x16: ffffffd2d461c6e0\nx15: 0000000000000242 x14: 000000000000018f\nx13: 000000000000004d x12: 0000000000000000\nx11: 0000000000000001 x10: fffffffffffffff0\nx9 : ffffff9bb6e793a8 x8 : 0000000000000000\nx7 : 0000000000000000 x6 : 000000000000003f\nx5 : 0000000000000040 x4 : fffffffffffffff0\nx3 : 0000000000000020 x2 : ffffff9bb6e79080\nx1 : 0000000000000010 x0 : ffffffc0131dbc08\nCall trace:\nvpu_dec_ipi_handler+0x58/0x1f8 [mtk_vcodec_dec (HASH:6c3f 2)]\nscp_ipi_handler+0xd0/0x194 [mtk_scp (HASH:7046 3)]\nmt8183_scp_irq_handler+0x44/0x88 [mtk_scp (HASH:7046 3)]\nscp_irq_handler+0x48/0x90 [mtk_scp (HASH:7046 3)]\nirq_thread_fn+0x38/0x94\nirq_thread+0x100/0x1c0\nkthread+0x140/0x1fc\nret_from_fork+0x10/0x30\nCode: 54000088 f94ca50a eb14015f 54000060 (f9400108)\n---[ end trace ace43ce36cbd5c93 ]---\nKernel panic - not syncing: Oops: Fatal exception\nSMP: stopping secondary CPUs\nKernel Offset: 0x12c4000000 from 0xffffffc010000000\nPHYS_OFFSET: 0xffffffe580000000\nCPU features: 0x08240002,2188200c\nMemory Limit: none",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0a2dc707aa42214f9c4827bd57e344e29a0841d6"
          },
          {
            "url": "https://git.kernel.org/stable/c/23aaf824121055ba81b55f75444355bd83c8eb38"
          },
          {
            "url": "https://git.kernel.org/stable/c/6467cda18c9f9b5f2f9a0aa1e2861c653e41f382"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35921",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:48.443",
        "lastModified": "2024-05-19T11:15:48.443",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmedia: mediatek: vcodec: Fix oops when HEVC init fails\nThe stateless HEVC decoder saves the instance pointer in the context\nregardless if the initialization worked or not. This caused a use after\nfree, when the pointer is freed in case of a failure in the deinit\nfunction.\nOnly store the instance pointer when the initialization was successful,\nto solve this issue.\n Hardware name: Acer Tomato (rev3 - 4) board (DT)\n pstate: 80400009 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n pc : vcodec_vpu_send_msg+0x4c/0x190 [mtk_vcodec_dec]\n lr : vcodec_send_ap_ipi+0x78/0x170 [mtk_vcodec_dec]\n sp : ffff80008750bc20\n x29: ffff80008750bc20 x28: ffff1299f6d70000 x27: 0000000000000000\n x26: 0000000000000000 x25: 0000000000000000 x24: 0000000000000000\n x23: ffff80008750bc98 x22: 000000000000a003 x21: ffffd45c4cfae000\n x20: 0000000000000010 x19: ffff1299fd668310 x18: 000000000000001a\n x17: 000000040044ffff x16: ffffd45cb15dc648 x15: 0000000000000000\n x14: ffff1299c08da1c0 x13: ffffd45cb1f87a10 x12: ffffd45cb2f5fe80\n x11: 0000000000000001 x10: 0000000000001b30 x9 : ffffd45c4d12b488\n x8 : 1fffe25339380d81 x7 : 0000000000000001 x6 : ffff1299c9c06c00\n x5 : 0000000000000132 x4 : 0000000000000000 x3 : 0000000000000000\n x2 : 0000000000000010 x1 : ffff80008750bc98 x0 : 0000000000000000\n Call trace:\n  vcodec_vpu_send_msg+0x4c/0x190 [mtk_vcodec_dec]\n  vcodec_send_ap_ipi+0x78/0x170 [mtk_vcodec_dec]\n  vpu_dec_deinit+0x1c/0x30 [mtk_vcodec_dec]\n  vdec_hevc_slice_deinit+0x30/0x98 [mtk_vcodec_dec]\n  vdec_if_deinit+0x38/0x68 [mtk_vcodec_dec]\n  mtk_vcodec_dec_release+0x20/0x40 [mtk_vcodec_dec]\n  fops_vcodec_release+0x64/0x118 [mtk_vcodec_dec]\n  v4l2_release+0x7c/0x100\n  __fput+0x80/0x2d8\n  __fput_sync+0x58/0x70\n  __arm64_sys_close+0x40/0x90\n  invoke_syscall+0x50/0x128\n  el0_svc_common.constprop.0+0x48/0xf0\n  do_el0_svc+0x24/0x38\n  el0_svc+0x38/0xd8\n  el0t_64_sync_handler+0xc0/0xc8\n  el0t_64_sync+0x1a8/0x1b0\n Code: d503201f f9401660 b900127f b900227f (f9400400)",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/521ce0ea7418298d754494fe53263c23c4c78a8e"
          },
          {
            "url": "https://git.kernel.org/stable/c/97c75ee5de060d271d80109b0c47cb6008439e5b"
          },
          {
            "url": "https://git.kernel.org/stable/c/ec25fc3c2c1e8958a51abcfed614f81446d918c4"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35922",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:48.513",
        "lastModified": "2024-05-19T11:15:48.513",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nfbmon: prevent division by zero in fb_videomode_from_videomode()\nThe expression htotal * vtotal can have a zero value on\noverflow. It is necessary to prevent division by zero like in\nfb_var_to_videomode().\nFound by Linux Verification Center (linuxtesting.org) with Svace.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1b107d637fed68a787da77a3514ad06e57abd0b4"
          },
          {
            "url": "https://git.kernel.org/stable/c/1fb52bc1de55e9e0bdf71fe078efd4da0889710f"
          },
          {
            "url": "https://git.kernel.org/stable/c/3d4b909704bf2114f64f87363fa22b5ef8ac4a33"
          },
          {
            "url": "https://git.kernel.org/stable/c/48d6bcfc31751ca2e753d901a2d82f27edf8a029"
          },
          {
            "url": "https://git.kernel.org/stable/c/664206ff8b019bcd1e55b10b2eea3add8761b971"
          },
          {
            "url": "https://git.kernel.org/stable/c/72d091b7515e0532ee015e144c906f3bcfdd6270"
          },
          {
            "url": "https://git.kernel.org/stable/c/951838fee462aa01fa2a6a91d56f9a495082e7f0"
          },
          {
            "url": "https://git.kernel.org/stable/c/c2d953276b8b27459baed1277a4fdd5dd9bd4126"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35923",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:48.587",
        "lastModified": "2024-05-19T11:15:48.587",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nio_uring: clear opcode specific data for an early failure\nIf failure happens before the opcode prep handler is called, ensure that\nwe clear the opcode specific area of the request, which holds data\nspecific to that request type. This prevents errors where opcode\nhandlers either don't get to clear per-request private data since prep\nisn't even called.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/21162ad2de7446438cbd6224b3794a375bcb24df"
          },
          {
            "url": "https://git.kernel.org/stable/c/5245a6da27ef79f8dba98dad5542ebe56d311837"
          },
          {
            "url": "https://git.kernel.org/stable/c/cb1cd176e0b431644653a7fa8691a1aaf7be98da"
          },
          {
            "url": "https://git.kernel.org/stable/c/e21e1c45e1fe2e31732f40256b49c04e76a17cee"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35924",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:48.653",
        "lastModified": "2024-05-19T11:15:48.653",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nusb: typec: ucsi: Limit read size on v1.2\nBetween UCSI 1.2 and UCSI 2.0, the size of the MESSAGE_IN region was\nincreased from 16 to 256. In order to avoid overflowing reads for older\nsystems, add a mechanism to use the read UCSI version to truncate read\nsizes on UCSI v1.2.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0defcaa09d3b21e8387829ee3a652c43fa91e13f"
          },
          {
            "url": "https://git.kernel.org/stable/c/266f403ec47573046dee4bcebda82777ce702c40"
          },
          {
            "url": "https://git.kernel.org/stable/c/b3db266fb031fba88c423d4bb8983a73a3db6527"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35925",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:48.720",
        "lastModified": "2024-05-19T11:15:48.720",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nblock: prevent division by zero in blk_rq_stat_sum()\nThe expression dst->nr_samples + src->nr_samples may\nhave zero value on overflow. It is necessary to add\na check to avoid division by zero.\nFound by Linux Verification Center (linuxtesting.org) with Svace.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/21e7d72d0cfcbae6042d498ea2e6f395311767f8"
          },
          {
            "url": "https://git.kernel.org/stable/c/512a01da7134bac8f8b373506011e8aaa3283854"
          },
          {
            "url": "https://git.kernel.org/stable/c/5f7fd6aa4c4877d77133ea86c14cf256f390b2fe"
          },
          {
            "url": "https://git.kernel.org/stable/c/6a55dab4ac956deb23690eedd74e70b892a378e7"
          },
          {
            "url": "https://git.kernel.org/stable/c/93f52fbeaf4b676b21acfe42a5152620e6770d02"
          },
          {
            "url": "https://git.kernel.org/stable/c/98ddf2604ade2d954bf5ec193600d5274a43fd68"
          },
          {
            "url": "https://git.kernel.org/stable/c/b0cb5564c3e8e0ee0a2d28c86fa7f02e82d64c3c"
          },
          {
            "url": "https://git.kernel.org/stable/c/edd073c78d2bf48c5b8bf435bbc3d61d6e7c6c14"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35926",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:48.793",
        "lastModified": "2024-05-19T11:15:48.793",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ncrypto: iaa - Fix async_disable descriptor leak\nThe disable_async paths of iaa_compress/decompress() don't free idxd\ndescriptors in the async_disable case. Currently this only happens in\nthe testcases where req->dst is set to null. Add a test to free them\nin those paths.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/262534ddc88dfea7474ed18adfecf856e4fbe054"
          },
          {
            "url": "https://git.kernel.org/stable/c/d994f7d77aaded05dc05af58a2720fd4f4b72a83"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35927",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:48.860",
        "lastModified": "2024-05-19T11:15:48.860",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm: Check output polling initialized before disabling\nIn drm_kms_helper_poll_disable() check if output polling\nsupport is initialized before disabling polling. If not flag\nthis as a warning.\nAdditionally in drm_mode_config_helper_suspend() and\ndrm_mode_config_helper_resume() calls, that re the callers of these\nfunctions, avoid invoking them if polling is not initialized.\nFor drivers like hyperv-drm, that do not initialize connector\npolling, if suspend is called without this check, it leads to\nsuspend failure with following stack\n[  770.719392] Freezing remaining freezable tasks ... (elapsed 0.001 seconds) done.\n[  770.720592] printk: Suspending console(s) (use no_console_suspend to debug)\n[  770.948823] ------------[ cut here ]------------\n[  770.948824] WARNING: CPU: 1 PID: 17197 at kernel/workqueue.c:3162 __flush_work.isra.0+0x212/0x230\n[  770.948831] Modules linked in: rfkill nft_counter xt_conntrack xt_owner udf nft_compat crc_itu_t nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables nfnetlink vfat fat mlx5_ib ib_uverbs ib_core mlx5_core intel_rapl_msr intel_rapl_common kvm_amd ccp mlxfw kvm psample hyperv_drm tls drm_shmem_helper drm_kms_helper irqbypass pcspkr syscopyarea sysfillrect sysimgblt hv_balloon hv_utils joydev drm fuse xfs libcrc32c pci_hyperv pci_hyperv_intf sr_mod sd_mod cdrom t10_pi sg hv_storvsc scsi_transport_fc hv_netvsc serio_raw hyperv_keyboard hid_hyperv crct10dif_pclmul crc32_pclmul crc32c_intel hv_vmbus ghash_clmulni_intel dm_mirror dm_region_hash dm_log dm_mod\n[  770.948863] CPU: 1 PID: 17197 Comm: systemd-sleep Not tainted 5.14.0-362.2.1.el9_3.x86_64 #1\n[  770.948865] Hardware name: Microsoft Corporation Virtual Machine/Virtual Machine, BIOS Hyper-V UEFI Release v4.1 05/09/2022\n[  770.948866] RIP: 0010:__flush_work.isra.0+0x212/0x230\n[  770.948869] Code: 8b 4d 00 4c 8b 45 08 89 ca 48 c1 e9 04 83 e2 08 83 e1 0f 83 ca 02 89 c8 48 0f ba 6d 00 03 e9 25 ff ff ff 0f 0b e9 4e ff ff ff <0f> 0b 45 31 ed e9 44 ff ff ff e8 8f 89 b2 00 66 66 2e 0f 1f 84 00\n[  770.948870] RSP: 0018:ffffaf4ac213fb10 EFLAGS: 00010246\n[  770.948871] RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff8c992857\n[  770.948872] RDX: 0000000000000001 RSI: 0000000000000001 RDI: ffff9aad82b00330\n[  770.948873] RBP: ffff9aad82b00330 R08: 0000000000000000 R09: ffff9aad87ee3d10\n[  770.948874] R10: 0000000000000200 R11: 0000000000000000 R12: ffff9aad82b00330\n[  770.948874] R13: 0000000000000001 R14: 0000000000000000 R15: 0000000000000001\n[  770.948875] FS:  00007ff1b2f6bb40(0000) GS:ffff9aaf37d00000(0000) knlGS:0000000000000000\n[  770.948878] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  770.948878] CR2: 0000555f345cb666 CR3: 00000001462dc005 CR4: 0000000000370ee0\n[  770.948879] Call Trace:\n[  770.948880]  <TASK>\n[  770.948881]  ? show_trace_log_lvl+0x1c4/0x2df\n[  770.948884]  ? show_trace_log_lvl+0x1c4/0x2df\n[  770.948886]  ? __cancel_work_timer+0x103/0x190\n[  770.948887]  ? __flush_work.isra.0+0x212/0x230\n[  770.948889]  ? __warn+0x81/0x110\n[  770.948891]  ? __flush_work.isra.0+0x212/0x230\n[  770.948892]  ? report_bug+0x10a/0x140\n[  770.948895]  ? handle_bug+0x3c/0x70\n[  770.948898]  ? exc_invalid_op+0x14/0x70\n[  770.948899]  ? asm_exc_invalid_op+0x16/0x20\n[  770.948903]  ? __flush_work.isra.0+0x212/0x230\n[  770.948905]  __cancel_work_timer+0x103/0x190\n[  770.948907]  ? _raw_spin_unlock_irqrestore+0xa/0x30\n[  770.948910]  drm_kms_helper_poll_disable+0x1e/0x40 [drm_kms_helper]\n[  770.948923]  drm_mode_config_helper_suspend+0x1c/0x80 [drm_kms_helper]\n[  770.948933]  ? __pfx_vmbus_suspend+0x10/0x10 [hv_vmbus]\n[  770.948942]  hyperv_vmbus_suspend+0x17/0x40 [hyperv_drm]\n[  770.948944]  ? __pfx_vmbus_suspend+0x10/0x10 [hv_vmbus]\n[  770.948951]  dpm_run_callback+0x4c/0x140\n[  770.948954]  __device_suspend_noir\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/18451798f4a4e7418b9fad7e7dd313fe84b1f545"
          },
          {
            "url": "https://git.kernel.org/stable/c/3d1b47e3a935abd4f258a945db87e7267ff4079c"
          },
          {
            "url": "https://git.kernel.org/stable/c/5abffb66d12bcac84bf7b66389c571b8bb6e82bd"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35928",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:48.930",
        "lastModified": "2024-05-19T11:15:48.930",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/amd/amdgpu: Fix potential ioremap() memory leaks in amdgpu_device_init()\nThis ensures that the memory mapped by ioremap for adev->rmmio, is\nproperly handled in amdgpu_device_init(). If the function exits early\ndue to an error, the memory is unmapped. If the function completes\nsuccessfully, the memory remains mapped.\nReported by smatch:\ndrivers/gpu/drm/amd/amdgpu/amdgpu_device.c:4337 amdgpu_device_init() warn: 'adev->rmmio' from ioremap() not released on lines: 4035,4045,4051,4058,4068,4337",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/14ac934db851642ea8cd1bd4121c788a8899ef69"
          },
          {
            "url": "https://git.kernel.org/stable/c/aa665c3a2aca2ffe31b9645bda278e96dfc3b55c"
          },
          {
            "url": "https://git.kernel.org/stable/c/c5f9fe2c1e5023fa096189a8bfba6420aa035587"
          },
          {
            "url": "https://git.kernel.org/stable/c/eb4f139888f636614dab3bcce97ff61cefc4b3a7"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35929",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:48.993",
        "lastModified": "2024-05-19T11:15:48.993",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nrcu/nocb: Fix WARN_ON_ONCE() in the rcu_nocb_bypass_lock()\nFor the kernels built with CONFIG_RCU_NOCB_CPU_DEFAULT_ALL=y and\nCONFIG_RCU_LAZY=y, the following scenarios will trigger WARN_ON_ONCE()\nin the rcu_nocb_bypass_lock() and rcu_nocb_wait_contended() functions:\n        CPU2                                               CPU11\nkthread\nrcu_nocb_cb_kthread                                       ksys_write\nrcu_do_batch                                              vfs_write\nrcu_torture_timer_cb                                      proc_sys_write\n__kmem_cache_free                                         proc_sys_call_handler\nkmemleak_free                                             drop_caches_sysctl_handler\ndelete_object_full                                        drop_slab\n__delete_object                                           shrink_slab\nput_object                                                lazy_rcu_shrink_scan\ncall_rcu                                                  rcu_nocb_flush_bypass\n__call_rcu_commn                                            rcu_nocb_bypass_lock\n                                                            raw_spin_trylock(&rdp->nocb_bypass_lock) fail\n                                                            atomic_inc(&rdp->nocb_lock_contended);\nrcu_nocb_wait_contended                                     WARN_ON_ONCE(smp_processor_id() != rdp->cpu);\n WARN_ON_ONCE(atomic_read(&rdp->nocb_lock_contended))                                          |\n                            |_ _ _ _ _ _ _ _ _ _same rdp and rdp->cpu != 11_ _ _ _ _ _ _ _ _ __|\nReproduce this bug with \"echo 3 > /proc/sys/vm/drop_caches\".\nThis commit therefore uses rcu_nocb_try_flush_bypass() instead of\nrcu_nocb_flush_bypass() in lazy_rcu_shrink_scan().  If the nocb_bypass\nqueue is being flushed, then rcu_nocb_try_flush_bypass will return\ndirectly.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4d58c9fb45c70e62c19e8be3f3605889c47601bc"
          },
          {
            "url": "https://git.kernel.org/stable/c/927d1f4f77e4784ab3944a9df86ab14d1cd3185a"
          },
          {
            "url": "https://git.kernel.org/stable/c/dda98810b552fc6bf650f4270edeebdc2f28bd3f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35930",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:49.057",
        "lastModified": "2024-05-19T11:15:49.057",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nscsi: lpfc: Fix possible memory leak in lpfc_rcv_padisc()\nThe call to lpfc_sli4_resume_rpi() in lpfc_rcv_padisc() may return an\nunsuccessful status.  In such cases, the elsiocb is not issued, the\ncompletion is not called, and thus the elsiocb resource is leaked.\nCheck return value after calling lpfc_sli4_resume_rpi() and conditionally\nrelease the elsiocb resource.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/07a2aa674fca679316b8ac51440adb895b53a7cf"
          },
          {
            "url": "https://git.kernel.org/stable/c/2ae917d4bcab80ab304b774d492e2fcd6c52c06b"
          },
          {
            "url": "https://git.kernel.org/stable/c/3320126ed3afbc11934502319b340f91a4d61c8f"
          },
          {
            "url": "https://git.kernel.org/stable/c/7849e6f8410da96384e3d1f6b6d730f095142dc7"
          },
          {
            "url": "https://git.kernel.org/stable/c/c473288f27d15014447de5a891bdf22a0695847a"
          },
          {
            "url": "https://git.kernel.org/stable/c/e2cd32435b1dff3d63759476a3abc878e02fb6c8"
          },
          {
            "url": "https://git.kernel.org/stable/c/edf82aa7e9eb864a09229392054d131b34a5c9e8"
          },
          {
            "url": "https://git.kernel.org/stable/c/ee0b5f96b6d66a1e6698228dcb41df11ec7f352f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35931",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:49.133",
        "lastModified": "2024-05-19T11:15:49.133",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/amdgpu: Skip do PCI error slot reset during RAS recovery\nWhy:\n    The PCI error slot reset maybe triggered after inject ue to UMC multi times, this\n    caused system hang.\n    [  557.371857] amdgpu 0000:af:00.0: amdgpu: GPU reset succeeded, trying to resume\n    [  557.373718] [drm] PCIE GART of 512M enabled.\n    [  557.373722] [drm] PTB located at 0x0000031FED700000\n    [  557.373788] [drm] VRAM is lost due to GPU reset!\n    [  557.373789] [drm] PSP is resuming...\n    [  557.547012] mlx5_core 0000:55:00.0: mlx5_pci_err_detected Device state = 1 pci_status: 0. Exit, result = 3, need reset\n    [  557.547067] [drm] PCI error: detected callback, state(1)!!\n    [  557.547069] [drm] No support for XGMI hive yet...\n    [  557.548125] mlx5_core 0000:55:00.0: mlx5_pci_slot_reset Device state = 1 pci_status: 0. Enter\n    [  557.607763] mlx5_core 0000:55:00.0: wait vital counter value 0x16b5b after 1 iterations\n    [  557.607777] mlx5_core 0000:55:00.0: mlx5_pci_slot_reset Device state = 1 pci_status: 1. Exit, err = 0, result = 5, recovered\n    [  557.610492] [drm] PCI error: slot reset callback!!\n    ...\n    [  560.689382] amdgpu 0000:3f:00.0: amdgpu: GPU reset(2) succeeded!\n    [  560.689546] amdgpu 0000:5a:00.0: amdgpu: GPU reset(2) succeeded!\n    [  560.689562] general protection fault, probably for non-canonical address 0x5f080b54534f611f: 0000 [#1] SMP NOPTI\n    [  560.701008] CPU: 16 PID: 2361 Comm: kworker/u448:9 Tainted: G           OE     5.15.0-91-generic #101-Ubuntu\n    [  560.712057] Hardware name: Microsoft C278A/C278A, BIOS C2789.5.BS.1C11.AG.1 11/08/2023\n    [  560.720959] Workqueue: amdgpu-reset-hive amdgpu_ras_do_recovery [amdgpu]\n    [  560.728887] RIP: 0010:amdgpu_device_gpu_recover.cold+0xbf1/0xcf5 [amdgpu]\n    [  560.736891] Code: ff 41 89 c6 e9 1b ff ff ff 44 0f b6 45 b0 e9 4f ff ff ff be 01 00 00 00 4c 89 e7 e8 76 c9 8b ff 44 0f b6 45 b0 e9 3c fd ff ff <48> 83 ba 18 02 00 00 00 0f 84 6a f8 ff ff 48 8d 7a 78 be 01 00 00\n    [  560.757967] RSP: 0018:ffa0000032e53d80 EFLAGS: 00010202\n    [  560.763848] RAX: ffa00000001dfd10 RBX: ffa0000000197090 RCX: ffa0000032e53db0\n    [  560.771856] RDX: 5f080b54534f5f07 RSI: 0000000000000000 RDI: ff11000128100010\n    [  560.779867] RBP: ffa0000032e53df0 R08: 0000000000000000 R09: ffffffffffe77f08\n    [  560.787879] R10: 0000000000ffff0a R11: 0000000000000001 R12: 0000000000000000\n    [  560.795889] R13: ffa0000032e53e00 R14: 0000000000000000 R15: 0000000000000000\n    [  560.803889] FS:  0000000000000000(0000) GS:ff11007e7e800000(0000) knlGS:0000000000000000\n    [  560.812973] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n    [  560.819422] CR2: 000055a04c118e68 CR3: 0000000007410005 CR4: 0000000000771ee0\n    [  560.827433] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n    [  560.835433] DR3: 0000000000000000 DR6: 00000000fffe07f0 DR7: 0000000000000400\n    [  560.843444] PKRU: 55555554\n    [  560.846480] Call Trace:\n    [  560.849225]  <TASK>\n    [  560.851580]  ? show_trace_log_lvl+0x1d6/0x2ea\n    [  560.856488]  ? show_trace_log_lvl+0x1d6/0x2ea\n    [  560.861379]  ? amdgpu_ras_do_recovery+0x1b2/0x210 [amdgpu]\n    [  560.867778]  ? show_regs.part.0+0x23/0x29\n    [  560.872293]  ? __die_body.cold+0x8/0xd\n    [  560.876502]  ? die_addr+0x3e/0x60\n    [  560.880238]  ? exc_general_protection+0x1c5/0x410\n    [  560.885532]  ? asm_exc_general_protection+0x27/0x30\n    [  560.891025]  ? amdgpu_device_gpu_recover.cold+0xbf1/0xcf5 [amdgpu]\n    [  560.898323]  amdgpu_ras_do_recovery+0x1b2/0x210 [amdgpu]\n    [  560.904520]  process_one_work+0x228/0x3d0\nHow:\n    In RAS recovery, mode-1 reset is issued from RAS fatal error handling and expected\n    all the nodes in a hive to be reset. no need to issue another mode-1 during this procedure.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/395ca1031acf89d8ecb26127c544a71688d96f35"
          },
          {
            "url": "https://git.kernel.org/stable/c/601429cca96b4af3be44172c3b64e4228515dbe1"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35932",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:49.203",
        "lastModified": "2024-05-19T11:15:49.203",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/vc4: don't check if plane->state->fb == state->fb\nCurrently, when using non-blocking commits, we can see the following\nkernel warning:\n[  110.908514] ------------[ cut here ]------------\n[  110.908529] refcount_t: underflow; use-after-free.\n[  110.908620] WARNING: CPU: 0 PID: 1866 at lib/refcount.c:87 refcount_dec_not_one+0xb8/0xc0\n[  110.908664] Modules linked in: rfcomm snd_seq_dummy snd_hrtimer snd_seq snd_seq_device cmac algif_hash aes_arm64 aes_generic algif_skcipher af_alg bnep hid_logitech_hidpp vc4 brcmfmac hci_uart btbcm brcmutil bluetooth snd_soc_hdmi_codec cfg80211 cec drm_display_helper drm_dma_helper drm_kms_helper snd_soc_core snd_compress snd_pcm_dmaengine fb_sys_fops sysimgblt syscopyarea sysfillrect raspberrypi_hwmon ecdh_generic ecc rfkill libaes i2c_bcm2835 binfmt_misc joydev snd_bcm2835(C) bcm2835_codec(C) bcm2835_isp(C) v4l2_mem2mem videobuf2_dma_contig snd_pcm bcm2835_v4l2(C) raspberrypi_gpiomem bcm2835_mmal_vchiq(C) videobuf2_v4l2 snd_timer videobuf2_vmalloc videobuf2_memops videobuf2_common snd videodev vc_sm_cma(C) mc hid_logitech_dj uio_pdrv_genirq uio i2c_dev drm fuse dm_mod drm_panel_orientation_quirks backlight ip_tables x_tables ipv6\n[  110.909086] CPU: 0 PID: 1866 Comm: kodi.bin Tainted: G         C         6.1.66-v8+ #32\n[  110.909104] Hardware name: Raspberry Pi 3 Model B Rev 1.2 (DT)\n[  110.909114] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[  110.909132] pc : refcount_dec_not_one+0xb8/0xc0\n[  110.909152] lr : refcount_dec_not_one+0xb4/0xc0\n[  110.909170] sp : ffffffc00913b9c0\n[  110.909177] x29: ffffffc00913b9c0 x28: 000000556969bbb0 x27: 000000556990df60\n[  110.909205] x26: 0000000000000002 x25: 0000000000000004 x24: ffffff8004448480\n[  110.909230] x23: ffffff800570b500 x22: ffffff802e03a7bc x21: ffffffecfca68c78\n[  110.909257] x20: ffffff8002b42000 x19: ffffff802e03a600 x18: 0000000000000000\n[  110.909283] x17: 0000000000000011 x16: ffffffffffffffff x15: 0000000000000004\n[  110.909308] x14: 0000000000000fff x13: ffffffed577e47e0 x12: 0000000000000003\n[  110.909333] x11: 0000000000000000 x10: 0000000000000027 x9 : c912d0d083728c00\n[  110.909359] x8 : c912d0d083728c00 x7 : 65646e75203a745f x6 : 746e756f63666572\n[  110.909384] x5 : ffffffed579f62ee x4 : ffffffed579eb01e x3 : 0000000000000000\n[  110.909409] x2 : 0000000000000000 x1 : ffffffc00913b750 x0 : 0000000000000001\n[  110.909434] Call trace:\n[  110.909441]  refcount_dec_not_one+0xb8/0xc0\n[  110.909461]  vc4_bo_dec_usecnt+0x4c/0x1b0 [vc4]\n[  110.909903]  vc4_cleanup_fb+0x44/0x50 [vc4]\n[  110.910315]  drm_atomic_helper_cleanup_planes+0x88/0xa4 [drm_kms_helper]\n[  110.910669]  vc4_atomic_commit_tail+0x390/0x9dc [vc4]\n[  110.911079]  commit_tail+0xb0/0x164 [drm_kms_helper]\n[  110.911397]  drm_atomic_helper_commit+0x1d0/0x1f0 [drm_kms_helper]\n[  110.911716]  drm_atomic_commit+0xb0/0xdc [drm]\n[  110.912569]  drm_mode_atomic_ioctl+0x348/0x4b8 [drm]\n[  110.913330]  drm_ioctl_kernel+0xec/0x15c [drm]\n[  110.914091]  drm_ioctl+0x24c/0x3b0 [drm]\n[  110.914850]  __arm64_sys_ioctl+0x9c/0xd4\n[  110.914873]  invoke_syscall+0x4c/0x114\n[  110.914897]  el0_svc_common+0xd0/0x118\n[  110.914917]  do_el0_svc+0x38/0xd0\n[  110.914936]  el0_svc+0x30/0x8c\n[  110.914958]  el0t_64_sync_handler+0x84/0xf0\n[  110.914979]  el0t_64_sync+0x18c/0x190\n[  110.914996] ---[ end trace 0000000000000000 ]---\nThis happens because, although `prepare_fb` and `cleanup_fb` are\nperfectly balanced, we cannot guarantee consistency in the check\nplane->state->fb == state->fb. This means that sometimes we can increase\nthe refcount in `prepare_fb` and don't decrease it in `cleanup_fb`. The\nopposite can also be true.\nIn fact, the struct drm_plane .state shouldn't be accessed directly\nbut instead, the `drm_atomic_get_new_plane_state()` helper function should\nbe used. So, we could stick to this check, but using\n`drm_atomic_get_new_plane_state()`. But actually, this check is not re\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/48bfb4b03c5ff6e1fa1dc73fb915e150b0968c40"
          },
          {
            "url": "https://git.kernel.org/stable/c/5343f724c912c77541029123f47ecd3d2ea63bdd"
          },
          {
            "url": "https://git.kernel.org/stable/c/5ee0d47dcf33efd8950b347dcf4d20bab12a3fa9"
          },
          {
            "url": "https://git.kernel.org/stable/c/d6b2fe2db1d0927b2d7df5c763eba55d0e1def3c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35933",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:49.270",
        "lastModified": "2024-05-19T11:15:49.270",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nBluetooth: btintel: Fix null ptr deref in btintel_read_version\nIf hci_cmd_sync_complete() is triggered and skb is NULL, then\nhdev->req_skb is NULL, which will cause this issue.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/006936ecb4edfc3102464044f75858c714e34d28"
          },
          {
            "url": "https://git.kernel.org/stable/c/22d3053ef05f0b5045e45bd91e7473846261d65e"
          },
          {
            "url": "https://git.kernel.org/stable/c/68a69bb2ecafaacdb998a87783068fb51736f43b"
          },
          {
            "url": "https://git.kernel.org/stable/c/86e9b47e8a75c74b1bd83a479979b425c5dc8bd9"
          },
          {
            "url": "https://git.kernel.org/stable/c/b19fe5eea619d54eea59bb8a37c0f8d00ef0e912"
          },
          {
            "url": "https://git.kernel.org/stable/c/b79e040910101b020931ba0c9a6b77e81ab7f645"
          },
          {
            "url": "https://git.kernel.org/stable/c/ec2049fb2b8be3e108fe2ef1f1040f91e72c9990"
          },
          {
            "url": "https://git.kernel.org/stable/c/ffdca0a62abaf8c41d8d9ea132000fd808de329b"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35934",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:49.343",
        "lastModified": "2024-05-19T11:15:49.343",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/smc: reduce rtnl pressure in smc_pnet_create_pnetids_list()\nMany syzbot reports show extreme rtnl pressure, and many of them hint\nthat smc acquires rtnl in netns creation for no good reason [1]\nThis patch returns early from smc_pnet_net_init()\nif there is no netdevice yet.\nI am not even sure why smc_pnet_create_pnetids_list() even exists,\nbecause smc_pnet_netdev_event() is also calling\nsmc_pnet_add_base_pnetid() when handling NETDEV_UP event.\n[1] extract of typical syzbot reports\n2 locks held by syz-executor.3/12252:\n  #0: ffffffff8f369610 (pernet_ops_rwsem){++++}-{3:3}, at: copy_net_ns+0x4c7/0x7b0 net/core/net_namespace.c:491\n  #1: ffffffff8f375b88 (rtnl_mutex){+.+.}-{3:3}, at: smc_pnet_create_pnetids_list net/smc/smc_pnet.c:809 [inline]\n  #1: ffffffff8f375b88 (rtnl_mutex){+.+.}-{3:3}, at: smc_pnet_net_init+0x10a/0x1e0 net/smc/smc_pnet.c:878\n2 locks held by syz-executor.4/12253:\n  #0: ffffffff8f369610 (pernet_ops_rwsem){++++}-{3:3}, at: copy_net_ns+0x4c7/0x7b0 net/core/net_namespace.c:491\n  #1: ffffffff8f375b88 (rtnl_mutex){+.+.}-{3:3}, at: smc_pnet_create_pnetids_list net/smc/smc_pnet.c:809 [inline]\n  #1: ffffffff8f375b88 (rtnl_mutex){+.+.}-{3:3}, at: smc_pnet_net_init+0x10a/0x1e0 net/smc/smc_pnet.c:878\n2 locks held by syz-executor.1/12257:\n  #0: ffffffff8f369610 (pernet_ops_rwsem){++++}-{3:3}, at: copy_net_ns+0x4c7/0x7b0 net/core/net_namespace.c:491\n  #1: ffffffff8f375b88 (rtnl_mutex){+.+.}-{3:3}, at: smc_pnet_create_pnetids_list net/smc/smc_pnet.c:809 [inline]\n  #1: ffffffff8f375b88 (rtnl_mutex){+.+.}-{3:3}, at: smc_pnet_net_init+0x10a/0x1e0 net/smc/smc_pnet.c:878\n2 locks held by syz-executor.2/12261:\n  #0: ffffffff8f369610 (pernet_ops_rwsem){++++}-{3:3}, at: copy_net_ns+0x4c7/0x7b0 net/core/net_namespace.c:491\n  #1: ffffffff8f375b88 (rtnl_mutex){+.+.}-{3:3}, at: smc_pnet_create_pnetids_list net/smc/smc_pnet.c:809 [inline]\n  #1: ffffffff8f375b88 (rtnl_mutex){+.+.}-{3:3}, at: smc_pnet_net_init+0x10a/0x1e0 net/smc/smc_pnet.c:878\n2 locks held by syz-executor.0/12265:\n  #0: ffffffff8f369610 (pernet_ops_rwsem){++++}-{3:3}, at: copy_net_ns+0x4c7/0x7b0 net/core/net_namespace.c:491\n  #1: ffffffff8f375b88 (rtnl_mutex){+.+.}-{3:3}, at: smc_pnet_create_pnetids_list net/smc/smc_pnet.c:809 [inline]\n  #1: ffffffff8f375b88 (rtnl_mutex){+.+.}-{3:3}, at: smc_pnet_net_init+0x10a/0x1e0 net/smc/smc_pnet.c:878\n2 locks held by syz-executor.3/12268:\n  #0: ffffffff8f369610 (pernet_ops_rwsem){++++}-{3:3}, at: copy_net_ns+0x4c7/0x7b0 net/core/net_namespace.c:491\n  #1: ffffffff8f375b88 (rtnl_mutex){+.+.}-{3:3}, at: smc_pnet_create_pnetids_list net/smc/smc_pnet.c:809 [inline]\n  #1: ffffffff8f375b88 (rtnl_mutex){+.+.}-{3:3}, at: smc_pnet_net_init+0x10a/0x1e0 net/smc/smc_pnet.c:878\n2 locks held by syz-executor.4/12271:\n  #0: ffffffff8f369610 (pernet_ops_rwsem){++++}-{3:3}, at: copy_net_ns+0x4c7/0x7b0 net/core/net_namespace.c:491\n  #1: ffffffff8f375b88 (rtnl_mutex){+.+.}-{3:3}, at: smc_pnet_create_pnetids_list net/smc/smc_pnet.c:809 [inline]\n  #1: ffffffff8f375b88 (rtnl_mutex){+.+.}-{3:3}, at: smc_pnet_net_init+0x10a/0x1e0 net/smc/smc_pnet.c:878\n2 locks held by syz-executor.1/12274:\n  #0: ffffffff8f369610 (pernet_ops_rwsem){++++}-{3:3}, at: copy_net_ns+0x4c7/0x7b0 net/core/net_namespace.c:491\n  #1: ffffffff8f375b88 (rtnl_mutex){+.+.}-{3:3}, at: smc_pnet_create_pnetids_list net/smc/smc_pnet.c:809 [inline]\n  #1: ffffffff8f375b88 (rtnl_mutex){+.+.}-{3:3}, at: smc_pnet_net_init+0x10a/0x1e0 net/smc/smc_pnet.c:878\n2 locks held by syz-executor.2/12280:\n  #0: ffffffff8f369610 (pernet_ops_rwsem){++++}-{3:3}, at: copy_net_ns+0x4c7/0x7b0 net/core/net_namespace.c:491\n  #1: ffffffff8f375b88 (rtnl_mutex){+.+.}-{3:3}, at: smc_pnet_create_pnetids_list net/smc/smc_pnet.c:809 [inline]\n  #1: ffffffff8f375b88 (rtnl_mutex){+.+.}-{3:3}, at: smc_pnet_net_init+0x10a/0x1e0 net/smc/smc_pnet.c:878",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/00af2aa93b76b1bade471ad0d0525d4d29ca5cc0"
          },
          {
            "url": "https://git.kernel.org/stable/c/6e920422e7104928f760fc0e12b6d65ab097a2e7"
          },
          {
            "url": "https://git.kernel.org/stable/c/a2e6bffc0388526ed10406040279a693d62b36ec"
          },
          {
            "url": "https://git.kernel.org/stable/c/b9117dc783c0ab0a3866812f70e07bf2ea071ac4"
          },
          {
            "url": "https://git.kernel.org/stable/c/bc4d1ebca11b4f194e262326bd45938e857c59d2"
          },
          {
            "url": "https://git.kernel.org/stable/c/d7ee3bf0caf599c14db0bf4af7aacd6206ef8a23"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35935",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:49.413",
        "lastModified": "2024-05-19T11:15:49.413",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbtrfs: send: handle path ref underflow in header iterate_inode_ref()\nChange BUG_ON to proper error handling if building the path buffer\nfails. The pointers are not printed so we don't accidentally leak kernel\naddresses.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/024529c27c8b4b273325a169e078337c8279e229"
          },
          {
            "url": "https://git.kernel.org/stable/c/03938619a1e718b6168ae4528e1b0f979293f1a5"
          },
          {
            "url": "https://git.kernel.org/stable/c/2f6174fd4ccf403b42b3d5f0d1b6b496a0e5330a"
          },
          {
            "url": "https://git.kernel.org/stable/c/3c6ee34c6f9cd12802326da26631232a61743501"
          },
          {
            "url": "https://git.kernel.org/stable/c/4720d590c4cb5d9ffa0060b89743651cc7e995f9"
          },
          {
            "url": "https://git.kernel.org/stable/c/9ae356c627b493323e1433dcb27a26917668c07c"
          },
          {
            "url": "https://git.kernel.org/stable/c/be2b6bcc936ae17f42fff6494106a5660b35d8d3"
          },
          {
            "url": "https://git.kernel.org/stable/c/c1363ed8867b81ea169fba2ccc14af96a85ed183"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35936",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:49.480",
        "lastModified": "2024-05-19T11:15:49.480",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbtrfs: handle chunk tree lookup error in btrfs_relocate_sys_chunks()\nThe unhandled case in btrfs_relocate_sys_chunks() loop is a corruption,\nas it could be caused only by two impossible conditions:\n- at first the search key is set up to look for a chunk tree item, with\n  offset -1, this is an inexact search and the key->offset will contain\n  the correct offset upon a successful search, a valid chunk tree item\n  cannot have an offset -1\n- after first successful search, the found_key corresponds to a chunk\n  item, the offset is decremented by 1 before the next loop, it's\n  impossible to find a chunk item there due to alignment and size\n  constraints",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0d23b34c68c46cd225b55868bc8a269e3134816d"
          },
          {
            "url": "https://git.kernel.org/stable/c/1f9212cdbd005bc55f2b7422e7b560d9c02bd1da"
          },
          {
            "url": "https://git.kernel.org/stable/c/36c2a2863bc3896243eb724dc3fd4cf9aea633f2"
          },
          {
            "url": "https://git.kernel.org/stable/c/576164bd01bd795f8b09fb194b493103506b33c9"
          },
          {
            "url": "https://git.kernel.org/stable/c/7411055db5ce64f836aaffd422396af0075fdc99"
          },
          {
            "url": "https://git.kernel.org/stable/c/87299cdaae757f3f41212146cfb5b3af416b8385"
          },
          {
            "url": "https://git.kernel.org/stable/c/bebd9e0ff90034875c5dfe4bd514fd7055fc7a89"
          },
          {
            "url": "https://git.kernel.org/stable/c/d1ffa4ae2d591fdd40471074e79954ec45f147f7"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35937",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:49.553",
        "lastModified": "2024-05-19T11:15:49.553",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nwifi: cfg80211: check A-MSDU format more carefully\nIf it looks like there's another subframe in the A-MSDU\nbut the header isn't fully there, we can end up reading\ndata out of bounds, only to discard later. Make this a\nbit more careful and check if the subframe header can\neven be present.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/16da1e1dac23be45ef6e23c41b1508c400e6c544"
          },
          {
            "url": "https://git.kernel.org/stable/c/5d7a8585fbb31e88fb2a0f581b70667d3300d1e9"
          },
          {
            "url": "https://git.kernel.org/stable/c/9ad7974856926129f190ffbe3beea78460b3b7cc"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35938",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:49.620",
        "lastModified": "2024-05-19T11:15:49.620",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nwifi: ath11k: decrease MHI channel buffer length to 8KB\nCurrently buf_len field of ath11k_mhi_config_qca6390 is assigned\nwith 0, making MHI use a default size, 64KB, to allocate channel\nbuffers. This is likely to fail in some scenarios where system\nmemory is highly fragmented and memory compaction or reclaim is\nnot allowed.\nThere is a fail report which is caused by it:\nkworker/u32:45: page allocation failure: order:4, mode:0x40c00(GFP_NOIO|__GFP_COMP), nodemask=(null),cpuset=/,mems_allowed=0\nCPU: 0 PID: 19318 Comm: kworker/u32:45 Not tainted 6.8.0-rc3-1.gae4495f-default #1 openSUSE Tumbleweed (unreleased) 493b6d5b382c603654d7a81fc3c144d59a1dfceb\nWorkqueue: events_unbound async_run_entry_fn\nCall Trace:\n <TASK>\n dump_stack_lvl+0x47/0x60\n warn_alloc+0x13a/0x1b0\n ? srso_alias_return_thunk+0x5/0xfbef5\n ? __alloc_pages_direct_compact+0xab/0x210\n __alloc_pages_slowpath.constprop.0+0xd3e/0xda0\n __alloc_pages+0x32d/0x350\n ? mhi_prepare_channel+0x127/0x2d0 [mhi 40df44e07c05479f7a6e7b90fba9f0e0031a7814]\n __kmalloc_large_node+0x72/0x110\n __kmalloc+0x37c/0x480\n ? mhi_map_single_no_bb+0x77/0xf0 [mhi 40df44e07c05479f7a6e7b90fba9f0e0031a7814]\n ? mhi_prepare_channel+0x127/0x2d0 [mhi 40df44e07c05479f7a6e7b90fba9f0e0031a7814]\n mhi_prepare_channel+0x127/0x2d0 [mhi 40df44e07c05479f7a6e7b90fba9f0e0031a7814]\n __mhi_prepare_for_transfer+0x44/0x80 [mhi 40df44e07c05479f7a6e7b90fba9f0e0031a7814]\n ? __pfx_____mhi_prepare_for_transfer+0x10/0x10 [mhi 40df44e07c05479f7a6e7b90fba9f0e0031a7814]\n device_for_each_child+0x5c/0xa0\n ? __pfx_pci_pm_resume+0x10/0x10\n ath11k_core_resume+0x65/0x100 [ath11k a5094e22d7223135c40d93c8f5321cf09fd85e4e]\n ? srso_alias_return_thunk+0x5/0xfbef5\n ath11k_pci_pm_resume+0x32/0x60 [ath11k_pci 830b7bfc3ea80ebef32e563cafe2cb55e9cc73ec]\n ? srso_alias_return_thunk+0x5/0xfbef5\n dpm_run_callback+0x8c/0x1e0\n device_resume+0x104/0x340\n ? __pfx_dpm_watchdog_handler+0x10/0x10\n async_resume+0x1d/0x30\n async_run_entry_fn+0x32/0x120\n process_one_work+0x168/0x330\n worker_thread+0x2f5/0x410\n ? __pfx_worker_thread+0x10/0x10\n kthread+0xe8/0x120\n ? __pfx_kthread+0x10/0x10\n ret_from_fork+0x34/0x50\n ? __pfx_kthread+0x10/0x10\n ret_from_fork_asm+0x1b/0x30\n </TASK>\nActually those buffers are used only by QMI target -> host communication.\nAnd for WCN6855 and QCA6390, the largest packet size for that is less\nthan 6KB. So change buf_len field to 8KB, which results in order 1\nallocation if page size is 4KB. In this way, we can at least save some\nmemory, and as well as decrease the possibility of allocation failure\nin those scenarios.\nTested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3.6510.30",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/138fdeac75fb7512a7f9f1c3b236cd2e754af793"
          },
          {
            "url": "https://git.kernel.org/stable/c/1cca1bddf9ef080503c15378cecf4877f7510015"
          },
          {
            "url": "https://git.kernel.org/stable/c/6597a6687af54e2cb58371cf8f6ee4dd85c537de"
          },
          {
            "url": "https://git.kernel.org/stable/c/805a1cdde82fec00c7471a393f4bb437b2741559"
          },
          {
            "url": "https://git.kernel.org/stable/c/ae5876b3b7b2243d874e2afa099e7926122087a1"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35939",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:49.690",
        "lastModified": "2024-05-19T11:15:49.690",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndma-direct: Leak pages on dma_set_decrypted() failure\nOn TDX it is possible for the untrusted host to cause\nset_memory_encrypted() or set_memory_decrypted() to fail such that an\nerror is returned and the resulting memory is shared. Callers need to\ntake care to handle these errors to avoid returning decrypted (shared)\nmemory to the page allocator, which could lead to functional or security\nissues.\nDMA could free decrypted/shared pages if dma_set_decrypted() fails. This\nshould be a rare case. Just leak the pages in this case instead of\nfreeing them.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4031b72ca747a1e6e9ae4fa729e765b43363d66a"
          },
          {
            "url": "https://git.kernel.org/stable/c/4e0cfb25d49da2e6261ad582f58ffa5b5dd8c8e9"
          },
          {
            "url": "https://git.kernel.org/stable/c/b57326c96b7bc7638aa8c44e12afa2defe0c934c"
          },
          {
            "url": "https://git.kernel.org/stable/c/b9fa16949d18e06bdf728a560f5c8af56d2bdcaf"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35940",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:49.757",
        "lastModified": "2024-05-19T11:15:49.757",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\npstore/zone: Add a null pointer check to the psz_kmsg_read\nkasprintf() returns a pointer to dynamically allocated memory\nwhich can be NULL upon failure. Ensure the allocation was successful\nby checking the pointer validity.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0ff96ec22a84d80a18d7ae8ca7eb111c34ee33bb"
          },
          {
            "url": "https://git.kernel.org/stable/c/635594cca59f9d7a8e96187600c34facb8bc0682"
          },
          {
            "url": "https://git.kernel.org/stable/c/6f9f2e498eae7897ba5d3e33908917f68ff4abcc"
          },
          {
            "url": "https://git.kernel.org/stable/c/98bc7e26e14fbb26a6abf97603d59532475e97f8"
          },
          {
            "url": "https://git.kernel.org/stable/c/98e2b97acb875d65bdfc75fc408e67975cef3041"
          },
          {
            "url": "https://git.kernel.org/stable/c/ec7256887d072f98c42cdbef4dcc80ddf84c7a70"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35941",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:49.823",
        "lastModified": "2024-05-19T11:15:49.823",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: skbuff: add overflow debug check to pull/push helpers\nsyzbot managed to trigger following splat:\nBUG: KASAN: use-after-free in __skb_flow_dissect+0x4a3b/0x5e50\nRead of size 1 at addr ffff888208a4000e by task a.out/2313\n[..]\n  __skb_flow_dissect+0x4a3b/0x5e50\n  __skb_get_hash+0xb4/0x400\n  ip_tunnel_xmit+0x77e/0x26f0\n  ipip_tunnel_xmit+0x298/0x410\n  ..\nAnalysis shows that the skb has a valid ->head, but bogus ->data\npointer.\nskb->data gets its bogus value via the neigh layer, which does:\n1556    __skb_pull(skb, skb_network_offset(skb));\n... and the skb was already dodgy at this point:\nskb_network_offset(skb) returns a negative value due to an\nearlier overflow of skb->network_header (u16).  __skb_pull thus\n\"adjusts\" skb->data by a huge offset, pointing outside skb->head\narea.\nAllow debug builds to splat when we try to pull/push more than\nINT_MAX bytes.\nAfter this, the syzkaller reproducer yields a more precise splat\nbefore the flow dissector attempts to read off skb->data memory:\nWARNING: CPU: 5 PID: 2313 at include/linux/skbuff.h:2653 neigh_connected_output+0x28e/0x400\n  ip_finish_output2+0xb25/0xed0\n  iptunnel_xmit+0x4ff/0x870\n  ipgre_xmit+0x78e/0xbb0",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1b2b26595bb09febf14c5444c873ac4ec90a5a77"
          },
          {
            "url": "https://git.kernel.org/stable/c/219eee9c0d16f1b754a8b85275854ab17df0850a"
          },
          {
            "url": "https://git.kernel.org/stable/c/8af60bb2b215f478b886f1d6d302fefa7f0b917d"
          },
          {
            "url": "https://git.kernel.org/stable/c/fff05b2b004d9a8a2416d08647f3dc9068e357c8"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35942",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:49.890",
        "lastModified": "2024-05-19T11:15:49.890",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\npmdomain: imx8mp-blk-ctrl: imx8mp_blk: Add fdcc clock to hdmimix domain\nAccording to i.MX8MP RM and HDMI ADD, the fdcc clock is part of\nhdmi rx verification IP that should not enable for HDMI TX.\nBut actually if the clock is disabled before HDMI/LCDIF probe,\nLCDIF will not get pixel clock from HDMI PHY and print the error\nlogs:\n[CRTC:39:crtc-2] vblank wait timed out\nWARNING: CPU: 2 PID: 9 at drivers/gpu/drm/drm_atomic_helper.c:1634 drm_atomic_helper_wait_for_vblanks.part.0+0x23c/0x260\nAdd fdcc clock to LCDIF and HDMI TX power domains to fix the issue.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/697624ee8ad557ab5417f985d2c804241a7ad30d"
          },
          {
            "url": "https://git.kernel.org/stable/c/9d3f959b426635c4da50dfc7b1306afd84d23e7c"
          },
          {
            "url": "https://git.kernel.org/stable/c/b13c0d871cd878ff53d25507ca535f59ed1f6a2a"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35943",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:49.953",
        "lastModified": "2024-05-19T11:15:49.953",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\npmdomain: ti: Add a null pointer check to the omap_prm_domain_init\ndevm_kasprintf() returns a pointer to dynamically allocated memory\nwhich can be NULL upon failure. Ensure the allocation was successful\nby checking the pointer validity.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/04f23510daa40f9010fadf309507564a34ad956f"
          },
          {
            "url": "https://git.kernel.org/stable/c/5d7f58ee08434a33340f75ac7ac5071eea9673b3"
          },
          {
            "url": "https://git.kernel.org/stable/c/ce666cecc09c0f92d5f86d89d8068ecfcf723a7e"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35944",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:50.017",
        "lastModified": "2024-05-19T11:15:50.017",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nVMCI: Fix memcpy() run-time warning in dg_dispatch_as_host()\nSyzkaller hit 'WARNING in dg_dispatch_as_host' bug.\nmemcpy: detected field-spanning write (size 56) of single field \"&dg_info->msg\"\nat drivers/misc/vmw_vmci/vmci_datagram.c:237 (size 24)\nWARNING: CPU: 0 PID: 1555 at drivers/misc/vmw_vmci/vmci_datagram.c:237\ndg_dispatch_as_host+0x88e/0xa60 drivers/misc/vmw_vmci/vmci_datagram.c:237\nSome code commentry, based on my understanding:\n544 #define VMCI_DG_SIZE(_dg) (VMCI_DG_HEADERSIZE + (size_t)(_dg)->payload_size)\n/// This is 24 + payload_size\nmemcpy(&dg_info->msg, dg, dg_size);\n\tDestination = dg_info->msg ---> this is a 24 byte\n\t\t\t\t\tstructure(struct vmci_datagram)\n\tSource = dg --> this is a 24 byte structure (struct vmci_datagram)\n\tSize = dg_size = 24 + payload_size\n{payload_size = 56-24 =32} -- Syzkaller managed to set payload_size to 32.\n 35 struct delayed_datagram_info {\n 36         struct datagram_entry *entry;\n 37         struct work_struct work;\n 38         bool in_dg_host_queue;\n 39         /* msg and msg_payload must be together. */\n 40         struct vmci_datagram msg;\n 41         u8 msg_payload[];\n 42 };\nSo those extra bytes of payload are copied into msg_payload[], a run time\nwarning is seen while fuzzing with Syzkaller.\nOne possible way to fix the warning is to split the memcpy() into\ntwo parts -- one -- direct assignment of msg and second taking care of payload.\nGustavo quoted:\n\"Under FORTIFY_SOURCE we should not copy data across multiple members\nin a structure.\"",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/130b0cd064874e0d0f58e18fb00e6f3993e90c74"
          },
          {
            "url": "https://git.kernel.org/stable/c/19b070fefd0d024af3daa7329cbc0d00de5302ec"
          },
          {
            "url": "https://git.kernel.org/stable/c/491a1eb07c2bd8841d63cb5263455e185be5866f"
          },
          {
            "url": "https://git.kernel.org/stable/c/ad78c5047dc4076d0b3c4fad4f42ffe9c86e8100"
          },
          {
            "url": "https://git.kernel.org/stable/c/dae70a57565686f16089737adb8ac64471570f73"
          },
          {
            "url": "https://git.kernel.org/stable/c/e87bb99d2df6512d8ee37a5d63d2ca9a39a8c051"
          },
          {
            "url": "https://git.kernel.org/stable/c/f15eca95138b3d4ec17b63c3c1937b0aa0d3624b"
          },
          {
            "url": "https://git.kernel.org/stable/c/feacd430b42bbfa9ab3ed9e4f38b86c43e348c75"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35945",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:50.110",
        "lastModified": "2024-05-19T11:15:50.110",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: phy: phy_device: Prevent nullptr exceptions on ISR\nIf phydev->irq is set unconditionally, check\nfor valid interrupt handler or fall back to polling mode to prevent\nnullptr exceptions in interrupt service routine.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3419ee39e3d3162ab2ec9942bb537613ed5b6311"
          },
          {
            "url": "https://git.kernel.org/stable/c/61c81872815f46006982bb80460c0c80a949b35b"
          },
          {
            "url": "https://git.kernel.org/stable/c/7a71f61ebf95cedd3f245db6da397822971d8db5"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35946",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-19T11:15:50.180",
        "lastModified": "2024-05-19T11:15:50.180",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nwifi: rtw89: fix null pointer access when abort scan\nDuring cancel scan we might use vif that weren't scanning.\nFix this by using the actual scanning vif.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4f11c741908dab7dd48fa5a986b210d4fc74ca8d"
          },
          {
            "url": "https://git.kernel.org/stable/c/7e11a2966f51695c0af0b1f976a32d64dee243b2"
          },
          {
            "url": "https://git.kernel.org/stable/c/b34d64e9aa5505e3c84570aed5c757f1839573e8"
          }
        ]
      }
    }
  ]
}