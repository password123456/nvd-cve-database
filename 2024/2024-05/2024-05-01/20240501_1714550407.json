{
  "totalResults": 106,
  "datePublished": "2024-05-01T17:00:07.221536Z",
  "vulnerabilities": [
    {
      "cve": {
        "id": "CVE-2023-52647",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:06.627",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmedia: nxp: imx8-isi: Check whether crossbar pad is non-NULL before access\nWhen translating source to sink streams in the crossbar subdev, the\ndriver tries to locate the remote subdev connected to the sink pad. The\nremote pad may be NULL, if userspace tries to enable a stream that ends\nat an unconnected crossbar sink. When that occurs, the driver\ndereferences the NULL pad, leading to a crash.\nPrevent the crash by checking if the pad is NULL before using it, and\nreturn an error if it is.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/91c8ce42fcde09f1da24acab9013b3e19cb88a4e"
          },
          {
            "url": "https://git.kernel.org/stable/c/c4bd29bf5b7f67925bc1abd16069f22dadf5f061"
          },
          {
            "url": "https://git.kernel.org/stable/c/c95318607fbe8fdd44991a8dad2e44118e6b8812"
          },
          {
            "url": "https://git.kernel.org/stable/c/eb2f932100288dbb881eadfed02e1459c6b9504c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2023-52648",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:07.217",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/vmwgfx: Unmap the surface before resetting it on a plane state\nSwitch to a new plane state requires unreferencing of all held surfaces.\nIn the work required for mob cursors the mapped surfaces started being\ncached but the variable indicating whether the surface is currently\nmapped was not being reset. This leads to crashes as the duplicated\nstate, incorrectly, indicates the that surface is mapped even when\nno surface is present. That's because after unreferencing the surface\nit's perfectly possible for the plane to be backed by a bo instead of a\nsurface.\nReset the surface mapped flag when unreferencing the plane state surface\nto fix null derefs in cleanup. Fixes crashes in KDE KWin 6.0 on Wayland:\nOops: 0000 [#1] PREEMPT SMP PTI\nCPU: 4 PID: 2533 Comm: kwin_wayland Not tainted 6.7.0-rc3-vmwgfx #2\nHardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020\nRIP: 0010:vmw_du_cursor_plane_cleanup_fb+0x124/0x140 [vmwgfx]\nCode: 00 00 00 75 3a 48 83 c4 10 5b 5d c3 cc cc cc cc 48 8b b3 a8 00 00 00 48 c7 c7 99 90 43 c0 e8 93 c5 db ca 48 8b 83 a8 00 00 00 <48> 8b 78 28 e8 e3 f>\nRSP: 0018:ffffb6b98216fa80 EFLAGS: 00010246\nRAX: 0000000000000000 RBX: ffff969d84cdcb00 RCX: 0000000000000027\nRDX: 0000000000000000 RSI: 0000000000000001 RDI: ffff969e75f21600\nRBP: ffff969d4143dc50 R08: 0000000000000000 R09: ffffb6b98216f920\nR10: 0000000000000003 R11: ffff969e7feb3b10 R12: 0000000000000000\nR13: 0000000000000000 R14: 000000000000027b R15: ffff969d49c9fc00\nFS:  00007f1e8f1b4180(0000) GS:ffff969e75f00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000000028 CR3: 0000000104006004 CR4: 00000000003706f0\nCall Trace:\n <TASK>\n ? __die+0x23/0x70\n ? page_fault_oops+0x171/0x4e0\n ? exc_page_fault+0x7f/0x180\n ? asm_exc_page_fault+0x26/0x30\n ? vmw_du_cursor_plane_cleanup_fb+0x124/0x140 [vmwgfx]\n drm_atomic_helper_cleanup_planes+0x9b/0xc0\n commit_tail+0xd1/0x130\n drm_atomic_helper_commit+0x11a/0x140\n drm_atomic_commit+0x97/0xd0\n ? __pfx___drm_printfn_info+0x10/0x10\n drm_atomic_helper_update_plane+0xf5/0x160\n drm_mode_cursor_universal+0x10e/0x270\n drm_mode_cursor_common+0x102/0x230\n ? __pfx_drm_mode_cursor2_ioctl+0x10/0x10\n drm_ioctl_kernel+0xb2/0x110\n drm_ioctl+0x26d/0x4b0\n ? __pfx_drm_mode_cursor2_ioctl+0x10/0x10\n ? __pfx_drm_ioctl+0x10/0x10\n vmw_generic_ioctl+0xa4/0x110 [vmwgfx]\n __x64_sys_ioctl+0x94/0xd0\n do_syscall_64+0x61/0xe0\n ? __x64_sys_ioctl+0xaf/0xd0\n ? syscall_exit_to_user_mode+0x2b/0x40\n ? do_syscall_64+0x70/0xe0\n ? __x64_sys_ioctl+0xaf/0xd0\n ? syscall_exit_to_user_mode+0x2b/0x40\n ? do_syscall_64+0x70/0xe0\n ? exc_page_fault+0x7f/0x180\n entry_SYSCALL_64_after_hwframe+0x6e/0x76\nRIP: 0033:0x7f1e93f279ed\nCode: 04 25 28 00 00 00 48 89 45 c8 31 c0 48 8d 45 10 c7 45 b0 10 00 00 00 48 89 45 b8 48 8d 45 d0 48 89 45 c0 b8 10 00 00 00 0f 05 <89> c2 3d 00 f0 ff f>\nRSP: 002b:00007ffca0faf600 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 000055db876ed2c0 RCX: 00007f1e93f279ed\nRDX: 00007ffca0faf6c0 RSI: 00000000c02464bb RDI: 0000000000000015\nRBP: 00007ffca0faf650 R08: 000055db87184010 R09: 0000000000000007\nR10: 000055db886471a0 R11: 0000000000000246 R12: 00007ffca0faf6c0\nR13: 00000000c02464bb R14: 0000000000000015 R15: 00007ffca0faf790\n </TASK>\nModules linked in: snd_seq_dummy snd_hrtimer nf_conntrack_netbios_ns nf_conntrack_broadcast nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_ine>\nCR2: 0000000000000028\n---[ end trace 0000000000000000 ]---\nRIP: 0010:vmw_du_cursor_plane_cleanup_fb+0x124/0x140 [vmwgfx]\nCode: 00 00 00 75 3a 48 83 c4 10 5b 5d c3 cc cc cc cc 48 8b b3 a8 00 00 00 48 c7 c7 99 90 43 c0 e8 93 c5 db ca 48 8b 83 a8 00 00 00 <48> 8b 78 28 e8 e3 f>\nRSP: 0018:ffffb6b98216fa80 EFLAGS: 00010246\nRAX: 0000000000000000 RBX: ffff969d84cdcb00 RCX: 0000000000000027\nRDX: 0000000000000000 RSI: 0000000000000001 RDI: ffff969e75f21600\nRBP: ffff969d4143\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0a23f95af7f28dae7c0f7c82578ca5e1a239d461"
          },
          {
            "url": "https://git.kernel.org/stable/c/105f72cc48c4c93f4578fcc61e06276471858e92"
          },
          {
            "url": "https://git.kernel.org/stable/c/27571c64f1855881753e6f33c3186573afbab7ba"
          },
          {
            "url": "https://git.kernel.org/stable/c/75baad63c033b3b900d822bffbc96c9d3649bc75"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26929",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:07.380",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nscsi: qla2xxx: Fix double free of fcport\nThe server was crashing after LOGO because fcport was getting freed twice.\n -----------[ cut here ]-----------\n kernel BUG at mm/slub.c:371!\n invalid opcode: 0000 1 SMP PTI\n CPU: 35 PID: 4610 Comm: bash Kdump: loaded Tainted: G OE --------- - - 4.18.0-425.3.1.el8.x86_64 #1\n Hardware name: HPE ProLiant DL360 Gen10/ProLiant DL360 Gen10, BIOS U32 09/03/2021\n RIP: 0010:set_freepointer.part.57+0x0/0x10\n RSP: 0018:ffffb07107027d90 EFLAGS: 00010246\n RAX: ffff9cb7e3150000 RBX: ffff9cb7e332b9c0 RCX: ffff9cb7e3150400\n RDX: 0000000000001f37 RSI: 0000000000000000 RDI: ffff9cb7c0005500\n RBP: fffff693448c5400 R08: 0000000080000000 R09: 0000000000000009\n R10: 0000000000000000 R11: 0000000000132af0 R12: ffff9cb7c0005500\n R13: ffff9cb7e3150000 R14: ffffffffc06990e0 R15: ffff9cb7ea85ea58\n FS: 00007ff6b79c2740(0000) GS:ffff9cb8f7ec0000(0000) knlGS:0000000000000000\n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 000055b426b7d700 CR3: 0000000169c18002 CR4: 00000000007706e0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n PKRU: 55555554\n Call Trace:\n kfree+0x238/0x250\n qla2x00_els_dcmd_sp_free+0x20/0x230 [qla2xxx]\n ? qla24xx_els_dcmd_iocb+0x607/0x690 [qla2xxx]\n qla2x00_issue_logo+0x28c/0x2a0 [qla2xxx]\n ? qla2x00_issue_logo+0x28c/0x2a0 [qla2xxx]\n ? kernfs_fop_write+0x11e/0x1a0\nRemove one of the free calls and add check for valid fcport. Also use\nfunction qla2x00_free_fcport() instead of kfree().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/282877633b25d67021a34169c5b5519b1d4ef65e"
          },
          {
            "url": "https://git.kernel.org/stable/c/82f522ae0d97119a43da53e0f729275691b9c525"
          },
          {
            "url": "https://git.kernel.org/stable/c/846fb9f112f618ec6ae181d8dae7961652574774"
          },
          {
            "url": "https://git.kernel.org/stable/c/9b43d2884b54d415caab48878b526dfe2ae9921b"
          },
          {
            "url": "https://git.kernel.org/stable/c/b03e626bd6d3f0684f56ee1890d70fc9ca991c04"
          },
          {
            "url": "https://git.kernel.org/stable/c/f85af9f1aa5e2f53694a6cbe72010f754b5ff862"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26930",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:07.540",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nscsi: qla2xxx: Fix double free of the ha->vp_map pointer\nCoverity scan reported potential risk of double free of the pointer\nha->vp_map.  ha->vp_map was freed in qla2x00_mem_alloc(), and again freed\nin function qla2x00_mem_free(ha).\nAssign NULL to vp_map and kfree take care of NULL.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/825d63164a2e6bacb059a9afb5605425b485413f"
          },
          {
            "url": "https://git.kernel.org/stable/c/b7deb675d674f44e0ddbab87fee8f9f098925e73"
          },
          {
            "url": "https://git.kernel.org/stable/c/e288285d47784fdcf7c81be56df7d65c6f10c58b"
          },
          {
            "url": "https://git.kernel.org/stable/c/f14cee7a882cb79528f17a2335f53e9fd1848467"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26931",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:07.673",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nscsi: qla2xxx: Fix command flush on cable pull\nSystem crash due to command failed to flush back to SCSI layer.\n BUG: unable to handle kernel NULL pointer dereference at 0000000000000000\n PGD 0 P4D 0\n Oops: 0000 [#1] SMP NOPTI\n CPU: 27 PID: 793455 Comm: kworker/u130:6 Kdump: loaded Tainted: G           OE    --------- -  - 4.18.0-372.9.1.el8.x86_64 #1\n Hardware name: HPE ProLiant DL360 Gen10/ProLiant DL360 Gen10, BIOS U32 09/03/2021\n Workqueue: nvme-wq nvme_fc_connect_ctrl_work [nvme_fc]\n RIP: 0010:__wake_up_common+0x4c/0x190\n Code: 24 10 4d 85 c9 74 0a 41 f6 01 04 0f 85 9d 00 00 00 48 8b 43 08 48 83 c3 08 4c 8d 48 e8 49 8d 41 18 48 39 c3 0f 84 f0 00 00 00 <49> 8b 41 18 89 54 24 08 31 ed 4c 8d 70 e8 45 8b 29 41 f6 c5 04 75\n RSP: 0018:ffff95f3e0cb7cd0 EFLAGS: 00010086\n RAX: 0000000000000000 RBX: ffff8b08d3b26328 RCX: 0000000000000000\n RDX: 0000000000000001 RSI: 0000000000000003 RDI: ffff8b08d3b26320\n RBP: 0000000000000001 R08: 0000000000000000 R09: ffffffffffffffe8\n R10: 0000000000000000 R11: ffff95f3e0cb7a60 R12: ffff95f3e0cb7d20\n R13: 0000000000000003 R14: 0000000000000000 R15: 0000000000000000\n FS:  0000000000000000(0000) GS:ffff8b2fdf6c0000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000000000000 CR3: 0000002f1e410002 CR4: 00000000007706e0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n PKRU: 55555554\n Call Trace:\n  __wake_up_common_lock+0x7c/0xc0\n  qla_nvme_ls_req+0x355/0x4c0 [qla2xxx]\n qla2xxx [0000:12:00.1]-f084:3: qlt_free_session_done: se_sess 0000000000000000 / sess ffff8ae1407ca000 from port 21:32:00:02:ac:07:ee:b8 loop_id 0x02 s_id 01:02:00 logout 1 keep 0 els_logo 0\n ? __nvme_fc_send_ls_req+0x260/0x380 [nvme_fc]\n qla2xxx [0000:12:00.1]-207d:3: FCPort 21:32:00:02:ac:07:ee:b8 state transitioned from ONLINE to LOST - portid=010200.\n  ? nvme_fc_send_ls_req.constprop.42+0x1a/0x45 [nvme_fc]\n qla2xxx [0000:12:00.1]-2109:3: qla2x00_schedule_rport_del 21320002ac07eeb8. rport ffff8ae598122000 roles 1\n ? nvme_fc_connect_ctrl_work.cold.63+0x1e3/0xa7d [nvme_fc]\n qla2xxx [0000:12:00.1]-f084:3: qlt_free_session_done: se_sess 0000000000000000 / sess ffff8ae14801e000 from port 21:32:01:02:ad:f7:ee:b8 loop_id 0x04 s_id 01:02:01 logout 1 keep 0 els_logo 0\n  ? __switch_to+0x10c/0x450\n ? process_one_work+0x1a7/0x360\n qla2xxx [0000:12:00.1]-207d:3: FCPort 21:32:01:02:ad:f7:ee:b8 state transitioned from ONLINE to LOST - portid=010201.\n  ? worker_thread+0x1ce/0x390\n  ? create_worker+0x1a0/0x1a0\n qla2xxx [0000:12:00.1]-2109:3: qla2x00_schedule_rport_del 21320102adf7eeb8. rport ffff8ae3b2312800 roles 70\n  ? kthread+0x10a/0x120\n qla2xxx [0000:12:00.1]-2112:3: qla_nvme_unregister_remote_port: unregister remoteport on ffff8ae14801e000 21320102adf7eeb8\n  ? set_kthread_struct+0x40/0x40\n qla2xxx [0000:12:00.1]-2110:3: remoteport_delete of ffff8ae14801e000 21320102adf7eeb8 completed.\n  ? ret_from_fork+0x1f/0x40\n qla2xxx [0000:12:00.1]-f086:3: qlt_free_session_done: waiting for sess ffff8ae14801e000 logout\nThe system was under memory stress where driver was not able to allocate an\nSRB to carry out error recovery of cable pull.  The failure to flush causes\nupper layer to start modifying scsi_cmnd.  When the system frees up some\nmemory, the subsequent cable pull trigger another command flush. At this\npoint the driver access a null pointer when attempting to DMA unmap the\nSGL.\nAdd a check to make sure commands are flush back on session tear down to\nprevent the null pointer access.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/09c0ac18cac206ed1218b1fe6c1a0918e5ea9211"
          },
          {
            "url": "https://git.kernel.org/stable/c/67b2d35853c2da25a8ca1c4190a5e96d3083c2ac"
          },
          {
            "url": "https://git.kernel.org/stable/c/8de1584ec4fe0ebea33c273036e7e0a05e65c81d"
          },
          {
            "url": "https://git.kernel.org/stable/c/8f0d32004e3a572bb77e6c11c2797c87f8c9703d"
          },
          {
            "url": "https://git.kernel.org/stable/c/a27d4d0e7de305def8a5098a614053be208d1aa1"
          },
          {
            "url": "https://git.kernel.org/stable/c/a859f6a8f4234b8ef62862bf7a92f1af5f8cd47a"
          },
          {
            "url": "https://git.kernel.org/stable/c/b73377124f56d2fec154737c2f8d2e839c237d5a"
          },
          {
            "url": "https://git.kernel.org/stable/c/d7a68eee87b05d4e29419e6f151aef99314970a9"
          },
          {
            "url": "https://git.kernel.org/stable/c/ec7587eef003cab15a13446d67c3adb88146a150"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26932",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:07.810",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nusb: typec: tcpm: fix double-free issue in tcpm_port_unregister_pd()\nWhen unregister pd capabilitie in tcpm, KASAN will capture below double\n-free issue. The root cause is the same capabilitiy will be kfreed twice,\nthe first time is kfreed by pd_capabilities_release() and the second time\nis explicitly kfreed by tcpm_port_unregister_pd().\n[    3.988059] BUG: KASAN: double-free in tcpm_port_unregister_pd+0x1a4/0x3dc\n[    3.995001] Free of addr ffff0008164d3000 by task kworker/u16:0/10\n[    4.001206]\n[    4.002712] CPU: 2 PID: 10 Comm: kworker/u16:0 Not tainted 6.8.0-rc5-next-20240220-05616-g52728c567a55 #53\n[    4.012402] Hardware name: Freescale i.MX8QXP MEK (DT)\n[    4.017569] Workqueue: events_unbound deferred_probe_work_func\n[    4.023456] Call trace:\n[    4.025920]  dump_backtrace+0x94/0xec\n[    4.029629]  show_stack+0x18/0x24\n[    4.032974]  dump_stack_lvl+0x78/0x90\n[    4.036675]  print_report+0xfc/0x5c0\n[    4.040289]  kasan_report_invalid_free+0xa0/0xc0\n[    4.044937]  __kasan_slab_free+0x124/0x154\n[    4.049072]  kfree+0xb4/0x1e8\n[    4.052069]  tcpm_port_unregister_pd+0x1a4/0x3dc\n[    4.056725]  tcpm_register_port+0x1dd0/0x2558\n[    4.061121]  tcpci_register_port+0x420/0x71c\n[    4.065430]  tcpci_probe+0x118/0x2e0\nTo fix the issue, this will remove kree() from tcpm_port_unregister_pd().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/242e425ed580b2f4dbcb86c8fc03a410a4084a69"
          },
          {
            "url": "https://git.kernel.org/stable/c/b63f90487bdf93a4223ce7853d14717e9d452856"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26933",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:07.930",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nUSB: core: Fix deadlock in port \"disable\" sysfs attribute\nThe show and store callback routines for the \"disable\" sysfs attribute\nfile in port.c acquire the device lock for the port's parent hub\ndevice.  This can cause problems if another process has locked the hub\nto remove it or change its configuration:\n\tRemoving the hub or changing its configuration requires the\n\thub interface to be removed, which requires the port device\n\tto be removed, and device_del() waits until all outstanding\n\tsysfs attribute callbacks for the ports have returned.  The\n\tlock can't be released until then.\n\tBut the disable_show() or disable_store() routine can't return\n\tuntil after it has acquired the lock.\nThe resulting deadlock can be avoided by calling\nsysfs_break_active_protection().  This will cause the sysfs core not\nto wait for the attribute's callback routine to return, allowing the\nremoval to proceed.  The disadvantage is that after making this call,\nthere is no guarantee that the hub structure won't be deallocated at\nany moment.  To prevent this, we have to acquire a reference to it\nfirst by calling hub_get().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4facc9421117ba9d8148c73771b213887fec77f7"
          },
          {
            "url": "https://git.kernel.org/stable/c/73d1589b91f2099e5f6534a8497b7c6b527e064e"
          },
          {
            "url": "https://git.kernel.org/stable/c/9dac54f08198147f5ec0ec52fcf1bc8ac899ac05"
          },
          {
            "url": "https://git.kernel.org/stable/c/f4d1960764d8a70318b02f15203a1be2b2554ca1"
          },
          {
            "url": "https://git.kernel.org/stable/c/f51849833705dea5b4f9b0c8de714dd87bd6c95c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26934",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:08.090",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nUSB: core: Fix deadlock in usb_deauthorize_interface()\nAmong the attribute file callback routines in\ndrivers/usb/core/sysfs.c, the interface_authorized_store() function is\nthe only one which acquires a device lock on an ancestor device: It\ncalls usb_deauthorize_interface(), which locks the interface's parent\nUSB device.\nThe will lead to deadlock if another process already owns that lock\nand tries to remove the interface, whether through a configuration\nchange or because the device has been disconnected.  As part of the\nremoval procedure, device_del() waits for all ongoing sysfs attribute\ncallbacks to complete.  But usb_deauthorize_interface() can't complete\nuntil the device lock has been released, and the lock won't be\nreleased until the removal has finished.\nThe mechanism provided by sysfs to prevent this kind of deadlock is\nto use the sysfs_break_active_protection() function, which tells sysfs\nnot to wait for the attribute callback.\nReported-and-tested by: Yue Sun <samsun1006219@gmail.com>\nReported by: xingwei lee <xrivendell7@gmail.com>",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/07acf979da33c721357ff27129edf74c23c036c6"
          },
          {
            "url": "https://git.kernel.org/stable/c/122a06f1068bf5e39089863f4f60b1f5d4273384"
          },
          {
            "url": "https://git.kernel.org/stable/c/12d6a5681a0a5cecc2af7860f0a1613fa7c6e947"
          },
          {
            "url": "https://git.kernel.org/stable/c/1b175bc579f46520b11ecda443bcd2ee4904f66a"
          },
          {
            "url": "https://git.kernel.org/stable/c/80ba43e9f799cbdd83842fc27db667289b3150f5"
          },
          {
            "url": "https://git.kernel.org/stable/c/8cbdd324b41528994027128207fae8100dff094f"
          },
          {
            "url": "https://git.kernel.org/stable/c/ab062fa3dc69aea88fe62162c5881ba14b50ecc5"
          },
          {
            "url": "https://git.kernel.org/stable/c/dbdf66250d2d33e8b27352fcb901de79f3521057"
          },
          {
            "url": "https://git.kernel.org/stable/c/e451709573f8be904a8a72d0775bf114d7c291d9"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26935",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:08.240",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nscsi: core: Fix unremoved procfs host directory regression\nCommit fc663711b944 (\"scsi: core: Remove the /proc/scsi/${proc_name}\ndirectory earlier\") fixed a bug related to modules loading/unloading, by\nadding a call to scsi_proc_hostdir_rm() on scsi_remove_host(). But that led\nto a potential duplicate call to the hostdir_rm() routine, since it's also\ncalled from scsi_host_dev_release(). That triggered a regression report,\nwhich was then fixed by commit be03df3d4bfe (\"scsi: core: Fix a procfs host\ndirectory removal regression\"). The fix just dropped the hostdir_rm() call\nfrom dev_release().\nBut it happens that this proc directory is created on scsi_host_alloc(),\nand that function \"pairs\" with scsi_host_dev_release(), while\nscsi_remove_host() pairs with scsi_add_host(). In other words, it seems the\nreason for removing the proc directory on dev_release() was meant to cover\ncases in which a SCSI host structure was allocated, but the call to\nscsi_add_host() didn't happen. And that pattern happens to exist in some\nerror paths, for example.\nSyzkaller causes that by using USB raw gadget device, error'ing on\nusb-storage driver, at usb_stor_probe2(). By checking that path, we can see\nthat the BadDevice label leads to a scsi_host_put() after a SCSI host\nallocation, but there's no call to scsi_add_host() in such path. That leads\nto messages like this in dmesg (and a leak of the SCSI host proc\nstructure):\nusb-storage 4-1:87.51: USB Mass Storage device detected\nproc_dir_entry 'scsi/usb-storage' already registered\nWARNING: CPU: 1 PID: 3519 at fs/proc/generic.c:377 proc_register+0x347/0x4e0 fs/proc/generic.c:376\nThe proper fix seems to still call scsi_proc_hostdir_rm() on dev_release(),\nbut guard that with the state check for SHOST_CREATED; there is even a\ncomment in scsi_host_dev_release() detailing that: such conditional is\nmeant for cases where the SCSI host was allocated but there was no calls to\n{add,remove}_host(), like the usb-storage case.\nThis is what we propose here and with that, the error path of usb-storage\ndoes not trigger the warning anymore.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0053f15d50d50c9312d8ab9c11e2e405812dfcac"
          },
          {
            "url": "https://git.kernel.org/stable/c/3678cf67ff7136db1dd3bf63c361650db5d92889"
          },
          {
            "url": "https://git.kernel.org/stable/c/5c2386ba80e779a92ec3bb64ccadbedd88f779b1"
          },
          {
            "url": "https://git.kernel.org/stable/c/cea234bb214b17d004dfdccce4491e6ff57c96ee"
          },
          {
            "url": "https://git.kernel.org/stable/c/d4c34782b6d7b1e68d18d9549451b19433bd4c6c"
          },
          {
            "url": "https://git.kernel.org/stable/c/e293c773c13b830cdc251f155df2254981abc320"
          },
          {
            "url": "https://git.kernel.org/stable/c/f23a4d6e07570826fe95023ca1aa96a011fa9f84"
          },
          {
            "url": "https://git.kernel.org/stable/c/f4ff08fab66eb5c0b97e1a24edac052fb40bf5d7"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26936",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:08.833",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nksmbd: validate request buffer size in smb2_allocate_rsp_buf()\nThe response buffer should be allocated in smb2_allocate_rsp_buf\nbefore validating request. But the fields in payload as well as smb2 header\nis used in smb2_allocate_rsp_buf(). This patch add simple buffer size\nvalidation to avoid potencial out-of-bounds in request buffer.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/17cf0c2794bdb6f39671265aa18aea5c22ee8c4a"
          },
          {
            "url": "https://git.kernel.org/stable/c/21ff9d7d223c5c19cb4334009e4c0c83a2f4d674"
          },
          {
            "url": "https://git.kernel.org/stable/c/2c27a64a2bc47d9bfc7c3cf8be14be53b1ee7cb6"
          },
          {
            "url": "https://git.kernel.org/stable/c/5c20b242d4fed73a93591e48bfd9772e2322fb11"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26937",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:08.960",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/i915/gt: Reset queue_priority_hint on parking\nOriginally, with strict in order execution, we could complete execution\nonly when the queue was empty. Preempt-to-busy allows replacement of an\nactive request that may complete before the preemption is processed by\nHW. If that happens, the request is retired from the queue, but the\nqueue_priority_hint remains set, preventing direct submission until\nafter the next CS interrupt is processed.\nThis preempt-to-busy race can be triggered by the heartbeat, which will\nalso act as the power-management barrier and upon completion allow us to\nidle the HW. We may process the completion of the heartbeat, and begin\nparking the engine before the CS event that restores the\nqueue_priority_hint, causing us to fail the assertion that it is MIN.\n<3>[  166.210729] __engine_park:283 GEM_BUG_ON(engine->sched_engine->queue_priority_hint != (-((int)(~0U >> 1)) - 1))\n<0>[  166.210781] Dumping ftrace buffer:\n<0>[  166.210795] ---------------------------------\n...\n<0>[  167.302811] drm_fdin-1097      2..s1. 165741070us : trace_ports: 0000:00:02.0 rcs0: promote { ccid:20 1217:2 prio 0 }\n<0>[  167.302861] drm_fdin-1097      2d.s2. 165741072us : execlists_submission_tasklet: 0000:00:02.0 rcs0: preempting last=1217:2, prio=0, hint=2147483646\n<0>[  167.302928] drm_fdin-1097      2d.s2. 165741072us : __i915_request_unsubmit: 0000:00:02.0 rcs0: fence 1217:2, current 0\n<0>[  167.302992] drm_fdin-1097      2d.s2. 165741073us : __i915_request_submit: 0000:00:02.0 rcs0: fence 3:4660, current 4659\n<0>[  167.303044] drm_fdin-1097      2d.s1. 165741076us : execlists_submission_tasklet: 0000:00:02.0 rcs0: context:3 schedule-in, ccid:40\n<0>[  167.303095] drm_fdin-1097      2d.s1. 165741077us : trace_ports: 0000:00:02.0 rcs0: submit { ccid:40 3:4660* prio 2147483646 }\n<0>[  167.303159] kworker/-89       11..... 165741139us : i915_request_retire.part.0: 0000:00:02.0 rcs0: fence c90:2, current 2\n<0>[  167.303208] kworker/-89       11..... 165741148us : __intel_context_do_unpin: 0000:00:02.0 rcs0: context:c90 unpin\n<0>[  167.303272] kworker/-89       11..... 165741159us : i915_request_retire.part.0: 0000:00:02.0 rcs0: fence 1217:2, current 2\n<0>[  167.303321] kworker/-89       11..... 165741166us : __intel_context_do_unpin: 0000:00:02.0 rcs0: context:1217 unpin\n<0>[  167.303384] kworker/-89       11..... 165741170us : i915_request_retire.part.0: 0000:00:02.0 rcs0: fence 3:4660, current 4660\n<0>[  167.303434] kworker/-89       11d..1. 165741172us : __intel_context_retire: 0000:00:02.0 rcs0: context:1216 retire runtime: { total:56028ns, avg:56028ns }\n<0>[  167.303484] kworker/-89       11..... 165741198us : __engine_park: 0000:00:02.0 rcs0: parked\n<0>[  167.303534]   <idle>-0         5d.H3. 165741207us : execlists_irq_handler: 0000:00:02.0 rcs0: semaphore yield: 00000040\n<0>[  167.303583] kworker/-89       11..... 165741397us : __intel_context_retire: 0000:00:02.0 rcs0: context:1217 retire runtime: { total:325575ns, avg:0ns }\n<0>[  167.303756] kworker/-89       11..... 165741777us : __intel_context_retire: 0000:00:02.0 rcs0: context:c90 retire runtime: { total:0ns, avg:0ns }\n<0>[  167.303806] kworker/-89       11..... 165742017us : __engine_park: __engine_park:283 GEM_BUG_ON(engine->sched_engine->queue_priority_hint != (-((int)(~0U >> 1)) - 1))\n<0>[  167.303811] ---------------------------------\n<4>[  167.304722] ------------[ cut here ]------------\n<2>[  167.304725] kernel BUG at drivers/gpu/drm/i915/gt/intel_engine_pm.c:283!\n<4>[  167.304731] invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\n<4>[  167.304734] CPU: 11 PID: 89 Comm: kworker/11:1 Tainted: G        W          6.8.0-rc2-CI_DRM_14193-gc655e0fd2804+ #1\n<4>[  167.304736] Hardware name: Intel Corporation Rocket Lake Client Platform/RocketLake S UDIMM 6L RVP, BIOS RKLSFWI1.R00.3173.A03.2204210138 04/21/2022\n<4>[  167.304738] Workqueue: i915-unordered retire_work_handler [i915]\n<4>[  16\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3b031e4fcb2740988143c303f81f69f18ce86325"
          },
          {
            "url": "https://git.kernel.org/stable/c/4a3859ea5240365d21f6053ee219bb240d520895"
          },
          {
            "url": "https://git.kernel.org/stable/c/67944e6db656bf1e986aa2a359f866f851091f8a"
          },
          {
            "url": "https://git.kernel.org/stable/c/7eab7b021835ae422c38b968d5cc60e99408fb62"
          },
          {
            "url": "https://git.kernel.org/stable/c/8fd9b0ce8c26533fe4d5d15ea15bbf7b904b611c"
          },
          {
            "url": "https://git.kernel.org/stable/c/ac9b6b3e8d1237136c8ebf0fa1ce037dd7e2948f"
          },
          {
            "url": "https://git.kernel.org/stable/c/aed034866a08bb7e6e34d50a5629a4d23fe83703"
          },
          {
            "url": "https://git.kernel.org/stable/c/fe34587acc995e7b1d7a5d3444a0736721ec32b3"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26938",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:09.077",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/i915/bios: Tolerate devdata==NULL in intel_bios_encoder_supports_dp_dual_mode()\nIf we have no VBT, or the VBT didn't declare the encoder\nin question, we won't have the 'devdata' for the encoder.\nInstead of oopsing just bail early.\nWe won't be able to tell whether the port is DP++ or not,\nbut so be it.\n(cherry picked from commit 26410896206342c8a80d2b027923e9ee7d33b733)",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/32e39bab59934bfd3f37097d4dd85ac5eb0fd549"
          },
          {
            "url": "https://git.kernel.org/stable/c/72e4d3fb72e9f0f016946158a7d95304832768e6"
          },
          {
            "url": "https://git.kernel.org/stable/c/94cf2fb6feccd625e5b4e23e1b70f39a206f82ac"
          },
          {
            "url": "https://git.kernel.org/stable/c/a891add409e3bc381f4f68c2ce9d953f1865cb1f"
          },
          {
            "url": "https://git.kernel.org/stable/c/f4bbac954d8f9ab214ea1d4f385de4fa6bd92dd0"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26939",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:09.193",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/i915/vma: Fix UAF on destroy against retire race\nObject debugging tools were sporadically reporting illegal attempts to\nfree a still active i915 VMA object when parking a GT believed to be idle.\n[161.359441] ODEBUG: free active (active state 0) object: ffff88811643b958 object type: i915_active hint: __i915_vma_active+0x0/0x50 [i915]\n[161.360082] WARNING: CPU: 5 PID: 276 at lib/debugobjects.c:514 debug_print_object+0x80/0xb0\n...\n[161.360304] CPU: 5 PID: 276 Comm: kworker/5:2 Not tainted 6.5.0-rc1-CI_DRM_13375-g003f860e5577+ #1\n[161.360314] Hardware name: Intel Corporation Rocket Lake Client Platform/RocketLake S UDIMM 6L RVP, BIOS RKLSFWI1.R00.3173.A03.2204210138 04/21/2022\n[161.360322] Workqueue: i915-unordered __intel_wakeref_put_work [i915]\n[161.360592] RIP: 0010:debug_print_object+0x80/0xb0\n...\n[161.361347] debug_object_free+0xeb/0x110\n[161.361362] i915_active_fini+0x14/0x130 [i915]\n[161.361866] release_references+0xfe/0x1f0 [i915]\n[161.362543] i915_vma_parked+0x1db/0x380 [i915]\n[161.363129] __gt_park+0x121/0x230 [i915]\n[161.363515] ____intel_wakeref_put_last+0x1f/0x70 [i915]\nThat has been tracked down to be happening when another thread is\ndeactivating the VMA inside __active_retire() helper, after the VMA's\nactive counter has been already decremented to 0, but before deactivation\nof the VMA's object is reported to the object debugging tool.\nWe could prevent from that race by serializing i915_active_fini() with\n__active_retire() via ref->tree_lock, but that wouldn't stop the VMA from\nbeing used, e.g. from __i915_vma_retire() called at the end of\n__active_retire(), after that VMA has been already freed by a concurrent\ni915_vma_destroy() on return from the i915_active_fini().  Then, we should\nrather fix the issue at the VMA level, not in i915_active.\nSince __i915_vma_parked() is called from __gt_park() on last put of the\nGT's wakeref, the issue could be addressed by holding the GT wakeref long\nenough for __active_retire() to complete before that wakeref is released\nand the GT parked.\nI believe the issue was introduced by commit d93939730347 (\"drm/i915:\nRemove the vma refcount\") which moved a call to i915_active_fini() from\na dropped i915_vma_release(), called on last put of the removed VMA kref,\nto i915_vma_parked() processing path called on last put of a GT wakeref.\nHowever, its visibility to the object debugging tool was suppressed by a\nbug in i915_active that was fixed two weeks later with commit e92eb246feb9\n(\"drm/i915/active: Fix missing debug object activation\").\nA VMA associated with a request doesn't acquire a GT wakeref by itself.\nInstead, it depends on a wakeref held directly by the request's active\nintel_context for a GT associated with its VM, and indirectly on that\nintel_context's engine wakeref if the engine belongs to the same GT as the\nVMA's VM.  Those wakerefs are released asynchronously to VMA deactivation.\nFix the issue by getting a wakeref for the VMA's GT when activating it,\nand putting that wakeref only after the VMA is deactivated.  However,\nexclude global GTT from that processing path, otherwise the GPU never goes\nidle.  Since __i915_vma_retire() may be called from atomic contexts, use\nasync variant of wakeref put.  Also, to avoid circular locking dependency,\ntake care of acquiring the wakeref before VM mutex when both are needed.\nv7: Add inline comments with justifications for:\n    - using untracked variants of intel_gt_pm_get/put() (Nirmoy),\n    - using async variant of _put(),\n    - not getting the wakeref in case of a global GTT,\n    - always getting the first wakeref outside vm->mutex.\nv6: Since __i915_vma_active/retire() callbacks are not serialized, storing\n    a wakeref tracking handle inside struct i915_vma is not safe, and\n    there is no other good place for that.  Use untracked variants of\n    intel_gt_pm_get/put_async().\nv5: Replace \"tile\" with \"GT\" across commit description (Rodrigo),\n  - \n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0e45882ca829b26b915162e8e86dbb1095768e9e"
          },
          {
            "url": "https://git.kernel.org/stable/c/59b2626dd8c8a2e13f18054b3530e0c00073d79f"
          },
          {
            "url": "https://git.kernel.org/stable/c/5e3eb862df9f972ab677fb19e0d4b9b1be8db7b5"
          },
          {
            "url": "https://git.kernel.org/stable/c/704edc9252f4988ae1ad7dafa23d0db8d90d7190"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26940",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:09.343",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/vmwgfx: Create debugfs ttm_resource_manager entry only if needed\nThe driver creates /sys/kernel/debug/dri/0/mob_ttm even when the\ncorresponding ttm_resource_manager is not allocated.\nThis leads to a crash when trying to read from this file.\nAdd a check to create mob_ttm, system_mob_ttm, and gmr_ttm debug file\nonly when the corresponding ttm_resource_manager is allocated.\ncrash> bt\nPID: 3133409  TASK: ffff8fe4834a5000  CPU: 3    COMMAND: \"grep\"\n #0 [ffffb954506b3b20] machine_kexec at ffffffffb2a6bec3\n #1 [ffffb954506b3b78] __crash_kexec at ffffffffb2bb598a\n #2 [ffffb954506b3c38] crash_kexec at ffffffffb2bb68c1\n #3 [ffffb954506b3c50] oops_end at ffffffffb2a2a9b1\n #4 [ffffb954506b3c70] no_context at ffffffffb2a7e913\n #5 [ffffb954506b3cc8] __bad_area_nosemaphore at ffffffffb2a7ec8c\n #6 [ffffb954506b3d10] do_page_fault at ffffffffb2a7f887\n #7 [ffffb954506b3d40] page_fault at ffffffffb360116e\n    [exception RIP: ttm_resource_manager_debug+0x11]\n    RIP: ffffffffc04afd11  RSP: ffffb954506b3df0  RFLAGS: 00010246\n    RAX: ffff8fe41a6d1200  RBX: 0000000000000000  RCX: 0000000000000940\n    RDX: 0000000000000000  RSI: ffffffffc04b4338  RDI: 0000000000000000\n    RBP: ffffb954506b3e08   R8: ffff8fee3ffad000   R9: 0000000000000000\n    R10: ffff8fe41a76a000  R11: 0000000000000001  R12: 00000000ffffffff\n    R13: 0000000000000001  R14: ffff8fe5bb6f3900  R15: ffff8fe41a6d1200\n    ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018\n #8 [ffffb954506b3e00] ttm_resource_manager_show at ffffffffc04afde7 [ttm]\n #9 [ffffb954506b3e30] seq_read at ffffffffb2d8f9f3\n    RIP: 00007f4c4eda8985  RSP: 00007ffdbba9e9f8  RFLAGS: 00000246\n    RAX: ffffffffffffffda  RBX: 000000000037e000  RCX: 00007f4c4eda8985\n    RDX: 000000000037e000  RSI: 00007f4c41573000  RDI: 0000000000000003\n    RBP: 000000000037e000   R8: 0000000000000000   R9: 000000000037fe30\n    R10: 0000000000000000  R11: 0000000000000246  R12: 00007f4c41573000\n    R13: 0000000000000003  R14: 00007f4c41572010  R15: 0000000000000003\n    ORIG_RAX: 0000000000000000  CS: 0033  SS: 002b",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/016119154981d81c9e8f2ea3f56b9e2b4ea14500"
          },
          {
            "url": "https://git.kernel.org/stable/c/042ef0afc40fa1a22b3608f22915b91ce39d128f"
          },
          {
            "url": "https://git.kernel.org/stable/c/25e3ce59c1200f1f0563e39de151f34962ab0fe1"
          },
          {
            "url": "https://git.kernel.org/stable/c/4be9075fec0a639384ed19975634b662bfab938f"
          },
          {
            "url": "https://git.kernel.org/stable/c/eb08db0fc5354fa17b7ed66dab3c503332423451"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26941",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:09.487",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/dp: Fix divide-by-zero regression on DP MST unplug with nouveau\nFix a regression when using nouveau and unplugging a StarTech MSTDP122DP\nDisplayPort 1.2 MST hub (the same regression does not appear when using\na Cable Matters DisplayPort 1.4 MST hub). Trace:\n divide error: 0000 [#1] PREEMPT SMP PTI\n CPU: 7 PID: 2962 Comm: Xorg Not tainted 6.8.0-rc3+ #744\n Hardware name: Razer Blade/DANA_MB, BIOS 01.01 08/31/2018\n RIP: 0010:drm_dp_bw_overhead+0xb4/0x110 [drm_display_helper]\n Code: c6 b8 01 00 00 00 75 61 01 c6 41 0f af f3 41 0f af f1 c1 e1 04 48 63 c7 31 d2 89 ff 48 8b 5d f8 c9 48 0f af f1 48 8d 44 06 ff <48> f7 f7 31 d2 31 c9 31 f6 31 ff 45 31 c0 45 31 c9 45 31 d2 45 31\n RSP: 0018:ffffb2c5c211fa30 EFLAGS: 00010206\n RAX: ffffffffffffffff RBX: 0000000000000000 RCX: 0000000000f59b00\n RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000\n RBP: ffffb2c5c211fa48 R08: 0000000000000001 R09: 0000000000000020\n R10: 0000000000000004 R11: 0000000000000000 R12: 0000000000023b4a\n R13: ffff91d37d165800 R14: ffff91d36fac6d80 R15: ffff91d34a764010\n FS:  00007f4a1ca3fa80(0000) GS:ffff91d6edbc0000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000559491d49000 CR3: 000000011d180002 CR4: 00000000003706f0\n Call Trace:\n  <TASK>\n  ? show_regs+0x6d/0x80\n  ? die+0x37/0xa0\n  ? do_trap+0xd4/0xf0\n  ? do_error_trap+0x71/0xb0\n  ? drm_dp_bw_overhead+0xb4/0x110 [drm_display_helper]\n  ? exc_divide_error+0x3a/0x70\n  ? drm_dp_bw_overhead+0xb4/0x110 [drm_display_helper]\n  ? asm_exc_divide_error+0x1b/0x20\n  ? drm_dp_bw_overhead+0xb4/0x110 [drm_display_helper]\n  ? drm_dp_calc_pbn_mode+0x2e/0x70 [drm_display_helper]\n  nv50_msto_atomic_check+0xda/0x120 [nouveau]\n  drm_atomic_helper_check_modeset+0xa87/0xdf0 [drm_kms_helper]\n  drm_atomic_helper_check+0x19/0xa0 [drm_kms_helper]\n  nv50_disp_atomic_check+0x13f/0x2f0 [nouveau]\n  drm_atomic_check_only+0x668/0xb20 [drm]\n  ? drm_connector_list_iter_next+0x86/0xc0 [drm]\n  drm_atomic_commit+0x58/0xd0 [drm]\n  ? __pfx___drm_printfn_info+0x10/0x10 [drm]\n  drm_atomic_connector_commit_dpms+0xd7/0x100 [drm]\n  drm_mode_obj_set_property_ioctl+0x1c5/0x450 [drm]\n  ? __pfx_drm_connector_property_set_ioctl+0x10/0x10 [drm]\n  drm_connector_property_set_ioctl+0x3b/0x60 [drm]\n  drm_ioctl_kernel+0xb9/0x120 [drm]\n  drm_ioctl+0x2d0/0x550 [drm]\n  ? __pfx_drm_connector_property_set_ioctl+0x10/0x10 [drm]\n  nouveau_drm_ioctl+0x61/0xc0 [nouveau]\n  __x64_sys_ioctl+0xa0/0xf0\n  do_syscall_64+0x76/0x140\n  ? do_syscall_64+0x85/0x140\n  ? do_syscall_64+0x85/0x140\n  entry_SYSCALL_64_after_hwframe+0x6e/0x76\n RIP: 0033:0x7f4a1cd1a94f\n Code: 00 48 89 44 24 18 31 c0 48 8d 44 24 60 c7 04 24 10 00 00 00 48 89 44 24 08 48 8d 44 24 20 48 89 44 24 10 b8 10 00 00 00 0f 05 <41> 89 c0 3d 00 f0 ff ff 77 1f 48 8b 44 24 18 64 48 2b 04 25 28 00\n RSP: 002b:00007ffd2f1df520 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\n RAX: ffffffffffffffda RBX: 00007ffd2f1df5b0 RCX: 00007f4a1cd1a94f\n RDX: 00007ffd2f1df5b0 RSI: 00000000c01064ab RDI: 000000000000000f\n RBP: 00000000c01064ab R08: 000056347932deb8 R09: 000056347a7d99c0\n R10: 0000000000000000 R11: 0000000000000246 R12: 000056347938a220\n R13: 000000000000000f R14: 0000563479d9f3f0 R15: 0000000000000000\n  </TASK>\n Modules linked in: rfcomm xt_conntrack nft_chain_nat xt_MASQUERADE nf_nat nf_conntrack_netlink nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 xfrm_user xfrm_algo xt_addrtype nft_compat nf_tables nfnetlink br_netfilter bridge stp llc ccm cmac algif_hash overlay algif_skcipher af_alg bnep binfmt_misc snd_sof_pci_intel_cnl snd_sof_intel_hda_common snd_soc_hdac_hda snd_sof_pci snd_sof_xtensa_dsp snd_sof_intel_hda snd_sof snd_sof_utils snd_soc_acpi_intel_match snd_soc_acpi snd_soc_core snd_compress snd_sof_intel_hda_mlink snd_hda_ext_core iwlmvm intel_rapl_msr intel_rapl_common intel_tcc_cooling x86_pkg_temp_thermal intel_powerclamp mac80211 coretemp kvm_intel snd_hda_codec_hdmi kvm snd_hda_\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/828862071a6ca0c52655e6e62ac7abfef3e5c578"
          },
          {
            "url": "https://git.kernel.org/stable/c/9cbd1dae842737bfafa4b10a87909fa209dde250"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26942",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:09.633",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: phy: qcom: at803x: fix kernel panic with at8031_probe\nOn reworking and splitting the at803x driver, in splitting function of\nat803x PHYs it was added a NULL dereference bug where priv is referenced\nbefore it's actually allocated and then is tried to write to for the\nis_1000basex and is_fiber variables in the case of at8031, writing on\nthe wrong address.\nFix this by correctly setting priv local variable only after\nat803x_probe is called and actually allocates priv in the phydev struct.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/6a4aee277740d04ac0fd54cfa17cc28261932ddc"
          },
          {
            "url": "https://git.kernel.org/stable/c/a8a296ad9957b845b89bcf48be1cf8c74875ecc3"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26943",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:09.877",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnouveau/dmem: handle kcalloc() allocation failure\nThe kcalloc() in nouveau_dmem_evict_chunk() will return null if\nthe physical memory has run out. As a result, if we dereference\nsrc_pfns, dst_pfns or dma_addrs, the null pointer dereference bugs\nwill happen.\nMoreover, the GPU is going away. If the kcalloc() fails, we could not\nevict all pages mapping a chunk. So this patch adds a __GFP_NOFAIL\nflag in kcalloc().\nFinally, as there is no need to have physically contiguous memory,\nthis patch switches kcalloc() to kvcalloc() in order to avoid\nfailing allocations.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/16e87fe23d4af6df920406494ced5c0f4354567b"
          },
          {
            "url": "https://git.kernel.org/stable/c/2a84744a037b8a511d6a9055f3defddc28ff4a4d"
          },
          {
            "url": "https://git.kernel.org/stable/c/3e82f7383e0b82a835e6b6b06a348b2bc4e2c2ee"
          },
          {
            "url": "https://git.kernel.org/stable/c/5e81773757a95fc298e96cfd6d4700f07b6192a2"
          },
          {
            "url": "https://git.kernel.org/stable/c/9acfd8b083a0ffbd387566800d89f55058a68af2"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26944",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:10.010",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbtrfs: zoned: fix use-after-free in do_zone_finish()\nShinichiro reported the following use-after-free triggered by the device\nreplace operation in fstests btrfs/070.\n BTRFS info (device nullb1): scrub: finished on devid 1 with status: 0\n ==================================================================\n BUG: KASAN: slab-use-after-free in do_zone_finish+0x91a/0xb90 [btrfs]\n Read of size 8 at addr ffff8881543c8060 by task btrfs-cleaner/3494007\n CPU: 0 PID: 3494007 Comm: btrfs-cleaner Tainted: G        W          6.8.0-rc5-kts #1\n Hardware name: Supermicro Super Server/X11SPi-TF, BIOS 3.3 02/21/2020\n Call Trace:\n  <TASK>\n  dump_stack_lvl+0x5b/0x90\n  print_report+0xcf/0x670\n  ? __virt_addr_valid+0x200/0x3e0\n  kasan_report+0xd8/0x110\n  ? do_zone_finish+0x91a/0xb90 [btrfs]\n  ? do_zone_finish+0x91a/0xb90 [btrfs]\n  do_zone_finish+0x91a/0xb90 [btrfs]\n  btrfs_delete_unused_bgs+0x5e1/0x1750 [btrfs]\n  ? __pfx_btrfs_delete_unused_bgs+0x10/0x10 [btrfs]\n  ? btrfs_put_root+0x2d/0x220 [btrfs]\n  ? btrfs_clean_one_deleted_snapshot+0x299/0x430 [btrfs]\n  cleaner_kthread+0x21e/0x380 [btrfs]\n  ? __pfx_cleaner_kthread+0x10/0x10 [btrfs]\n  kthread+0x2e3/0x3c0\n  ? __pfx_kthread+0x10/0x10\n  ret_from_fork+0x31/0x70\n  ? __pfx_kthread+0x10/0x10\n  ret_from_fork_asm+0x1b/0x30\n  </TASK>\n Allocated by task 3493983:\n  kasan_save_stack+0x33/0x60\n  kasan_save_track+0x14/0x30\n  __kasan_kmalloc+0xaa/0xb0\n  btrfs_alloc_device+0xb3/0x4e0 [btrfs]\n  device_list_add.constprop.0+0x993/0x1630 [btrfs]\n  btrfs_scan_one_device+0x219/0x3d0 [btrfs]\n  btrfs_control_ioctl+0x26e/0x310 [btrfs]\n  __x64_sys_ioctl+0x134/0x1b0\n  do_syscall_64+0x99/0x190\n  entry_SYSCALL_64_after_hwframe+0x6e/0x76\n Freed by task 3494056:\n  kasan_save_stack+0x33/0x60\n  kasan_save_track+0x14/0x30\n  kasan_save_free_info+0x3f/0x60\n  poison_slab_object+0x102/0x170\n  __kasan_slab_free+0x32/0x70\n  kfree+0x11b/0x320\n  btrfs_rm_dev_replace_free_srcdev+0xca/0x280 [btrfs]\n  btrfs_dev_replace_finishing+0xd7e/0x14f0 [btrfs]\n  btrfs_dev_replace_by_ioctl+0x1286/0x25a0 [btrfs]\n  btrfs_ioctl+0xb27/0x57d0 [btrfs]\n  __x64_sys_ioctl+0x134/0x1b0\n  do_syscall_64+0x99/0x190\n  entry_SYSCALL_64_after_hwframe+0x6e/0x76\n The buggy address belongs to the object at ffff8881543c8000\n  which belongs to the cache kmalloc-1k of size 1024\n The buggy address is located 96 bytes inside of\n  freed 1024-byte region [ffff8881543c8000, ffff8881543c8400)\n The buggy address belongs to the physical page:\n page:00000000fe2c1285 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1543c8\n head:00000000fe2c1285 order:3 entire_mapcount:0 nr_pages_mapped:0 pincount:0\n flags: 0x17ffffc0000840(slab|head|node=0|zone=2|lastcpupid=0x1fffff)\n page_type: 0xffffffff()\n raw: 0017ffffc0000840 ffff888100042dc0 ffffea0019e8f200 dead000000000002\n raw: 0000000000000000 0000000000100010 00000001ffffffff 0000000000000000\n page dumped because: kasan: bad access detected\n Memory state around the buggy address:\n  ffff8881543c7f00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  ffff8881543c7f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n >ffff8881543c8000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                                                        ^\n  ffff8881543c8080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n  ffff8881543c8100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\nThis UAF happens because we're accessing stale zone information of a\nalready removed btrfs_device in do_zone_finish().\nThe sequence of events is as follows:\nbtrfs_dev_replace_start\n  btrfs_scrub_dev\n   btrfs_dev_replace_finishing\n    btrfs_dev_replace_update_device_in_mapping_tree <-- devices replaced\n    btrfs_rm_dev_replace_free_srcdev\n     btrfs_free_device                              <-- device freed\ncleaner_kthread\n btrfs_delete_unused_bgs\n  btrfs_zone_finish\n   do_zone_finish              <-- refers the freed device\nThe reason for this is that we're using a\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1ec17ef59168a1a6f1105f5dc517f783839a5302"
          },
          {
            "url": "https://git.kernel.org/stable/c/34ca809e055eca5cfe63d9c7efbf80b7c21b4e57"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26945",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:10.177",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ncrypto: iaa - Fix nr_cpus < nr_iaa case\nIf nr_cpus < nr_iaa, the calculated cpus_per_iaa will be 0, which\ncauses a divide-by-0 in rebalance_wq_table().\nMake sure cpus_per_iaa is 1 in that case, and also in the nr_iaa == 0\ncase, even though cpus_per_iaa is never used if nr_iaa == 0, for\nparanoia.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/5a7e89d3315d1be86aff8a8bf849023cda6547f7"
          },
          {
            "url": "https://git.kernel.org/stable/c/a5ca1be7f9817de4e93085778b3ee2219bdc2664"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26946",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:10.480",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nkprobes/x86: Use copy_from_kernel_nofault() to read from unsafe address\nRead from an unsafe address with copy_from_kernel_nofault() in\narch_adjust_kprobe_addr() because this function is used before checking\nthe address is in text or not. Syzcaller bot found a bug and reported\nthe case if user specifies inaccessible data area,\narch_adjust_kprobe_addr() will cause a kernel panic.\n[ mingo: Clarified the comment. ]",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/20fdb21eabaeb8f78f8f701f56d14ea0836ec861"
          },
          {
            "url": "https://git.kernel.org/stable/c/4e51653d5d871f40f1bd5cf95cc7f2d8b33d063b"
          },
          {
            "url": "https://git.kernel.org/stable/c/6417684315087904fffe8966d27ca74398c57dd6"
          },
          {
            "url": "https://git.kernel.org/stable/c/b69f577308f1070004cafac106dd1a44099e5483"
          },
          {
            "url": "https://git.kernel.org/stable/c/f13edd1871d4fb4ab829aff629d47914e251bae3"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26947",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:10.607",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nARM: 9359/1: flush: check if the folio is reserved for no-mapping addresses\nSince commit a4d5613c4dc6 (\"arm: extend pfn_valid to take into account\nfreed memory map alignment\") changes the semantics of pfn_valid() to check\npresence of the memory map for a PFN. A valid page for an address which\nis reserved but not mapped by the kernel[1], the system crashed during\nsome uio test with the following memory layout:\n node   0: [mem 0x00000000c0a00000-0x00000000cc8fffff]\n node   0: [mem 0x00000000d0000000-0x00000000da1fffff]\n the uio layout is?0xc0900000, 0x100000\nthe crash backtrace like:\n  Unable to handle kernel paging request at virtual address bff00000\n  [...]\n  CPU: 1 PID: 465 Comm: startapp.bin Tainted: G           O      5.10.0 #1\n  Hardware name: Generic DT based system\n  PC is at b15_flush_kern_dcache_area+0x24/0x3c\n  LR is at __sync_icache_dcache+0x6c/0x98\n  [...]\n   (b15_flush_kern_dcache_area) from (__sync_icache_dcache+0x6c/0x98)\n   (__sync_icache_dcache) from (set_pte_at+0x28/0x54)\n   (set_pte_at) from (remap_pfn_range+0x1a0/0x274)\n   (remap_pfn_range) from (uio_mmap+0x184/0x1b8 [uio])\n   (uio_mmap [uio]) from (__mmap_region+0x264/0x5f4)\n   (__mmap_region) from (__do_mmap_mm+0x3ec/0x440)\n   (__do_mmap_mm) from (do_mmap+0x50/0x58)\n   (do_mmap) from (vm_mmap_pgoff+0xfc/0x188)\n   (vm_mmap_pgoff) from (ksys_mmap_pgoff+0xac/0xc4)\n   (ksys_mmap_pgoff) from (ret_fast_syscall+0x0/0x5c)\n  Code: e0801001 e2423001 e1c00003 f57ff04f (ee070f3e)\n  ---[ end trace 09cf0734c3805d52 ]---\n  Kernel panic - not syncing: Fatal exception\nSo check if PG_reserved was set to solve this issue.\n[1]: https://lore.kernel.org/lkml/Zbtdue57RO0QScJM@linux.ibm.com/",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0c027c2bad7f5111c51a358b5d392e1a695dabff"
          },
          {
            "url": "https://git.kernel.org/stable/c/0c66c6f4e21cb22220cbd8821c5c73fc157d20dc"
          },
          {
            "url": "https://git.kernel.org/stable/c/9f7ddc222cae8254e93d5c169a8ae11a49d912a7"
          },
          {
            "url": "https://git.kernel.org/stable/c/fb3a122a978626b33de3367ee1762da934c0f512"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26948",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:10.757",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/amd/display: Add a dc_state NULL check in dc_state_release\n[How]\nCheck wheather state is NULL before releasing it.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/334b56cea5d9df5989be6cf1a5898114fa70ad98"
          },
          {
            "url": "https://git.kernel.org/stable/c/d37a08f840485995e3fb91dad95e441b9d28a269"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26949",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:10.930",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/amdgpu/pm: Fix NULL pointer dereference when get power limit\nBecause powerplay_table initialization is skipped under\nsriov case, We check and set default lower and upper OD\nvalue if powerplay_table is NULL.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/08ae9ef829b8055c2fdc8cfee37510c1f4721a07"
          },
          {
            "url": "https://git.kernel.org/stable/c/99c2f1563b1400cc8331fc79d19ada1bb95bb388"
          },
          {
            "url": "https://git.kernel.org/stable/c/b8eaa8ef1f1157a9f330e36e66bdd7a693309948"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26950",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:11.080",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nwireguard: netlink: access device through ctx instead of peer\nThe previous commit fixed a bug that led to a NULL peer->device being\ndereferenced. It's actually easier and faster performance-wise to\ninstead get the device from ctx->wg. This semantically makes more sense\ntoo, since ctx->wg->peer_allowedips.seq is compared with\nctx->allowedips_seq, basing them both in ctx. This also acts as a\ndefence in depth provision against freed peers.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/09c3fa70f65175861ca948cb2f0f791e666c90e5"
          },
          {
            "url": "https://git.kernel.org/stable/c/493aa6bdcffd90a4f82aa614fe4f4db0641b4068"
          },
          {
            "url": "https://git.kernel.org/stable/c/4be453271a882c8ebc28df3dbf9e4d95e6ac42f5"
          },
          {
            "url": "https://git.kernel.org/stable/c/71cbd32e3db82ea4a74e3ef9aeeaa6971969c86f"
          },
          {
            "url": "https://git.kernel.org/stable/c/93bcc1752c69bb309f4d8cfaf960ef1faeb34996"
          },
          {
            "url": "https://git.kernel.org/stable/c/c991567e6c638079304cc15dff28748e4a3c4a37"
          },
          {
            "url": "https://git.kernel.org/stable/c/d44bd323d8bb8031eef4bdc44547925998a11e47"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26951",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:11.223",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nwireguard: netlink: check for dangling peer via is_dead instead of empty list\nIf all peers are removed via wg_peer_remove_all(), rather than setting\npeer_list to empty, the peer is added to a temporary list with a head on\nthe stack of wg_peer_remove_all(). If a netlink dump is resumed and the\ncursored peer is one that has been removed via wg_peer_remove_all(), it\nwill iterate from that peer and then attempt to dump freed peers.\nFix this by instead checking peer->is_dead, which was explictly created\nfor this purpose. Also move up the device_update_lock lockdep assertion,\nsince reading is_dead relies on that.\nIt can be reproduced by a small script like:\n    echo \"Setting config...\"\n    ip link add dev wg0 type wireguard\n    wg setconf wg0 /big-config\n    (\n            while true; do\n                    echo \"Showing config...\"\n                    wg showconf wg0 > /dev/null\n            done\n    ) &\n    sleep 4\n    wg setconf wg0 <(printf \"[Peer]\\nPublicKey=$(wg genkey)\\n\")\nResulting in:\n    BUG: KASAN: slab-use-after-free in __lock_acquire+0x182a/0x1b20\n    Read of size 8 at addr ffff88811956ec70 by task wg/59\n    CPU: 2 PID: 59 Comm: wg Not tainted 6.8.0-rc2-debug+ #5\n    Call Trace:\n     <TASK>\n     dump_stack_lvl+0x47/0x70\n     print_address_description.constprop.0+0x2c/0x380\n     print_report+0xab/0x250\n     kasan_report+0xba/0xf0\n     __lock_acquire+0x182a/0x1b20\n     lock_acquire+0x191/0x4b0\n     down_read+0x80/0x440\n     get_peer+0x140/0xcb0\n     wg_get_device_dump+0x471/0x1130",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/13d107794304306164481d31ce33f8fdb25a9c04"
          },
          {
            "url": "https://git.kernel.org/stable/c/302b2dfc013baca3dea7ceda383930d9297d231d"
          },
          {
            "url": "https://git.kernel.org/stable/c/55b6c738673871c9b0edae05d0c97995c1ff08c4"
          },
          {
            "url": "https://git.kernel.org/stable/c/710a177f347282eea162aec8712beb1f42d5ad87"
          },
          {
            "url": "https://git.kernel.org/stable/c/7bedfe4cfa38771840a355970e4437cd52d4046b"
          },
          {
            "url": "https://git.kernel.org/stable/c/b7cea3a9af0853fdbb1b16633a458f991dde6aac"
          },
          {
            "url": "https://git.kernel.org/stable/c/f52be46e3e6ecefc2539119784324f0cbc09620a"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26952",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:11.350",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nksmbd: fix potencial out-of-bounds when buffer offset is invalid\nI found potencial out-of-bounds when buffer offset fields of a few requests\nis invalid. This patch set the minimum value of buffer offset field to\n->Buffer offset to validate buffer length.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0c5541b4c980626fa3cab16ba1a451757778bbb5"
          },
          {
            "url": "https://git.kernel.org/stable/c/2dcda336b6e80b72d58d30d40f2fad9724e5fe63"
          },
          {
            "url": "https://git.kernel.org/stable/c/c6cd2e8d2d9aa7ee35b1fa6a668e32a22a9753da"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26953",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:11.457",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: esp: fix bad handling of pages from page_pool\nWhen the skb is reorganized during esp_output (!esp->inline), the pages\ncoming from the original skb fragments are supposed to be released back\nto the system through put_page. But if the skb fragment pages are\noriginating from a page_pool, calling put_page on them will trigger a\npage_pool leak which will eventually result in a crash.\nThis leak can be easily observed when using CONFIG_DEBUG_VM and doing\nipsec + gre (non offloaded) forwarding:\n  BUG: Bad page state in process ksoftirqd/16  pfn:1451b6\n  page:00000000de2b8d32 refcount:0 mapcount:0 mapping:0000000000000000 index:0x1451b6000 pfn:0x1451b6\n  flags: 0x200000000000000(node=0|zone=2)\n  page_type: 0xffffffff()\n  raw: 0200000000000000 dead000000000040 ffff88810d23c000 0000000000000000\n  raw: 00000001451b6000 0000000000000001 00000000ffffffff 0000000000000000\n  page dumped because: page_pool leak\n  Modules linked in: ip_gre gre mlx5_ib mlx5_core xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink iptable_nat nf_nat xt_addrtype br_netfilter rpcrdma rdma_ucm ib_iser libiscsi scsi_transport_iscsi ib_umad rdma_cm ib_ipoib iw_cm ib_cm ib_uverbs ib_core overlay zram zsmalloc fuse [last unloaded: mlx5_core]\n  CPU: 16 PID: 96 Comm: ksoftirqd/16 Not tainted 6.8.0-rc4+ #22\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\n  Call Trace:\n   <TASK>\n   dump_stack_lvl+0x36/0x50\n   bad_page+0x70/0xf0\n   free_unref_page_prepare+0x27a/0x460\n   free_unref_page+0x38/0x120\n   esp_ssg_unref.isra.0+0x15f/0x200\n   esp_output_tail+0x66d/0x780\n   esp_xmit+0x2c5/0x360\n   validate_xmit_xfrm+0x313/0x370\n   ? validate_xmit_skb+0x1d/0x330\n   validate_xmit_skb_list+0x4c/0x70\n   sch_direct_xmit+0x23e/0x350\n   __dev_queue_xmit+0x337/0xba0\n   ? nf_hook_slow+0x3f/0xd0\n   ip_finish_output2+0x25e/0x580\n   iptunnel_xmit+0x19b/0x240\n   ip_tunnel_xmit+0x5fb/0xb60\n   ipgre_xmit+0x14d/0x280 [ip_gre]\n   dev_hard_start_xmit+0xc3/0x1c0\n   __dev_queue_xmit+0x208/0xba0\n   ? nf_hook_slow+0x3f/0xd0\n   ip_finish_output2+0x1ca/0x580\n   ip_sublist_rcv_finish+0x32/0x40\n   ip_sublist_rcv+0x1b2/0x1f0\n   ? ip_rcv_finish_core.constprop.0+0x460/0x460\n   ip_list_rcv+0x103/0x130\n   __netif_receive_skb_list_core+0x181/0x1e0\n   netif_receive_skb_list_internal+0x1b3/0x2c0\n   napi_gro_receive+0xc8/0x200\n   gro_cell_poll+0x52/0x90\n   __napi_poll+0x25/0x1a0\n   net_rx_action+0x28e/0x300\n   __do_softirq+0xc3/0x276\n   ? sort_range+0x20/0x20\n   run_ksoftirqd+0x1e/0x30\n   smpboot_thread_fn+0xa6/0x130\n   kthread+0xcd/0x100\n   ? kthread_complete_and_exit+0x20/0x20\n   ret_from_fork+0x31/0x50\n   ? kthread_complete_and_exit+0x20/0x20\n   ret_from_fork_asm+0x11/0x20\n   </TASK>\nThe suggested fix is to introduce a new wrapper (skb_page_unref) that\ncovers page refcounting for page_pool pages as well.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1abb20a5f4b02fb3020f88456fc1e6069b3cdc45"
          },
          {
            "url": "https://git.kernel.org/stable/c/8291b4eac429c480386669444c6377573f5d8664"
          },
          {
            "url": "https://git.kernel.org/stable/c/c3198822c6cb9fb588e446540485669cc81c5d34"
          },
          {
            "url": "https://git.kernel.org/stable/c/f278ff9db67264715d0d50e3e75044f8b78990f4"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26954",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:11.583",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nksmbd: fix slab-out-of-bounds in smb_strndup_from_utf16()\nIf ->NameOffset of smb2_create_req is smaller than Buffer offset of\nsmb2_create_req, slab-out-of-bounds read can happen from smb2_open.\nThis patch set the minimum value of the name offset to the buffer offset\nto validate name length of smb2_create_req().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3b8da67191e938a63d2736dabb4ac5d337e5de57"
          },
          {
            "url": "https://git.kernel.org/stable/c/4f97e6a9d62cb1fce82fbf4baff44b83221bc178"
          },
          {
            "url": "https://git.kernel.org/stable/c/a80a486d72e20bd12c335bcd38b6e6f19356b0aa"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26955",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:11.730",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnilfs2: prevent kernel bug at submit_bh_wbc()\nFix a bug where nilfs_get_block() returns a successful status when\nsearching and inserting the specified block both fail inconsistently.  If\nthis inconsistent behavior is not due to a previously fixed bug, then an\nunexpected race is occurring, so return a temporary error -EAGAIN instead.\nThis prevents callers such as __block_write_begin_int() from requesting a\nread into a buffer that is not mapped, which would cause the BUG_ON check\nfor the BH_Mapped flag in submit_bh_wbc() to fail.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0c8aa4cfda4e4adb15d5b6536d155eca9c9cd44c"
          },
          {
            "url": "https://git.kernel.org/stable/c/192e9f9078c96be30b31c4b44d6294b24520fce5"
          },
          {
            "url": "https://git.kernel.org/stable/c/269cdf353b5bdd15f1a079671b0f889113865f20"
          },
          {
            "url": "https://git.kernel.org/stable/c/32eaee72e96590a75445c8a6c7c1057673b47e07"
          },
          {
            "url": "https://git.kernel.org/stable/c/48d443d200237782dc82e6b60663ec414ef02e39"
          },
          {
            "url": "https://git.kernel.org/stable/c/76ffbe911e2798c7296968f5fd72f7bf67207a8d"
          },
          {
            "url": "https://git.kernel.org/stable/c/91e4c4595fae5e87069e44687ae879091783c183"
          },
          {
            "url": "https://git.kernel.org/stable/c/ca581d237f3b8539c044205bb003de71d75d227c"
          },
          {
            "url": "https://git.kernel.org/stable/c/f0fe7ad5aff4f0fcf988913313c497de85f1e186"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26956",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:11.837",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnilfs2: fix failure to detect DAT corruption in btree and direct mappings\nPatch series \"nilfs2: fix kernel bug at submit_bh_wbc()\".\nThis resolves a kernel BUG reported by syzbot.  Since there are two\nflaws involved, I've made each one a separate patch.\nThe first patch alone resolves the syzbot-reported bug, but I think\nboth fixes should be sent to stable, so I've tagged them as such.\nThis patch (of 2):\nSyzbot has reported a kernel bug in submit_bh_wbc() when writing file data\nto a nilfs2 file system whose metadata is corrupted.\nThere are two flaws involved in this issue.\nThe first flaw is that when nilfs_get_block() locates a data block using\nbtree or direct mapping, if the disk address translation routine\nnilfs_dat_translate() fails with internal code -ENOENT due to DAT metadata\ncorruption, it can be passed back to nilfs_get_block().  This causes\nnilfs_get_block() to misidentify an existing block as non-existent,\ncausing both data block lookup and insertion to fail inconsistently.\nThe second flaw is that nilfs_get_block() returns a successful status in\nthis inconsistent state.  This causes the caller __block_write_begin_int()\nor others to request a read even though the buffer is not mapped,\nresulting in a BUG_ON check for the BH_Mapped flag in submit_bh_wbc()\nfailing.\nThis fixes the first issue by changing the return value to code -EINVAL\nwhen a conversion using DAT fails with code -ENOENT, avoiding the\nconflicting condition that leads to the kernel bug described above.  Here,\ncode -EINVAL indicates that metadata corruption was detected during the\nblock lookup, which will be properly handled as a file system error and\nconverted to -EIO when passing through the nilfs2 bmap layer.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2e2619ff5d0def4bb6c2037a32a6eaa28dd95c84"
          },
          {
            "url": "https://git.kernel.org/stable/c/46b832e09d43b394ac0f6d9485d2b1a06593f0b7"
          },
          {
            "url": "https://git.kernel.org/stable/c/82827ca21e7c8a91384c5baa656f78a5adfa4ab4"
          },
          {
            "url": "https://git.kernel.org/stable/c/9cbe1ad5f4354f4df1445e5f4883983328cd6d8e"
          },
          {
            "url": "https://git.kernel.org/stable/c/a8e4d098de1c0f4c5c1f2ed4633a860f0da6d713"
          },
          {
            "url": "https://git.kernel.org/stable/c/b67189690eb4b7ecc84ae16fa1e880e0123eaa35"
          },
          {
            "url": "https://git.kernel.org/stable/c/c3b5c5c31e723b568f83d8cafab8629d9d830ffb"
          },
          {
            "url": "https://git.kernel.org/stable/c/f2f26b4a84a0ef41791bd2d70861c8eac748f4ba"
          },
          {
            "url": "https://git.kernel.org/stable/c/f69e81396aea66304d214f175aa371f1b5578862"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26957",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:11.953",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ns390/zcrypt: fix reference counting on zcrypt card objects\nTests with hot-plugging crytpo cards on KVM guests with debug\nkernel build revealed an use after free for the load field of\nthe struct zcrypt_card. The reason was an incorrect reference\nhandling of the zcrypt card object which could lead to a free\nof the zcrypt card object while it was still in use.\nThis is an example of the slab message:\n    kernel: 0x00000000885a7512-0x00000000885a7513 @offset=1298. First byte 0x68 instead of 0x6b\n    kernel: Allocated in zcrypt_card_alloc+0x36/0x70 [zcrypt] age=18046 cpu=3 pid=43\n    kernel:  kmalloc_trace+0x3f2/0x470\n    kernel:  zcrypt_card_alloc+0x36/0x70 [zcrypt]\n    kernel:  zcrypt_cex4_card_probe+0x26/0x380 [zcrypt_cex4]\n    kernel:  ap_device_probe+0x15c/0x290\n    kernel:  really_probe+0xd2/0x468\n    kernel:  driver_probe_device+0x40/0xf0\n    kernel:  __device_attach_driver+0xc0/0x140\n    kernel:  bus_for_each_drv+0x8c/0xd0\n    kernel:  __device_attach+0x114/0x198\n    kernel:  bus_probe_device+0xb4/0xc8\n    kernel:  device_add+0x4d2/0x6e0\n    kernel:  ap_scan_adapter+0x3d0/0x7c0\n    kernel:  ap_scan_bus+0x5a/0x3b0\n    kernel:  ap_scan_bus_wq_callback+0x40/0x60\n    kernel:  process_one_work+0x26e/0x620\n    kernel:  worker_thread+0x21c/0x440\n    kernel: Freed in zcrypt_card_put+0x54/0x80 [zcrypt] age=9024 cpu=3 pid=43\n    kernel:  kfree+0x37e/0x418\n    kernel:  zcrypt_card_put+0x54/0x80 [zcrypt]\n    kernel:  ap_device_remove+0x4c/0xe0\n    kernel:  device_release_driver_internal+0x1c4/0x270\n    kernel:  bus_remove_device+0x100/0x188\n    kernel:  device_del+0x164/0x3c0\n    kernel:  device_unregister+0x30/0x90\n    kernel:  ap_scan_adapter+0xc8/0x7c0\n    kernel:  ap_scan_bus+0x5a/0x3b0\n    kernel:  ap_scan_bus_wq_callback+0x40/0x60\n    kernel:  process_one_work+0x26e/0x620\n    kernel:  worker_thread+0x21c/0x440\n    kernel:  kthread+0x150/0x168\n    kernel:  __ret_from_fork+0x3c/0x58\n    kernel:  ret_from_fork+0xa/0x30\n    kernel: Slab 0x00000372022169c0 objects=20 used=18 fp=0x00000000885a7c88 flags=0x3ffff00000000a00(workingset|slab|node=0|zone=1|lastcpupid=0x1ffff)\n    kernel: Object 0x00000000885a74b8 @offset=1208 fp=0x00000000885a7c88\n    kernel: Redzone  00000000885a74b0: bb bb bb bb bb bb bb bb                          ........\n    kernel: Object   00000000885a74b8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    kernel: Object   00000000885a74c8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    kernel: Object   00000000885a74d8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    kernel: Object   00000000885a74e8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    kernel: Object   00000000885a74f8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    kernel: Object   00000000885a7508: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 68 4b 6b 6b 6b a5  kkkkkkkkkkhKkkk.\n    kernel: Redzone  00000000885a7518: bb bb bb bb bb bb bb bb                          ........\n    kernel: Padding  00000000885a756c: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a              ZZZZZZZZZZZZ\n    kernel: CPU: 0 PID: 387 Comm: systemd-udevd Not tainted 6.8.0-HF #2\n    kernel: Hardware name: IBM 3931 A01 704 (KVM/Linux)\n    kernel: Call Trace:\n    kernel:  [<00000000ca5ab5b8>] dump_stack_lvl+0x90/0x120\n    kernel:  [<00000000c99d78bc>] check_bytes_and_report+0x114/0x140\n    kernel:  [<00000000c99d53cc>] check_object+0x334/0x3f8\n    kernel:  [<00000000c99d820c>] alloc_debug_processing+0xc4/0x1f8\n    kernel:  [<00000000c99d852e>] get_partial_node.part.0+0x1ee/0x3e0\n    kernel:  [<00000000c99d94ec>] ___slab_alloc+0xaf4/0x13c8\n    kernel:  [<00000000c99d9e38>] __slab_alloc.constprop.0+0x78/0xb8\n    kernel:  [<00000000c99dc8dc>] __kmalloc+0x434/0x590\n    kernel:  [<00000000c9b4c0ce>] ext4_htree_store_dirent+0x4e/0x1c0\n    kernel:  [<00000000c9b908a2>] htree_dirblock_to_tree+0x17a/0x3f0\n    kernel: \n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/394b6d8bbdf9ddee6d5bcf3e1f3e9f23eecd6484"
          },
          {
            "url": "https://git.kernel.org/stable/c/50ed48c80fecbe17218afed4f8bed005c802976c"
          },
          {
            "url": "https://git.kernel.org/stable/c/6470078ab3d8f222115e11c4ec67351f3031b3dd"
          },
          {
            "url": "https://git.kernel.org/stable/c/7e500849fa558879a1cde43f80c7c048c2437058"
          },
          {
            "url": "https://git.kernel.org/stable/c/9daddee03de3f231012014dab8ab2b277a116a55"
          },
          {
            "url": "https://git.kernel.org/stable/c/a55677878b93e9ebc31f66d0e2fb93be5e7836a6"
          },
          {
            "url": "https://git.kernel.org/stable/c/a64ab862e84e3e698cd351a87cdb504c7fc575ca"
          },
          {
            "url": "https://git.kernel.org/stable/c/b7f6c3630eb3f103115ab0d7613588064f665d0d"
          },
          {
            "url": "https://git.kernel.org/stable/c/befb7f889594d23e1b475720cf93efd2f77df000"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26958",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:12.090",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnfs: fix UAF in direct writes\nIn production we have been hitting the following warning consistently\n------------[ cut here ]------------\nrefcount_t: underflow; use-after-free.\nWARNING: CPU: 17 PID: 1800359 at lib/refcount.c:28 refcount_warn_saturate+0x9c/0xe0\nWorkqueue: nfsiod nfs_direct_write_schedule_work [nfs]\nRIP: 0010:refcount_warn_saturate+0x9c/0xe0\nPKRU: 55555554\nCall Trace:\n <TASK>\n ? __warn+0x9f/0x130\n ? refcount_warn_saturate+0x9c/0xe0\n ? report_bug+0xcc/0x150\n ? handle_bug+0x3d/0x70\n ? exc_invalid_op+0x16/0x40\n ? asm_exc_invalid_op+0x16/0x20\n ? refcount_warn_saturate+0x9c/0xe0\n nfs_direct_write_schedule_work+0x237/0x250 [nfs]\n process_one_work+0x12f/0x4a0\n worker_thread+0x14e/0x3b0\n ? ZSTD_getCParams_internal+0x220/0x220\n kthread+0xdc/0x120\n ? __btf_name_valid+0xa0/0xa0\n ret_from_fork+0x1f/0x30\nThis is because we're completing the nfs_direct_request twice in a row.\nThe source of this is when we have our commit requests to submit, we\nprocess them and send them off, and then in the completion path for the\ncommit requests we have\nif (nfs_commit_end(cinfo.mds))\n\tnfs_direct_write_complete(dreq);\nHowever since we're submitting asynchronous requests we sometimes have\none that completes before we submit the next one, so we end up calling\ncomplete on the nfs_direct_request twice.\nThe only other place we use nfs_generic_commit_list() is in\n__nfs_commit_inode, which wraps this call in a\nnfs_commit_begin();\nnfs_commit_end();\nWhich is a common pattern for this style of completion handling, one\nthat is also repeated in the direct code with get_dreq()/put_dreq()\ncalls around where we process events as well as in the completion paths.\nFix this by using the same pattern for the commit requests.\nBefore with my 200 node rocksdb stress running this warning would pop\nevery 10ish minutes.  With my patch the stress test has been running for\nseveral hours without popping.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/17f46b803d4f23c66cacce81db35fef3adb8f2af"
          },
          {
            "url": "https://git.kernel.org/stable/c/1daf52b5ffb24870fbeda20b4967526d8f9e12ab"
          },
          {
            "url": "https://git.kernel.org/stable/c/3abc2d160ed8213948b147295d77d44a22c88fa3"
          },
          {
            "url": "https://git.kernel.org/stable/c/4595d90b5d2ea5fa4d318d13f59055aa4bf3e7f5"
          },
          {
            "url": "https://git.kernel.org/stable/c/80d24b308b7ee7037fc90d8ac99f6f78df0a256f"
          },
          {
            "url": "https://git.kernel.org/stable/c/cf54f66e1dd78990ec6b32177bca7e6ea2144a95"
          },
          {
            "url": "https://git.kernel.org/stable/c/e25447c35f8745337ea8bc0c9697fcac14df8605"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26959",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:12.207",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nBluetooth: btnxpuart: Fix btnxpuart_close\nFix scheduling while atomic BUG in btnxpuart_close(), properly\npurge the transmit queue and free the receive skb.\n[   10.973809] BUG: scheduling while atomic: kworker/u9:0/80/0x00000002\n...\n[   10.980740] CPU: 3 PID: 80 Comm: kworker/u9:0 Not tainted 6.8.0-rc7-0.0.0-devel-00005-g61fdfceacf09 #1\n[   10.980751] Hardware name: Toradex Verdin AM62 WB on Dahlia Board (DT)\n[   10.980760] Workqueue: hci0 hci_power_off [bluetooth]\n[   10.981169] Call trace:\n...\n[   10.981363]  uart_update_mctrl+0x58/0x78\n[   10.981373]  uart_dtr_rts+0x104/0x114\n[   10.981381]  tty_port_shutdown+0xd4/0xdc\n[   10.981396]  tty_port_close+0x40/0xbc\n[   10.981407]  uart_close+0x34/0x9c\n[   10.981414]  ttyport_close+0x50/0x94\n[   10.981430]  serdev_device_close+0x40/0x50\n[   10.981442]  btnxpuart_close+0x24/0x98 [btnxpuart]\n[   10.981469]  hci_dev_close_sync+0x2d8/0x718 [bluetooth]\n[   10.981728]  hci_dev_do_close+0x2c/0x70 [bluetooth]\n[   10.981862]  hci_power_off+0x20/0x64 [bluetooth]",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/586e099c93fe26b7bd40593979532f507ed9f6a4"
          },
          {
            "url": "https://git.kernel.org/stable/c/664130c0b0309b360bc5bdd40a30604a9387bde8"
          },
          {
            "url": "https://git.kernel.org/stable/c/74bcf708775c405f7fb6ed776ccd3e1957f38a52"
          },
          {
            "url": "https://git.kernel.org/stable/c/d4e2365b07f1ae1f811a915b514caef5b2d6581e"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26960",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:12.323",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmm: swap: fix race between free_swap_and_cache() and swapoff()\nThere was previously a theoretical window where swapoff() could run and\nteardown a swap_info_struct while a call to free_swap_and_cache() was\nrunning in another thread.  This could cause, amongst other bad\npossibilities, swap_page_trans_huge_swapped() (called by\nfree_swap_and_cache()) to access the freed memory for swap_map.\nThis is a theoretical problem and I haven't been able to provoke it from a\ntest case.  But there has been agreement based on code review that this is\npossible (see link below).\nFix it by using get_swap_device()/put_swap_device(), which will stall\nswapoff().  There was an extra check in _swap_info_get() to confirm that\nthe swap entry was not free.  This isn't present in get_swap_device()\nbecause it doesn't make sense in general due to the race between getting\nthe reference and swapoff.  So I've added an equivalent check directly in\nfree_swap_and_cache().\nDetails of how to provoke one possible issue (thanks to David Hildenbrand\nfor deriving this):\n--8<-----\n__swap_entry_free() might be the last user and result in\n\"count == SWAP_HAS_CACHE\".\nswapoff->try_to_unuse() will stop as soon as soon as si->inuse_pages==0.\nSo the question is: could someone reclaim the folio and turn\nsi->inuse_pages==0, before we completed swap_page_trans_huge_swapped().\nImagine the following: 2 MiB folio in the swapcache. Only 2 subpages are\nstill references by swap entries.\nProcess 1 still references subpage 0 via swap entry.\nProcess 2 still references subpage 1 via swap entry.\nProcess 1 quits. Calls free_swap_and_cache().\n-> count == SWAP_HAS_CACHE\n[then, preempted in the hypervisor etc.]\nProcess 2 quits. Calls free_swap_and_cache().\n-> count == SWAP_HAS_CACHE\nProcess 2 goes ahead, passes swap_page_trans_huge_swapped(), and calls\n__try_to_reclaim_swap().\n__try_to_reclaim_swap()->folio_free_swap()->delete_from_swap_cache()->\nput_swap_folio()->free_swap_slot()->swapcache_free_entries()->\nswap_entry_free()->swap_range_free()->\n...\nWRITE_ONCE(si->inuse_pages, si->inuse_pages - nr_entries);\nWhat stops swapoff to succeed after process 2 reclaimed the swap cache\nbut before process1 finished its call to swap_page_trans_huge_swapped()?\n--8<-----",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0f98f6d2fb5fad00f8299b84b85b6bc1b6d7d19a"
          },
          {
            "url": "https://git.kernel.org/stable/c/1ede7f1d7eed1738d1b9333fd1e152ccb450b86a"
          },
          {
            "url": "https://git.kernel.org/stable/c/2da5568ee222ce0541bfe446a07998f92ed1643e"
          },
          {
            "url": "https://git.kernel.org/stable/c/363d17e7f7907c8e27a9e86968af0eaa2301787b"
          },
          {
            "url": "https://git.kernel.org/stable/c/3ce4c4c653e4e478ecb15d3c88e690f12cbf6b39"
          },
          {
            "url": "https://git.kernel.org/stable/c/82b1c07a0af603e3c47b906c8e991dc96f01688e"
          },
          {
            "url": "https://git.kernel.org/stable/c/d85c11c97ecf92d47a4b29e3faca714dc1f18d0d"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26961",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:12.437",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmac802154: fix llsec key resources release in mac802154_llsec_key_del\nmac802154_llsec_key_del() can free resources of a key directly without\nfollowing the RCU rules for waiting before the end of a grace period. This\nmay lead to use-after-free in case llsec_lookup_key() is traversing the\nlist of keys in parallel with a key deletion:\nrefcount_t: addition on 0; use-after-free.\nWARNING: CPU: 4 PID: 16000 at lib/refcount.c:25 refcount_warn_saturate+0x162/0x2a0\nModules linked in:\nCPU: 4 PID: 16000 Comm: wpan-ping Not tainted 6.7.0 #19\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014\nRIP: 0010:refcount_warn_saturate+0x162/0x2a0\nCall Trace:\n <TASK>\n llsec_lookup_key.isra.0+0x890/0x9e0\n mac802154_llsec_encrypt+0x30c/0x9c0\n ieee802154_subif_start_xmit+0x24/0x1e0\n dev_hard_start_xmit+0x13e/0x690\n sch_direct_xmit+0x2ae/0xbc0\n __dev_queue_xmit+0x11dd/0x3c20\n dgram_sendmsg+0x90b/0xd60\n __sys_sendto+0x466/0x4c0\n __x64_sys_sendto+0xe0/0x1c0\n do_syscall_64+0x45/0xf0\n entry_SYSCALL_64_after_hwframe+0x6e/0x76\nAlso, ieee802154_llsec_key_entry structures are not freed by\nmac802154_llsec_key_del():\nunreferenced object 0xffff8880613b6980 (size 64):\n  comm \"iwpan\", pid 2176, jiffies 4294761134 (age 60.475s)\n  hex dump (first 32 bytes):\n    78 0d 8f 18 80 88 ff ff 22 01 00 00 00 00 ad de  x.......\".......\n    00 00 00 00 00 00 00 00 03 00 cd ab 00 00 00 00  ................\n  backtrace:\n    [<ffffffff81dcfa62>] __kmem_cache_alloc_node+0x1e2/0x2d0\n    [<ffffffff81c43865>] kmalloc_trace+0x25/0xc0\n    [<ffffffff88968b09>] mac802154_llsec_key_add+0xac9/0xcf0\n    [<ffffffff8896e41a>] ieee802154_add_llsec_key+0x5a/0x80\n    [<ffffffff8892adc6>] nl802154_add_llsec_key+0x426/0x5b0\n    [<ffffffff86ff293e>] genl_family_rcv_msg_doit+0x1fe/0x2f0\n    [<ffffffff86ff46d1>] genl_rcv_msg+0x531/0x7d0\n    [<ffffffff86fee7a9>] netlink_rcv_skb+0x169/0x440\n    [<ffffffff86ff1d88>] genl_rcv+0x28/0x40\n    [<ffffffff86fec15c>] netlink_unicast+0x53c/0x820\n    [<ffffffff86fecd8b>] netlink_sendmsg+0x93b/0xe60\n    [<ffffffff86b91b35>] ____sys_sendmsg+0xac5/0xca0\n    [<ffffffff86b9c3dd>] ___sys_sendmsg+0x11d/0x1c0\n    [<ffffffff86b9c65a>] __sys_sendmsg+0xfa/0x1d0\n    [<ffffffff88eadbf5>] do_syscall_64+0x45/0xf0\n    [<ffffffff890000ea>] entry_SYSCALL_64_after_hwframe+0x6e/0x76\nHandle the proper resource release in the RCU callback function\nmac802154_llsec_key_del_rcu().\nNote that if llsec_lookup_key() finds a key, it gets a refcount via\nllsec_key_get() and locally copies key id from key_entry (which is a\nlist element). So it's safe to call llsec_key_put() and free the list\nentry after the RCU grace period elapses.\nFound by Linux Verification Center (linuxtesting.org).",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/068ab2759bc0b4daf0b964de61b2731449c86531"
          },
          {
            "url": "https://git.kernel.org/stable/c/20d3e1c8a1847497269f04d874b2a5818ec29e2d"
          },
          {
            "url": "https://git.kernel.org/stable/c/49c8951680d7b76fceaee89dcfbab1363fb24fd1"
          },
          {
            "url": "https://git.kernel.org/stable/c/640297c3e897bd7e1481466a6a5cb9560f1edb88"
          },
          {
            "url": "https://git.kernel.org/stable/c/d3d858650933d44ac12c1f31337e7110c2071821"
          },
          {
            "url": "https://git.kernel.org/stable/c/dcd51ab42b7a0431575689c5f74b8b6efd45fc2f"
          },
          {
            "url": "https://git.kernel.org/stable/c/e8a1e58345cf40b7b272e08ac7b32328b2543e40"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26962",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:12.527",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndm-raid456, md/raid456: fix a deadlock for dm-raid456 while io concurrent with reshape\nFor raid456, if reshape is still in progress, then IO across reshape\nposition will wait for reshape to make progress. However, for dm-raid,\nin following cases reshape will never make progress hence IO will hang:\n1) the array is read-only;\n2) MD_RECOVERY_WAIT is set;\n3) MD_RECOVERY_FROZEN is set;\nAfter commit c467e97f079f (\"md/raid6: use valid sector values to determine\nif an I/O should wait on the reshape\") fix the problem that IO across\nreshape position doesn't wait for reshape, the dm-raid test\nshell/lvconvert-raid-reshape.sh start to hang:\n[root@fedora ~]# cat /proc/979/stack\n[<0>] wait_woken+0x7d/0x90\n[<0>] raid5_make_request+0x929/0x1d70 [raid456]\n[<0>] md_handle_request+0xc2/0x3b0 [md_mod]\n[<0>] raid_map+0x2c/0x50 [dm_raid]\n[<0>] __map_bio+0x251/0x380 [dm_mod]\n[<0>] dm_submit_bio+0x1f0/0x760 [dm_mod]\n[<0>] __submit_bio+0xc2/0x1c0\n[<0>] submit_bio_noacct_nocheck+0x17f/0x450\n[<0>] submit_bio_noacct+0x2bc/0x780\n[<0>] submit_bio+0x70/0xc0\n[<0>] mpage_readahead+0x169/0x1f0\n[<0>] blkdev_readahead+0x18/0x30\n[<0>] read_pages+0x7c/0x3b0\n[<0>] page_cache_ra_unbounded+0x1ab/0x280\n[<0>] force_page_cache_ra+0x9e/0x130\n[<0>] page_cache_sync_ra+0x3b/0x110\n[<0>] filemap_get_pages+0x143/0xa30\n[<0>] filemap_read+0xdc/0x4b0\n[<0>] blkdev_read_iter+0x75/0x200\n[<0>] vfs_read+0x272/0x460\n[<0>] ksys_read+0x7a/0x170\n[<0>] __x64_sys_read+0x1c/0x30\n[<0>] do_syscall_64+0xc6/0x230\n[<0>] entry_SYSCALL_64_after_hwframe+0x6c/0x74\nThis is because reshape can't make progress.\nFor md/raid, the problem doesn't exist because register new sync_thread\ndoesn't rely on the IO to be done any more:\n1) If array is read-only, it can switch to read-write by ioctl/sysfs;\n2) md/raid never set MD_RECOVERY_WAIT;\n3) If MD_RECOVERY_FROZEN is set, mddev_suspend() doesn't hold\n   'reconfig_mutex', hence it can be cleared and reshape can continue by\n   sysfs api 'sync_action'.\nHowever, I'm not sure yet how to avoid the problem in dm-raid yet. This\npatch on the one hand make sure raid_message() can't change\nsync_thread() through raid_message() after presuspend(), on the other\nhand detect the above 3 cases before wait for IO do be done in\ndm_suspend(), and let dm-raid requeue those IO.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/41425f96d7aa59bc865f60f5dda3d7697b555677"
          },
          {
            "url": "https://git.kernel.org/stable/c/5943a34bf6bab5801e08a55f63e1b8d5bc90dae1"
          },
          {
            "url": "https://git.kernel.org/stable/c/a8d249d770cb357d16a2097b548d2e4c1c137304"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26963",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:12.610",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nusb: dwc3-am62: fix module unload/reload behavior\nAs runtime PM is enabled, the module can be runtime\nsuspended when .remove() is called.\nDo a pm_runtime_get_sync() to make sure module is active\nbefore doing any register operations.\nDoing a pm_runtime_put_sync() should disable the refclk\nso no need to disable it again.\nFixes the below warning at module removel.\n[   39.705310] ------------[ cut here ]------------\n[   39.710004] clk:162:3 already disabled\n[   39.713941] WARNING: CPU: 0 PID: 921 at drivers/clk/clk.c:1090 clk_core_disable+0xb0/0xb8\nWe called of_platform_populate() in .probe() so call the\ncleanup function of_platform_depopulate() in .remove().\nGet rid of the now unnnecessary dwc3_ti_remove_core().\nWithout this, module re-load doesn't work properly.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3895780fabd120d0fbd54354014e85207b25687c"
          },
          {
            "url": "https://git.kernel.org/stable/c/629b534c42d04f0797980f2d1ed105fdb8906975"
          },
          {
            "url": "https://git.kernel.org/stable/c/6661befe41009c210efa2c1bcd16a5cc4cff8a06"
          },
          {
            "url": "https://git.kernel.org/stable/c/6c6a45645a2e6a272dfde14eddbb6706de63c25d"
          },
          {
            "url": "https://git.kernel.org/stable/c/7dfed9855397d0df4c6f748d1f66547ab3bad766"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26964",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:12.707",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nusb: xhci: Add error handling in xhci_map_urb_for_dma\nCurrently xhci_map_urb_for_dma() creates a temporary buffer and copies\nthe SG list to the new linear buffer. But if the kzalloc_node() fails,\nthen the following sg_pcopy_to_buffer() can lead to crash since it\ntries to memcpy to NULL pointer.\nSo return -ENOMEM if kzalloc returns null pointer.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4a49d24fdec0a802aa686a567a3989a9fdf4e5dd"
          },
          {
            "url": "https://git.kernel.org/stable/c/620b6cf2f1a270f48d38e6b8ce199c1acb3e90f4"
          },
          {
            "url": "https://git.kernel.org/stable/c/7b6cc33593d7ccfc3011b290849cfa899db46757"
          },
          {
            "url": "https://git.kernel.org/stable/c/962300a360d24c5be5a188cda48da58a37e4304d"
          },
          {
            "url": "https://git.kernel.org/stable/c/b2c898469dfc388f619c6c972a28466cbb1442ea"
          },
          {
            "url": "https://git.kernel.org/stable/c/be95cc6d71dfd0cba66e3621c65413321b398052"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26965",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:12.783",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nclk: qcom: mmcc-msm8974: fix terminating of frequency table arrays\nThe frequency table arrays are supposed to be terminated with an\nempty element. Add such entry to the end of the arrays where it\nis missing in order to avoid possible out-of-bound access when\nthe table is traversed by functions like qcom_find_freq() or\nqcom_find_freq_floor().\nOnly compile tested.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3ff4a0f6a8f0ad4b4ee9e908bdfc3cacb7be4060"
          },
          {
            "url": "https://git.kernel.org/stable/c/537040c257ab4cd0673fbae048f3940c8ea2e589"
          },
          {
            "url": "https://git.kernel.org/stable/c/7e9926fef71e514b4a8ea9d11d5a84d52b181362"
          },
          {
            "url": "https://git.kernel.org/stable/c/86bf75d9158f511db7530bc82a84b19a5134d089"
          },
          {
            "url": "https://git.kernel.org/stable/c/8f562f3b25177c2055b20fd8cf000496f6fa9194"
          },
          {
            "url": "https://git.kernel.org/stable/c/99740c4791dc8019b0d758c5389ca6d1c0604d95"
          },
          {
            "url": "https://git.kernel.org/stable/c/ae99e199037c580b7350bfa3596f447a53bcf01f"
          },
          {
            "url": "https://git.kernel.org/stable/c/ca2cf98d46748373e830a13d85d215d64a2d9bf2"
          },
          {
            "url": "https://git.kernel.org/stable/c/e2c02a85bf53ae86d79b5fccf0a75ac0b78e0c96"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26966",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:12.913",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nclk: qcom: mmcc-apq8084: fix terminating of frequency table arrays\nThe frequency table arrays are supposed to be terminated with an\nempty element. Add such entry to the end of the arrays where it\nis missing in order to avoid possible out-of-bound access when\nthe table is traversed by functions like qcom_find_freq() or\nqcom_find_freq_floor().\nOnly compile tested.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/185de0b7cdeaad8b89ebd4c8a258ff2f21adba99"
          },
          {
            "url": "https://git.kernel.org/stable/c/3aedcf3755c74dafc187eb76acb04e3e6348b1a9"
          },
          {
            "url": "https://git.kernel.org/stable/c/5533686e99b04994d7c4877dc0e4282adc9444a2"
          },
          {
            "url": "https://git.kernel.org/stable/c/5638330150db2cc30b53eed04e481062faa3ece8"
          },
          {
            "url": "https://git.kernel.org/stable/c/7e5432401536117c316d7f3b21d46b64c1514f38"
          },
          {
            "url": "https://git.kernel.org/stable/c/9b4c4546dd61950e80ffdca1bf6925f42b665b03"
          },
          {
            "url": "https://git.kernel.org/stable/c/a09aecb6cb482de88301c43bf00a6c8726c4d34f"
          },
          {
            "url": "https://git.kernel.org/stable/c/a903cfd38d8dee7e754fb89fd1bebed99e28003d"
          },
          {
            "url": "https://git.kernel.org/stable/c/b2dfb216f32627c2f6a8041f2d9d56d102ab87c0"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26967",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:13.010",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nclk: qcom: camcc-sc8280xp: fix terminating of frequency table arrays\nThe frequency table arrays are supposed to be terminated with an\nempty element. Add such entry to the end of the arrays where it\nis missing in order to avoid possible out-of-bound access when\nthe table is traversed by functions like qcom_find_freq() or\nqcom_find_freq_floor().\nOnly compile tested.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/6a3d70f7802a98e6c28a74f997a264118b9f50cd"
          },
          {
            "url": "https://git.kernel.org/stable/c/93ff48729211dae55df5d216023be4528d29babb"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26968",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:13.133",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nclk: qcom: gcc-ipq9574: fix terminating of frequency table arrays\nThe frequency table arrays are supposed to be terminated with an\nempty element. Add such entry to the end of the arrays where it\nis missing in order to avoid possible out-of-bound access when\nthe table is traversed by functions like qcom_find_freq() or\nqcom_find_freq_floor().\nOnly compile tested.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0204247cf3669b6021fb745c3b7f37ae392ab19c"
          },
          {
            "url": "https://git.kernel.org/stable/c/1723629fea8a4e75333196866e10d395463dca72"
          },
          {
            "url": "https://git.kernel.org/stable/c/604f2d7c46727c5e24fc7faddc980bc1cc0b1011"
          },
          {
            "url": "https://git.kernel.org/stable/c/bd2b6395671d823caa38d8e4d752de2448ae61e1"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26969",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:13.220",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nclk: qcom: gcc-ipq8074: fix terminating of frequency table arrays\nThe frequency table arrays are supposed to be terminated with an\nempty element. Add such entry to the end of the arrays where it\nis missing in order to avoid possible out-of-bound access when\nthe table is traversed by functions like qcom_find_freq() or\nqcom_find_freq_floor().\nOnly compile tested.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1040ef5ed95d6fd2628bad387d78a61633e09429"
          },
          {
            "url": "https://git.kernel.org/stable/c/83fe1bbd9e259ad109827ccfbfc2488e0dea8e94"
          },
          {
            "url": "https://git.kernel.org/stable/c/851cc19bdb02556fb13629b3e4fef6f2bdb038fe"
          },
          {
            "url": "https://git.kernel.org/stable/c/9de184d4e557d550fb0b7b833b676bda4f269e4f"
          },
          {
            "url": "https://git.kernel.org/stable/c/b6b31b4c67ea6bd9222e5b73b330554c57f2f90d"
          },
          {
            "url": "https://git.kernel.org/stable/c/be9e2752d823eca1d5af67014a1844a9176ff566"
          },
          {
            "url": "https://git.kernel.org/stable/c/dd92b159c506804ac57adf3742d9728298bb1255"
          },
          {
            "url": "https://git.kernel.org/stable/c/e117c6e2d1617520f5f7d7f6f6b395f01d8b5a27"
          },
          {
            "url": "https://git.kernel.org/stable/c/fc3ac2fcd0a7fad63eba1b359490a4b81720d0f9"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26970",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:13.320",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nclk: qcom: gcc-ipq6018: fix terminating of frequency table arrays\nThe frequency table arrays are supposed to be terminated with an\nempty element. Add such entry to the end of the arrays where it\nis missing in order to avoid possible out-of-bound access when\nthe table is traversed by functions like qcom_find_freq() or\nqcom_find_freq_floor().\nOnly compile tested.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/421b135aceace99789c982f6a77ce9476564fb52"
          },
          {
            "url": "https://git.kernel.org/stable/c/852db52b45ea96dac2720f108e7c7331cd3738bb"
          },
          {
            "url": "https://git.kernel.org/stable/c/ae60e3342296f766f88911d39199f77b05f657a6"
          },
          {
            "url": "https://git.kernel.org/stable/c/b4527ee3de365a742215773d20f07db3e2c06f3b"
          },
          {
            "url": "https://git.kernel.org/stable/c/cdbc6e2d8108bc47895e5a901cfcaf799b00ca8d"
          },
          {
            "url": "https://git.kernel.org/stable/c/db4066e3ab6b3d918ae2b92734a89c04fe82cc1d"
          },
          {
            "url": "https://git.kernel.org/stable/c/dcb13b5c9ae8743f99a96f392186527c3df89198"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26971",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:13.450",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nclk: qcom: gcc-ipq5018: fix terminating of frequency table arrays\nThe frequency table arrays are supposed to be terminated with an\nempty element. Add such entry to the end of the arrays where it\nis missing in order to avoid possible out-of-bound access when\nthe table is traversed by functions like qcom_find_freq() or\nqcom_find_freq_floor().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/50c3acd460551cdf9d8ac6fe0c04f2de0e8e0872"
          },
          {
            "url": "https://git.kernel.org/stable/c/90ad946fff70f312b8d23226afc38c13ddd88c4b"
          },
          {
            "url": "https://git.kernel.org/stable/c/b0cf3d200e8a72b6d28e6e088c062b4a98cb5eaf"
          },
          {
            "url": "https://git.kernel.org/stable/c/c8f4bef0667947b826848db1c45a645f751357c1"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26972",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:13.597",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nubifs: ubifs_symlink: Fix memleak of inode->i_link in error path\nFor error handling path in ubifs_symlink(), inode will be marked as\nbad first, then iput() is invoked. If inode->i_link is initialized by\nfscrypt_encrypt_symlink() in encryption scenario, inode->i_link won't\nbe freed by callchain ubifs_free_inode -> fscrypt_free_inode in error\nhandling path, because make_bad_inode() has changed 'inode->i_mode' as\n'S_IFREG'.\nFollowing kmemleak is easy to be reproduced by injecting error in\nubifs_jnl_update() when doing symlink in encryption scenario:\n unreferenced object 0xffff888103da3d98 (size 8):\n  comm \"ln\", pid 1692, jiffies 4294914701 (age 12.045s)\n  backtrace:\n   kmemdup+0x32/0x70\n   __fscrypt_encrypt_symlink+0xed/0x1c0\n   ubifs_symlink+0x210/0x300 [ubifs]\n   vfs_symlink+0x216/0x360\n   do_symlinkat+0x11a/0x190\n   do_syscall_64+0x3b/0xe0\nThere are two ways fixing it:\n 1. Remove make_bad_inode() in error handling path. We can do that\n    because ubifs_evict_inode() will do same processes for good\n    symlink inode and bad symlink inode, for inode->i_nlink checking\n    is before is_bad_inode().\n 2. Free inode->i_link before marking inode bad.\nMethod 2 is picked, it has less influence, personally, I think.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/62b5ae00c2b835639002ce898ccb5d82c51073ae"
          },
          {
            "url": "https://git.kernel.org/stable/c/6379b44cdcd67f5f5d986b73953e99700591edfa"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26973",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:13.920",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nfat: fix uninitialized field in nostale filehandles\nWhen fat_encode_fh_nostale() encodes file handle without a parent it\nstores only first 10 bytes of the file handle. However the length of the\nfile handle must be a multiple of 4 so the file handle is actually 12\nbytes long and the last two bytes remain uninitialized. This is not\ngreat at we potentially leak uninitialized information with the handle\nto userspace. Properly initialize the full handle length.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/03a7e3f2ba3ca25f1da1d3898709a08db14c1abb"
          },
          {
            "url": "https://git.kernel.org/stable/c/74f852654b8b7866f15323685f1e178d3386c688"
          },
          {
            "url": "https://git.kernel.org/stable/c/9840d1897e28f8733cc1e38f97e044f987dc0a63"
          },
          {
            "url": "https://git.kernel.org/stable/c/a276c595c3a629170b0f052a3724f755d7c6adc6"
          },
          {
            "url": "https://git.kernel.org/stable/c/b7fb63e807c6dadf7ecc1d43448c4f1711d7eeee"
          },
          {
            "url": "https://git.kernel.org/stable/c/c8cc05de8e6b5612b6e9f92c385c1a064b0db375"
          },
          {
            "url": "https://git.kernel.org/stable/c/cdd33d54e789d229d6d5007cbf3f53965ca1a5c6"
          },
          {
            "url": "https://git.kernel.org/stable/c/f52d7663a10a1266a2d3871a6dd8fd111edc549f"
          },
          {
            "url": "https://git.kernel.org/stable/c/fde2497d2bc3a063d8af88b258dbadc86bd7b57c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26974",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:14.313",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ncrypto: qat - resolve race condition during AER recovery\nDuring the PCI AER system's error recovery process, the kernel driver\nmay encounter a race condition with freeing the reset_data structure's\nmemory. If the device restart will take more than 10 seconds the function\nscheduling that restart will exit due to a timeout, and the reset_data\nstructure will be freed. However, this data structure is used for\ncompletion notification after the restart is completed, which leads\nto a UAF bug.\nThis results in a KFENCE bug notice.\n  BUG: KFENCE: use-after-free read in adf_device_reset_worker+0x38/0xa0 [intel_qat]\n  Use-after-free read at 0x00000000bc56fddf (in kfence-#142):\n  adf_device_reset_worker+0x38/0xa0 [intel_qat]\n  process_one_work+0x173/0x340\nTo resolve this race condition, the memory associated to the container\nof the work_struct is freed on the worker if the timeout expired,\notherwise on the function that schedules the worker.\nThe timeout detection can be done by checking if the caller is\nstill waiting for completion or not by using completion_done() function.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0c2cf5142bfb634c0ef0a1a69cdf37950747d0be"
          },
          {
            "url": "https://git.kernel.org/stable/c/226fc408c5fcd23cc4186f05ea3a09a7a9aef2f7"
          },
          {
            "url": "https://git.kernel.org/stable/c/4ae5a97781ce7d6ecc9c7055396535815b64ca4f"
          },
          {
            "url": "https://git.kernel.org/stable/c/7d42e097607c4d246d99225bf2b195b6167a210c"
          },
          {
            "url": "https://git.kernel.org/stable/c/8a5a7611ccc7b1fba8d933a9f22a2e76859d94dc"
          },
          {
            "url": "https://git.kernel.org/stable/c/8e81cd58aee14a470891733181a47d123193ba81"
          },
          {
            "url": "https://git.kernel.org/stable/c/bb279ead42263e9fb09480f02a4247b2c287d828"
          },
          {
            "url": "https://git.kernel.org/stable/c/d03092550f526a79cf1ade7f0dfa74906f39eb71"
          },
          {
            "url": "https://git.kernel.org/stable/c/daba62d9eeddcc5b1081be7d348ca836c83c59d7"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26975",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:14.533",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\npowercap: intel_rapl: Fix a NULL pointer dereference\nA NULL pointer dereference is triggered when probing the MMIO RAPL\ndriver on platforms with CPU ID not listed in intel_rapl_common CPU\nmodel list.\nThis is because the intel_rapl_common module still probes on such\nplatforms even if 'defaults_msr' is not set after commit 1488ac990ac8\n(\"powercap: intel_rapl: Allow probing without CPUID match\"). Thus the\nMMIO RAPL rp->priv->defaults is NULL when registering to RAPL framework.\nFix the problem by adding sanity check to ensure rp->priv->rapl_defaults\nis always valid.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0641908b906a133f1494c312a71f9fecbe2b6c78"
          },
          {
            "url": "https://git.kernel.org/stable/c/2d1f5006ff95770da502f8cee2a224a1ff83866e"
          },
          {
            "url": "https://git.kernel.org/stable/c/2f73cf2ae5e0f4e629db5be3a4380ff7807148e6"
          },
          {
            "url": "https://git.kernel.org/stable/c/9b254feb249981b66ccdb1dae54e757789a15ba1"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26976",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:14.667",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nKVM: Always flush async #PF workqueue when vCPU is being destroyed\nAlways flush the per-vCPU async #PF workqueue when a vCPU is clearing its\ncompletion queue, e.g. when a VM and all its vCPUs is being destroyed.\nKVM must ensure that none of its workqueue callbacks is running when the\nlast reference to the KVM _module_ is put.  Gifting a reference to the\nassociated VM prevents the workqueue callback from dereferencing freed\nvCPU/VM memory, but does not prevent the KVM module from being unloaded\nbefore the callback completes.\nDrop the misguided VM refcount gifting, as calling kvm_put_kvm() from\nasync_pf_execute() if kvm_put_kvm() flushes the async #PF workqueue will\nresult in deadlock.  async_pf_execute() can't return until kvm_put_kvm()\nfinishes, and kvm_put_kvm() can't return until async_pf_execute() finishes:\n WARNING: CPU: 8 PID: 251 at virt/kvm/kvm_main.c:1435 kvm_put_kvm+0x2d/0x320 [kvm]\n Modules linked in: vhost_net vhost vhost_iotlb tap kvm_intel kvm irqbypass\n CPU: 8 PID: 251 Comm: kworker/8:1 Tainted: G        W          6.6.0-rc1-e7af8d17224a-x86/gmem-vm #119\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015\n Workqueue: events async_pf_execute [kvm]\n RIP: 0010:kvm_put_kvm+0x2d/0x320 [kvm]\n Call Trace:\n  <TASK>\n  async_pf_execute+0x198/0x260 [kvm]\n  process_one_work+0x145/0x2d0\n  worker_thread+0x27e/0x3a0\n  kthread+0xba/0xe0\n  ret_from_fork+0x2d/0x50\n  ret_from_fork_asm+0x11/0x20\n  </TASK>\n ---[ end trace 0000000000000000 ]---\n INFO: task kworker/8:1:251 blocked for more than 120 seconds.\n       Tainted: G        W          6.6.0-rc1-e7af8d17224a-x86/gmem-vm #119\n \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\n task:kworker/8:1     state:D stack:0     pid:251   ppid:2      flags:0x00004000\n Workqueue: events async_pf_execute [kvm]\n Call Trace:\n  <TASK>\n  __schedule+0x33f/0xa40\n  schedule+0x53/0xc0\n  schedule_timeout+0x12a/0x140\n  __wait_for_common+0x8d/0x1d0\n  __flush_work.isra.0+0x19f/0x2c0\n  kvm_clear_async_pf_completion_queue+0x129/0x190 [kvm]\n  kvm_arch_destroy_vm+0x78/0x1b0 [kvm]\n  kvm_put_kvm+0x1c1/0x320 [kvm]\n  async_pf_execute+0x198/0x260 [kvm]\n  process_one_work+0x145/0x2d0\n  worker_thread+0x27e/0x3a0\n  kthread+0xba/0xe0\n  ret_from_fork+0x2d/0x50\n  ret_from_fork_asm+0x11/0x20\n  </TASK>\nIf kvm_clear_async_pf_completion_queue() actually flushes the workqueue,\nthen there's no need to gift async_pf_execute() a reference because all\ninvocations of async_pf_execute() will be forced to complete before the\nvCPU and its VM are destroyed/freed.  And that in turn fixes the module\nunloading bug as __fput() won't do module_put() on the last vCPU reference\nuntil the vCPU has been freed, e.g. if closing the vCPU file also puts the\nlast reference to the KVM module.\nNote that kvm_check_async_pf_completion() may also take the work item off\nthe completion queue and so also needs to flush the work queue, as the\nwork will not be seen by kvm_clear_async_pf_completion_queue().  Waiting\non the workqueue could theoretically delay a vCPU due to waiting for the\nwork to complete, but that's a very, very small chance, and likely a very\nsmall delay.  kvm_arch_async_page_present_queued() unconditionally makes a\nnew request, i.e. will effectively delay entering the guest, so the\nremaining work is really just:\n        trace_kvm_async_pf_completed(addr, cr2_or_gpa);\n        __kvm_vcpu_wake_up(vcpu);\n        mmput(mm);\nand mmput() can't drop the last reference to the page tables if the vCPU is\nstill alive, i.e. the vCPU won't get stuck tearing down page tables.\nAdd a helper to do the flushing, specifically to deal with \"wakeup all\"\nwork items, as they aren't actually work items, i.e. are never placed in a\nworkqueue.  Trying to flush a bogus workqueue entry rightly makes\n__flush_work() complain (kudos to whoever added that sanity check).\nNote, commit 5f6de5cbebee (\"KVM: Prevent module exit until al\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3d75b8aa5c29058a512db29da7cbee8052724157"
          },
          {
            "url": "https://git.kernel.org/stable/c/4f3a3bce428fb439c66a578adc447afce7b4a750"
          },
          {
            "url": "https://git.kernel.org/stable/c/82e25cc1c2e93c3023da98be282322fc08b61ffb"
          },
          {
            "url": "https://git.kernel.org/stable/c/83d3c5e309611ef593e2fcb78444fc8ceedf9bac"
          },
          {
            "url": "https://git.kernel.org/stable/c/a75afe480d4349c524d9c659b1a5a544dbc39a98"
          },
          {
            "url": "https://git.kernel.org/stable/c/ab2c2f5d9576112ad22cfd3798071cb74693b1f5"
          },
          {
            "url": "https://git.kernel.org/stable/c/b54478d20375874aeee257744dedfd3e413432ff"
          },
          {
            "url": "https://git.kernel.org/stable/c/caa9af2e27c275e089d702cfbaaece3b42bca31b"
          },
          {
            "url": "https://git.kernel.org/stable/c/f8730d6335e5f43d09151fca1f0f41922209a264"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26977",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:14.860",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\npci_iounmap(): Fix MMIO mapping leak\nThe #ifdef ARCH_HAS_GENERIC_IOPORT_MAP accidentally also guards iounmap(),\nwhich means MMIO mappings are leaked.\nMove the guard so we call iounmap() for MMIO mappings.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/5e4b23e7a7b33a1e56bfa3e5598138a2234d55b6"
          },
          {
            "url": "https://git.kernel.org/stable/c/6d21d0356aa44157a62e39c0d1a13d4c69a8d0c8"
          },
          {
            "url": "https://git.kernel.org/stable/c/7626913652cc786c238e2dd7d8740b17d41b2637"
          },
          {
            "url": "https://git.kernel.org/stable/c/af280e137e273935f2e09f4d73169998298792ed"
          },
          {
            "url": "https://git.kernel.org/stable/c/b5d40f02e7222da032c2042aebcf2a07de9b342f"
          },
          {
            "url": "https://git.kernel.org/stable/c/f3749345a9b7295dd071d0ed589634cb46364f77"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26978",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:15.040",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nserial: max310x: fix NULL pointer dereference in I2C instantiation\nWhen trying to instantiate a max14830 device from userspace:\n    echo max14830 0x60 > /sys/bus/i2c/devices/i2c-2/new_device\nwe get the following error:\n    Unable to handle kernel NULL pointer dereference at virtual address...\n    ...\n    Call trace:\n        max310x_i2c_probe+0x48/0x170 [max310x]\n        i2c_device_probe+0x150/0x2a0\n    ...\nAdd check for validity of devtype to prevent the error, and abort probe\nwith a meaningful error message.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0d27056c24efd3d63a03f3edfbcfc4827086b110"
          },
          {
            "url": "https://git.kernel.org/stable/c/12609c76b755dbeb1645c0aacc0f0f4743b2eff3"
          },
          {
            "url": "https://git.kernel.org/stable/c/2160ad6861c4a21d3fa553d7b2aaec6634a37f8a"
          },
          {
            "url": "https://git.kernel.org/stable/c/5cd8af02b466e1beeae13e2de3dc58fcc7925e5a"
          },
          {
            "url": "https://git.kernel.org/stable/c/7d271b798add90c6196539167c019d0817285cf0"
          },
          {
            "url": "https://git.kernel.org/stable/c/aeca49661fd02fd56fb026768b580ce301b45733"
          },
          {
            "url": "https://git.kernel.org/stable/c/c45e53c27b78afd6c81fc25608003576f27b5735"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26979",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:15.227",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/vmwgfx: Fix possible null pointer derefence with invalid contexts\nvmw_context_cotable can return either an error or a null pointer and its\nusage sometimes went unchecked. Subsequent code would then try to access\neither a null pointer or an error value.\nThe invalid dereferences were only possible with malformed userspace\napps which never properly initialized the rendering contexts.\nCheck the results of vmw_context_cotable to fix the invalid derefs.\nThanks:\nziming zhang(@ezrak1e) from Ant Group Light-Year Security Lab\nwho was the first person to discover it.\nNiels De Graef who reported it and helped to track down the poc.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/07c3fe923ff7eccf684fb4f8c953d0a7cc8ded73"
          },
          {
            "url": "https://git.kernel.org/stable/c/517621b7060096e48e42f545fa6646fc00252eac"
          },
          {
            "url": "https://git.kernel.org/stable/c/585fec7361e7850bead21fada49a7fcde2f2e791"
          },
          {
            "url": "https://git.kernel.org/stable/c/899e154f9546fcae18065d74064889d08fff62c2"
          },
          {
            "url": "https://git.kernel.org/stable/c/9cb3755b1e3680b720b74dbedfac889e904605c7"
          },
          {
            "url": "https://git.kernel.org/stable/c/c560327d900bab968c2e1b4cd7fa2d46cd429e3d"
          },
          {
            "url": "https://git.kernel.org/stable/c/ff41e0d4f3fa10d7cdd7d40f8026bea9fcc8b000"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26980",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:15.423",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nksmbd: fix slab-out-of-bounds in smb2_allocate_rsp_buf\nIf ->ProtocolId is SMB2_TRANSFORM_PROTO_NUM, smb2 request size\nvalidation could be skipped. if request size is smaller than\nsizeof(struct smb2_query_info_req), slab-out-of-bounds read can happen in\nsmb2_allocate_rsp_buf(). This patch allocate response buffer after\ndecrypting transform request. smb3_decrypt_req() will validate transform\nrequest size and avoid slab-out-of-bound in smb2_allocate_rsp_buf().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0977f89722eceba165700ea384f075143f012085"
          },
          {
            "url": "https://git.kernel.org/stable/c/3160d9734453a40db248487f8204830879c207f1"
          },
          {
            "url": "https://git.kernel.org/stable/c/b80ba648714e6d790d69610cf14656be222d0248"
          },
          {
            "url": "https://git.kernel.org/stable/c/c119f4ede3fa90a9463f50831761c28f989bfb20"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26981",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:15.517",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnilfs2: fix OOB in nilfs_set_de_type\nThe size of the nilfs_type_by_mode array in the fs/nilfs2/dir.c file is\ndefined as \"S_IFMT >> S_SHIFT\", but the nilfs_set_de_type() function,\nwhich uses this array, specifies the index to read from the array in the\nsame way as \"(mode & S_IFMT) >> S_SHIFT\".\nstatic void nilfs_set_de_type(struct nilfs_dir_entry *de, struct inode\n *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tde->file_type = nilfs_type_by_mode[(mode & S_IFMT)>>S_SHIFT]; // oob\n}\nHowever, when the index is determined this way, an out-of-bounds (OOB)\nerror occurs by referring to an index that is 1 larger than the array size\nwhen the condition \"mode & S_IFMT == S_IFMT\" is satisfied.  Therefore, a\npatch to resize the nilfs_type_by_mode array should be applied to prevent\nOOB errors.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2382eae66b196c31893984a538908c3eb7506ff9"
          },
          {
            "url": "https://git.kernel.org/stable/c/897ac5306bbeb83e90c437326f7044c79a17c611"
          },
          {
            "url": "https://git.kernel.org/stable/c/90823f8d9ecca3d5fa6b102c8e464c62f416975f"
          },
          {
            "url": "https://git.kernel.org/stable/c/bdbe483da21f852c93b22557b146bc4d989260f0"
          },
          {
            "url": "https://git.kernel.org/stable/c/c4a7dc9523b59b3e73fd522c73e95e072f876b16"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26982",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:15.610",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nSquashfs: check the inode number is not the invalid value of zero\nSyskiller has produced an out of bounds access in fill_meta_index().\nThat out of bounds access is ultimately caused because the inode\nhas an inode number with the invalid value of zero, which was not checked.\nThe reason this causes the out of bounds access is due to following\nsequence of events:\n1. Fill_meta_index() is called to allocate (via empty_meta_index())\n   and fill a metadata index.  It however suffers a data read error\n   and aborts, invalidating the newly returned empty metadata index.\n   It does this by setting the inode number of the index to zero,\n   which means unused (zero is not a valid inode number).\n2. When fill_meta_index() is subsequently called again on another\n   read operation, locate_meta_index() returns the previous index\n   because it matches the inode number of 0.  Because this index\n   has been returned it is expected to have been filled, and because\n   it hasn't been, an out of bounds access is performed.\nThis patch adds a sanity check which checks that the inode number\nis not zero when the inode is created and returns -EINVAL if it is.\n[phillip@squashfs.org.uk: whitespace fix]\n  Link: https://lkml.kernel.org/r/20240409204723.446925-1-phillip@squashfs.org.uk",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/7def00ebc9f2d6a581ddf46ce4541f84a10680e5"
          },
          {
            "url": "https://git.kernel.org/stable/c/9253c54e01b6505d348afbc02abaa4d9f8a01395"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26983",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:15.747",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbootconfig: use memblock_free_late to free xbc memory to buddy\nOn the time to free xbc memory in xbc_exit(), memblock may has handed\nover memory to buddy allocator. So it doesn't make sense to free memory\nback to memblock. memblock_free() called by xbc_exit() even causes UAF bugs\non architectures with CONFIG_ARCH_KEEP_MEMBLOCK disabled like x86.\nFollowing KASAN logs shows this case.\nThis patch fixes the xbc memory free problem by calling memblock_free()\nin early xbc init error rewind path and calling memblock_free_late() in\nxbc exit path to free memory to buddy allocator.\n[    9.410890] ==================================================================\n[    9.418962] BUG: KASAN: use-after-free in memblock_isolate_range+0x12d/0x260\n[    9.426850] Read of size 8 at addr ffff88845dd30000 by task swapper/0/1\n[    9.435901] CPU: 9 PID: 1 Comm: swapper/0 Tainted: G     U             6.9.0-rc3-00208-g586b5dfb51b9 #5\n[    9.446403] Hardware name: Intel Corporation RPLP LP5 (CPU:RaptorLake)/RPLP LP5 (ID:13), BIOS IRPPN02.01.01.00.00.19.015.D-00000000 Dec 28 2023\n[    9.460789] Call Trace:\n[    9.463518]  <TASK>\n[    9.465859]  dump_stack_lvl+0x53/0x70\n[    9.469949]  print_report+0xce/0x610\n[    9.473944]  ? __virt_addr_valid+0xf5/0x1b0\n[    9.478619]  ? memblock_isolate_range+0x12d/0x260\n[    9.483877]  kasan_report+0xc6/0x100\n[    9.487870]  ? memblock_isolate_range+0x12d/0x260\n[    9.493125]  memblock_isolate_range+0x12d/0x260\n[    9.498187]  memblock_phys_free+0xb4/0x160\n[    9.502762]  ? __pfx_memblock_phys_free+0x10/0x10\n[    9.508021]  ? mutex_unlock+0x7e/0xd0\n[    9.512111]  ? __pfx_mutex_unlock+0x10/0x10\n[    9.516786]  ? kernel_init_freeable+0x2d4/0x430\n[    9.521850]  ? __pfx_kernel_init+0x10/0x10\n[    9.526426]  xbc_exit+0x17/0x70\n[    9.529935]  kernel_init+0x38/0x1e0\n[    9.533829]  ? _raw_spin_unlock_irq+0xd/0x30\n[    9.538601]  ret_from_fork+0x2c/0x50\n[    9.542596]  ? __pfx_kernel_init+0x10/0x10\n[    9.547170]  ret_from_fork_asm+0x1a/0x30\n[    9.551552]  </TASK>\n[    9.555649] The buggy address belongs to the physical page:\n[    9.561875] page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x1 pfn:0x45dd30\n[    9.570821] flags: 0x200000000000000(node=0|zone=2)\n[    9.576271] page_type: 0xffffffff()\n[    9.580167] raw: 0200000000000000 ffffea0011774c48 ffffea0012ba1848 0000000000000000\n[    9.588823] raw: 0000000000000001 0000000000000000 00000000ffffffff 0000000000000000\n[    9.597476] page dumped because: kasan: bad access detected\n[    9.605362] Memory state around the buggy address:\n[    9.610714]  ffff88845dd2ff00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[    9.618786]  ffff88845dd2ff80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[    9.626857] >ffff88845dd30000: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n[    9.634930]                    ^\n[    9.638534]  ffff88845dd30080: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n[    9.646605]  ffff88845dd30100: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n[    9.654675] ==================================================================",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1e7feb31a18c197d63a5e606025ed63c762f8918"
          },
          {
            "url": "https://git.kernel.org/stable/c/5a7dfb8fcd3f29fc93161100179b27f24f3d5f35"
          },
          {
            "url": "https://git.kernel.org/stable/c/89f9a1e876b5a7ad884918c03a46831af202c8a0"
          },
          {
            "url": "https://git.kernel.org/stable/c/e46d3be714ad9652480c6db129ab8125e2d20ab7"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26984",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:15.880",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnouveau: fix instmem race condition around ptr stores\nRunning a lot of VK CTS in parallel against nouveau, once every\nfew hours you might see something like this crash.\nBUG: kernel NULL pointer dereference, address: 0000000000000008\nPGD 8000000114e6e067 P4D 8000000114e6e067 PUD 109046067 PMD 0\nOops: 0000 [#1] PREEMPT SMP PTI\nCPU: 7 PID: 53891 Comm: deqp-vk Not tainted 6.8.0-rc6+ #27\nHardware name: Gigabyte Technology Co., Ltd. Z390 I AORUS PRO WIFI/Z390 I AORUS PRO WIFI-CF, BIOS F8 11/05/2021\nRIP: 0010:gp100_vmm_pgt_mem+0xe3/0x180 [nouveau]\nCode: c7 48 01 c8 49 89 45 58 85 d2 0f 84 95 00 00 00 41 0f b7 46 12 49 8b 7e 08 89 da 42 8d 2c f8 48 8b 47 08 41 83 c7 01 48 89 ee <48> 8b 40 08 ff d0 0f 1f 00 49 8b 7e 08 48 89 d9 48 8d 75 04 48 c1\nRSP: 0000:ffffac20c5857838 EFLAGS: 00010202\nRAX: 0000000000000000 RBX: 00000000004d8001 RCX: 0000000000000001\nRDX: 00000000004d8001 RSI: 00000000000006d8 RDI: ffffa07afe332180\nRBP: 00000000000006d8 R08: ffffac20c5857ad0 R09: 0000000000ffff10\nR10: 0000000000000001 R11: ffffa07af27e2de0 R12: 000000000000001c\nR13: ffffac20c5857ad0 R14: ffffa07a96fe9040 R15: 000000000000001c\nFS:  00007fe395eed7c0(0000) GS:ffffa07e2c980000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000000008 CR3: 000000011febe001 CR4: 00000000003706f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n...\n ? gp100_vmm_pgt_mem+0xe3/0x180 [nouveau]\n ? gp100_vmm_pgt_mem+0x37/0x180 [nouveau]\n nvkm_vmm_iter+0x351/0xa20 [nouveau]\n ? __pfx_nvkm_vmm_ref_ptes+0x10/0x10 [nouveau]\n ? __pfx_gp100_vmm_pgt_mem+0x10/0x10 [nouveau]\n ? __pfx_gp100_vmm_pgt_mem+0x10/0x10 [nouveau]\n ? __lock_acquire+0x3ed/0x2170\n ? __pfx_gp100_vmm_pgt_mem+0x10/0x10 [nouveau]\n nvkm_vmm_ptes_get_map+0xc2/0x100 [nouveau]\n ? __pfx_nvkm_vmm_ref_ptes+0x10/0x10 [nouveau]\n ? __pfx_gp100_vmm_pgt_mem+0x10/0x10 [nouveau]\n nvkm_vmm_map_locked+0x224/0x3a0 [nouveau]\nAdding any sort of useful debug usually makes it go away, so I hand\nwrote the function in a line, and debugged the asm.\nEvery so often pt->memory->ptrs is NULL. This ptrs ptr is set in\nthe nv50_instobj_acquire called from nvkm_kmap.\nIf Thread A and Thread B both get to nv50_instobj_acquire around\nthe same time, and Thread A hits the refcount_set line, and in\nlockstep thread B succeeds at refcount_inc_not_zero, there is a\nchance the ptrs value won't have been stored since refcount_set\nis unordered. Force a memory barrier here, I picked smp_mb, since\nwe want it on all CPUs and it's write followed by a read.\nv2: use paired smp_rmb/smp_wmb.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/21ca9539f09360fd83654f78f2c361f2f5ddcb52"
          },
          {
            "url": "https://git.kernel.org/stable/c/3ab056814cd8ab84744c9a19ef51360b2271c572"
          },
          {
            "url": "https://git.kernel.org/stable/c/a019b44b1bc6ed224c46fb5f88a8a10dd116e525"
          },
          {
            "url": "https://git.kernel.org/stable/c/ad74d208f213c06d860916ad40f609ade8c13039"
          },
          {
            "url": "https://git.kernel.org/stable/c/fff1386cc889d8fb4089d285f883f8cba62d82ce"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26985",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:16.063",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/xe: Fix bo leak in intel_fb_bo_framebuffer_init\nAdd a unreference bo in the error path, to prevent leaking a bo ref.\nReturn 0 on success to clarify the success path.\n(cherry picked from commit a2f3d731be3893e730417ae3190760fcaffdf549)",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/652ead9b746a63e4e79d7ad66d3edf0a8a5b0c2f"
          },
          {
            "url": "https://git.kernel.org/stable/c/7d8ac0942c312abda43b407eff72d31747a7b472"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26986",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:16.180",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/amdkfd: Fix memory leak in create_process failure\nFix memory leak due to a leaked mmget reference on an error handling\ncode path that is triggered when attempting to create KFD processes\nwhile a GPU reset is in progress.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0dcd876411644da98a6b4d5a18d32ca94c15bdb5"
          },
          {
            "url": "https://git.kernel.org/stable/c/18921b205012568b45760753ad3146ddb9e2d4e2"
          },
          {
            "url": "https://git.kernel.org/stable/c/aa02d43367a9adf8c85fb382fea4171fb266c8d0"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26987",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:16.260",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmm/memory-failure: fix deadlock when hugetlb_optimize_vmemmap is enabled\nWhen I did hard offline test with hugetlb pages, below deadlock occurs:\n======================================================\nWARNING: possible circular locking dependency detected\n6.8.0-11409-gf6cef5f8c37f #1 Not tainted\n------------------------------------------------------\nbash/46904 is trying to acquire lock:\nffffffffabe68910 (cpu_hotplug_lock){++++}-{0:0}, at: static_key_slow_dec+0x16/0x60\nbut task is already holding lock:\nffffffffabf92ea8 (pcp_batch_high_lock){+.+.}-{3:3}, at: zone_pcp_disable+0x16/0x40\nwhich lock already depends on the new lock.\nthe existing dependency chain (in reverse order) is:\n-> #1 (pcp_batch_high_lock){+.+.}-{3:3}:\n       __mutex_lock+0x6c/0x770\n       page_alloc_cpu_online+0x3c/0x70\n       cpuhp_invoke_callback+0x397/0x5f0\n       __cpuhp_invoke_callback_range+0x71/0xe0\n       _cpu_up+0xeb/0x210\n       cpu_up+0x91/0xe0\n       cpuhp_bringup_mask+0x49/0xb0\n       bringup_nonboot_cpus+0xb7/0xe0\n       smp_init+0x25/0xa0\n       kernel_init_freeable+0x15f/0x3e0\n       kernel_init+0x15/0x1b0\n       ret_from_fork+0x2f/0x50\n       ret_from_fork_asm+0x1a/0x30\n-> #0 (cpu_hotplug_lock){++++}-{0:0}:\n       __lock_acquire+0x1298/0x1cd0\n       lock_acquire+0xc0/0x2b0\n       cpus_read_lock+0x2a/0xc0\n       static_key_slow_dec+0x16/0x60\n       __hugetlb_vmemmap_restore_folio+0x1b9/0x200\n       dissolve_free_huge_page+0x211/0x260\n       __page_handle_poison+0x45/0xc0\n       memory_failure+0x65e/0xc70\n       hard_offline_page_store+0x55/0xa0\n       kernfs_fop_write_iter+0x12c/0x1d0\n       vfs_write+0x387/0x550\n       ksys_write+0x64/0xe0\n       do_syscall_64+0xca/0x1e0\n       entry_SYSCALL_64_after_hwframe+0x6d/0x75\nother info that might help us debug this:\n Possible unsafe locking scenario:\n       CPU0                    CPU1\n       ----                    ----\n  lock(pcp_batch_high_lock);\n                               lock(cpu_hotplug_lock);\n                               lock(pcp_batch_high_lock);\n  rlock(cpu_hotplug_lock);\n *** DEADLOCK ***\n5 locks held by bash/46904:\n #0: ffff98f6c3bb23f0 (sb_writers#5){.+.+}-{0:0}, at: ksys_write+0x64/0xe0\n #1: ffff98f6c328e488 (&of->mutex){+.+.}-{3:3}, at: kernfs_fop_write_iter+0xf8/0x1d0\n #2: ffff98ef83b31890 (kn->active#113){.+.+}-{0:0}, at: kernfs_fop_write_iter+0x100/0x1d0\n #3: ffffffffabf9db48 (mf_mutex){+.+.}-{3:3}, at: memory_failure+0x44/0xc70\n #4: ffffffffabf92ea8 (pcp_batch_high_lock){+.+.}-{3:3}, at: zone_pcp_disable+0x16/0x40\nstack backtrace:\nCPU: 10 PID: 46904 Comm: bash Kdump: loaded Not tainted 6.8.0-11409-gf6cef5f8c37f #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014\nCall Trace:\n <TASK>\n dump_stack_lvl+0x68/0xa0\n check_noncircular+0x129/0x140\n __lock_acquire+0x1298/0x1cd0\n lock_acquire+0xc0/0x2b0\n cpus_read_lock+0x2a/0xc0\n static_key_slow_dec+0x16/0x60\n __hugetlb_vmemmap_restore_folio+0x1b9/0x200\n dissolve_free_huge_page+0x211/0x260\n __page_handle_poison+0x45/0xc0\n memory_failure+0x65e/0xc70\n hard_offline_page_store+0x55/0xa0\n kernfs_fop_write_iter+0x12c/0x1d0\n vfs_write+0x387/0x550\n ksys_write+0x64/0xe0\n do_syscall_64+0xca/0x1e0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\nRIP: 0033:0x7fc862314887\nCode: 10 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b7 0f 1f 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 51 c3 48 83 ec 28 48 89 54 24 18 48 89 74 24\nRSP: 002b:00007fff19311268 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\nRAX: ffffffffffffffda RBX: 000000000000000c RCX: 00007fc862314887\nRDX: 000000000000000c RSI: 000056405645fe10 RDI: 0000000000000001\nRBP: 000056405645fe10 R08: 00007fc8623d1460 R09: 000000007fffffff\nR10: 0000000000000000 R11: 0000000000000246 R12: 000000000000000c\nR13: 00007fc86241b780 R14: 00007fc862417600 R15: 00007fc862416a00\nIn short, below scene breaks the \n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1983184c22dd84a4d95a71e5c6775c2638557dc7"
          },
          {
            "url": "https://git.kernel.org/stable/c/49955b24002dc16a0ae2e83a57a2a6c863a1845c"
          },
          {
            "url": "https://git.kernel.org/stable/c/5ef7ba2799a3b5ed292b8f6407376e2c25ef002e"
          },
          {
            "url": "https://git.kernel.org/stable/c/882e1180c83f5b75bae03d0ccc31ccedfe5159de"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26988",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:16.420",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ninit/main.c: Fix potential static_command_line memory overflow\nWe allocate memory of size 'xlen + strlen(boot_command_line) + 1' for\nstatic_command_line, but the strings copied into static_command_line are\nextra_command_line and command_line, rather than extra_command_line and\nboot_command_line.\nWhen strlen(command_line) > strlen(boot_command_line), static_command_line\nwill overflow.\nThis patch just recovers strlen(command_line) which was miss-consolidated\nwith strlen(boot_command_line) in the commit f5c7310ac73e (\"init/main: add\nchecks for the return value of memblock_alloc*()\")",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0dc727a4e05400205358a22c3d01ccad2c8e1fe4"
          },
          {
            "url": "https://git.kernel.org/stable/c/46dad3c1e57897ab9228332f03e1c14798d2d3b9"
          },
          {
            "url": "https://git.kernel.org/stable/c/76c2f4d426a5358fced5d5990744d46f10a4ccea"
          },
          {
            "url": "https://git.kernel.org/stable/c/81cf85ae4f2dd5fa3e43021782aa72c4c85558e8"
          },
          {
            "url": "https://git.kernel.org/stable/c/936a02b5a9630c5beb0353c3085cc49d86c57034"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26989",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:16.577",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\narm64: hibernate: Fix level3 translation fault in swsusp_save()\nOn arm64 machines, swsusp_save() faults if it attempts to access\nMEMBLOCK_NOMAP memory ranges. This can be reproduced in QEMU using UEFI\nwhen booting with rodata=off debug_pagealloc=off and CONFIG_KFENCE=n:\n  Unable to handle kernel paging request at virtual address ffffff8000000000\n  Mem abort info:\n    ESR = 0x0000000096000007\n    EC = 0x25: DABT (current EL), IL = 32 bits\n    SET = 0, FnV = 0\n    EA = 0, S1PTW = 0\n    FSC = 0x07: level 3 translation fault\n  Data abort info:\n    ISV = 0, ISS = 0x00000007, ISS2 = 0x00000000\n    CM = 0, WnR = 0, TnD = 0, TagAccess = 0\n    GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0\n  swapper pgtable: 4k pages, 39-bit VAs, pgdp=00000000eeb0b000\n  [ffffff8000000000] pgd=180000217fff9803, p4d=180000217fff9803, pud=180000217fff9803, pmd=180000217fff8803, pte=0000000000000000\n  Internal error: Oops: 0000000096000007 [#1] SMP\n  Internal error: Oops: 0000000096000007 [#1] SMP\n  Modules linked in: xt_multiport ipt_REJECT nf_reject_ipv4 xt_conntrack nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 libcrc32c iptable_filter bpfilter rfkill at803x snd_hda_codec_hdmi snd_hda_intel snd_intel_dspcfg dwmac_generic stmmac_platform snd_hda_codec stmmac joydev pcs_xpcs snd_hda_core phylink ppdev lp parport ramoops reed_solomon ip_tables x_tables nls_iso8859_1 vfat multipath linear amdgpu amdxcp drm_exec gpu_sched drm_buddy hid_generic usbhid hid radeon video drm_suballoc_helper drm_ttm_helper ttm i2c_algo_bit drm_display_helper cec drm_kms_helper drm\n  CPU: 0 PID: 3663 Comm: systemd-sleep Not tainted 6.6.2+ #76\n  Source Version: 4e22ed63a0a48e7a7cff9b98b7806d8d4add7dc0\n  Hardware name: Greatwall GW-XXXXXX-XXX/GW-XXXXXX-XXX, BIOS KunLun BIOS V4.0 01/19/2021\n  pstate: 600003c5 (nZCv DAIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n  pc : swsusp_save+0x280/0x538\n  lr : swsusp_save+0x280/0x538\n  sp : ffffffa034a3fa40\n  x29: ffffffa034a3fa40 x28: ffffff8000001000 x27: 0000000000000000\n  x26: ffffff8001400000 x25: ffffffc08113e248 x24: 0000000000000000\n  x23: 0000000000080000 x22: ffffffc08113e280 x21: 00000000000c69f2\n  x20: ffffff8000000000 x19: ffffffc081ae2500 x18: 0000000000000000\n  x17: 6666662074736420 x16: 3030303030303030 x15: 3038666666666666\n  x14: 0000000000000b69 x13: ffffff9f89088530 x12: 00000000ffffffea\n  x11: 00000000ffff7fff x10: 00000000ffff7fff x9 : ffffffc08193f0d0\n  x8 : 00000000000bffe8 x7 : c0000000ffff7fff x6 : 0000000000000001\n  x5 : ffffffa0fff09dc8 x4 : 0000000000000000 x3 : 0000000000000027\n  x2 : 0000000000000000 x1 : 0000000000000000 x0 : 000000000000004e\n  Call trace:\n   swsusp_save+0x280/0x538\n   swsusp_arch_suspend+0x148/0x190\n   hibernation_snapshot+0x240/0x39c\n   hibernate+0xc4/0x378\n   state_store+0xf0/0x10c\n   kobj_attr_store+0x14/0x24\nThe reason is swsusp_save() -> copy_data_pages() -> page_is_saveable()\n-> kernel_page_present() assuming that a page is always present when\ncan_set_direct_map() is false (all of rodata_full,\ndebug_pagealloc_enabled() and arm64_kfence_can_set_direct_map() false),\nirrespective of the MEMBLOCK_NOMAP ranges. Such MEMBLOCK_NOMAP regions\nshould not be saved during hibernation.\nThis problem was introduced by changes to the pfn_valid() logic in\ncommit a7d9f306ba70 (\"arm64: drop pfn_valid_within() and simplify\npfn_valid()\").\nSimilar to other architectures, drop the !can_set_direct_map() check in\nkernel_page_present() so that page_is_savable() skips such pages.\n[catalin.marinas@arm.com: rework commit message]",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/022b19ebc31cce369c407617041a3db810db23b3"
          },
          {
            "url": "https://git.kernel.org/stable/c/31f815cb436082e72d34ed2e8a182140a73ebdf4"
          },
          {
            "url": "https://git.kernel.org/stable/c/50449ca66cc5a8cbc64749cf4b9f3d3fc5f4b457"
          },
          {
            "url": "https://git.kernel.org/stable/c/813f5213f2c612dc800054859aaa396ec8ad7069"
          },
          {
            "url": "https://git.kernel.org/stable/c/f7e71a7cf399f53ff9fc314ca3836dc913b05bd6"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26990",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:16.673",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nKVM: x86/mmu: Write-protect L2 SPTEs in TDP MMU when clearing dirty status\nCheck kvm_mmu_page_ad_need_write_protect() when deciding whether to\nwrite-protect or clear D-bits on TDP MMU SPTEs, so that the TDP MMU\naccounts for any role-specific reasons for disabling D-bit dirty logging.\nSpecifically, TDP MMU SPTEs must be write-protected when the TDP MMU is\nbeing used to run an L2 (i.e. L1 has disabled EPT) and PML is enabled.\nKVM always disables PML when running L2, even when L1 and L2 GPAs are in\nthe some domain, so failing to write-protect TDP MMU SPTEs will cause\nwrites made by L2 to not be reflected in the dirty log.\n[sean: massage shortlog and changelog, tweak ternary op formatting]",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2673dfb591a359c75080dd5af3da484b89320d22"
          },
          {
            "url": "https://git.kernel.org/stable/c/cdf811a937471af2d1facdf8ae80e5e68096f1ed"
          },
          {
            "url": "https://git.kernel.org/stable/c/e20bff0f1b2de9cfe303dd35ff46470104a87404"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26991",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:16.820",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nKVM: x86/mmu: x86: Don't overflow lpage_info when checking attributes\nFix KVM_SET_MEMORY_ATTRIBUTES to not overflow lpage_info array and trigger\nKASAN splat, as seen in the private_mem_conversions_test selftest.\nWhen memory attributes are set on a GFN range, that range will have\nspecific properties applied to the TDP. A huge page cannot be used when\nthe attributes are inconsistent, so they are disabled for those the\nspecific huge pages. For internal KVM reasons, huge pages are also not\nallowed to span adjacent memslots regardless of whether the backing memory\ncould be mapped as huge.\nWhat GFNs support which huge page sizes is tracked by an array of arrays\n'lpage_info' on the memslot, of ‘kvm_lpage_info’ structs. Each index of\nlpage_info contains a vmalloc allocated array of these for a specific\nsupported page size. The kvm_lpage_info denotes whether a specific huge\npage (GFN and page size) on the memslot is supported. These arrays include\nindices for unaligned head and tail huge pages.\nPreventing huge pages from spanning adjacent memslot is covered by\nincrementing the count in head and tail kvm_lpage_info when the memslot is\nallocated, but disallowing huge pages for memory that has mixed attributes\nhas to be done in a more complicated way. During the\nKVM_SET_MEMORY_ATTRIBUTES ioctl KVM updates lpage_info for each memslot in\nthe range that has mismatched attributes. KVM does this a memslot at a\ntime, and marks a special bit, KVM_LPAGE_MIXED_FLAG, in the kvm_lpage_info\nfor any huge page. This bit is essentially a permanently elevated count.\nSo huge pages will not be mapped for the GFN at that page size if the\ncount is elevated in either case: a huge head or tail page unaligned to\nthe memslot or if KVM_LPAGE_MIXED_FLAG is set because it has mixed\nattributes.\nTo determine whether a huge page has consistent attributes, the\nKVM_SET_MEMORY_ATTRIBUTES operation checks an xarray to make sure it\nconsistently has the incoming attribute. Since level - 1 huge pages are\naligned to level huge pages, it employs an optimization. As long as the\nlevel - 1 huge pages are checked first, it can just check these and assume\nthat if each level - 1 huge page contained within the level sized huge\npage is not mixed, then the level size huge page is not mixed. This\noptimization happens in the helper hugepage_has_attrs().\nUnfortunately, although the kvm_lpage_info array representing page size\n'level' will contain an entry for an unaligned tail page of size level,\nthe array for level - 1  will not contain an entry for each GFN at page\nsize level. The level - 1 array will only contain an index for any\nunaligned region covered by level - 1 huge page size, which can be a\nsmaller region. So this causes the optimization to overflow the level - 1\nkvm_lpage_info and perform a vmalloc out of bounds read.\nIn some cases of head and tail pages where an overflow could happen,\ncallers skip the operation completely as KVM_LPAGE_MIXED_FLAG is not\nrequired to prevent huge pages as discussed earlier. But for memslots that\nare smaller than the 1GB page size, it does call hugepage_has_attrs(). In\nthis case the huge page is both the head and tail page. The issue can be\nobserved simply by compiling the kernel with CONFIG_KASAN_VMALLOC and\nrunning the selftest “private_mem_conversions_test”, which produces the\noutput like the following:\nBUG: KASAN: vmalloc-out-of-bounds in hugepage_has_attrs+0x7e/0x110\nRead of size 4 at addr ffffc900000a3008 by task private_mem_con/169\nCall Trace:\n  dump_stack_lvl\n  print_report\n  ? __virt_addr_valid\n  ? hugepage_has_attrs\n  ? hugepage_has_attrs\n  kasan_report\n  ? hugepage_has_attrs\n  hugepage_has_attrs\n  kvm_arch_post_set_memory_attributes\n  kvm_vm_ioctl\nIt is a little ambiguous whether the unaligned head page (in the bug case\nalso the tail page) should be expected to have KVM_LPAGE_MIXED_FLAG set.\nIt is not functionally required, as the unal\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/048cc4a028e635d339687ed968985d2d1669494c"
          },
          {
            "url": "https://git.kernel.org/stable/c/992b54bd083c5bee24ff7cc35991388ab08598c4"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26992",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:16.957",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nKVM: x86/pmu: Disable support for adaptive PEBS\nDrop support for virtualizing adaptive PEBS, as KVM's implementation is\narchitecturally broken without an obvious/easy path forward, and because\nexposing adaptive PEBS can leak host LBRs to the guest, i.e. can leak\nhost kernel addresses to the guest.\nBug #1 is that KVM doesn't account for the upper 32 bits of\nIA32_FIXED_CTR_CTRL when (re)programming fixed counters, e.g\nfixed_ctrl_field() drops the upper bits, reprogram_fixed_counters()\nstores local variables as u8s and truncates the upper bits too, etc.\nBug #2 is that, because KVM _always_ sets precise_ip to a non-zero value\nfor PEBS events, perf will _always_ generate an adaptive record, even if\nthe guest requested a basic record.  Note, KVM will also enable adaptive\nPEBS in individual *counter*, even if adaptive PEBS isn't exposed to the\nguest, but this is benign as MSR_PEBS_DATA_CFG is guaranteed to be zero,\ni.e. the guest will only ever see Basic records.\nBug #3 is in perf.  intel_pmu_disable_fixed() doesn't clear the upper\nbits either, i.e. leaves ICL_FIXED_0_ADAPTIVE set, and\nintel_pmu_enable_fixed() effectively doesn't clear ICL_FIXED_0_ADAPTIVE\neither.  I.e. perf _always_ enables ADAPTIVE counters, regardless of what\nKVM requests.\nBug #4 is that adaptive PEBS *might* effectively bypass event filters set\nby the host, as \"Updated Memory Access Info Group\" records information\nthat might be disallowed by userspace via KVM_SET_PMU_EVENT_FILTER.\nBug #5 is that KVM doesn't ensure LBR MSRs hold guest values (or at least\nzeros) when entering a vCPU with adaptive PEBS, which allows the guest\nto read host LBRs, i.e. host RIPs/addresses, by enabling \"LBR Entries\"\nrecords.\nDisable adaptive PEBS support as an immediate fix due to the severity of\nthe LBR leak in particular, and because fixing all of the bugs will be\nnon-trivial, e.g. not suitable for backporting to stable kernels.\nNote!  This will break live migration, but trying to make KVM play nice\nwith live migration would be quite complicated, wouldn't be guaranteed to\nwork (i.e. KVM might still kill/confuse the guest), and it's not clear\nthat there are any publicly available VMMs that support adaptive PEBS,\nlet alone live migrate VMs that support adaptive PEBS, e.g. QEMU doesn't\nsupport PEBS in any capacity.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/037e48ceccf163899374b601afb6ae8d0bf1d2ac"
          },
          {
            "url": "https://git.kernel.org/stable/c/0fb74c00d140a66128afc0003785dcc57e69d312"
          },
          {
            "url": "https://git.kernel.org/stable/c/7a7650b3ac23e5fc8c990f00e94f787dc84e3175"
          },
          {
            "url": "https://git.kernel.org/stable/c/9e985cbf2942a1bb8fcef9adc2a17d90fd7ca8ee"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26993",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:17.110",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nfs: sysfs: Fix reference leak in sysfs_break_active_protection()\nThe sysfs_break_active_protection() routine has an obvious reference\nleak in its error path.  If the call to kernfs_find_and_get() fails then\nkn will be NULL, so the companion sysfs_unbreak_active_protection()\nroutine won't get called (and would only cause an access violation by\ntrying to dereference kn->parent if it was called).  As a result, the\nreference to kobj acquired at the start of the function will never be\nreleased.\nFix the leak by adding an explicit kobject_put() call when kn is NULL.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/43f00210cb257bcb0387e8caeb4b46375d67f30c"
          },
          {
            "url": "https://git.kernel.org/stable/c/5d43e072285e81b0b63cee7189b3357c7768a43b"
          },
          {
            "url": "https://git.kernel.org/stable/c/a4c99b57d43bab45225ba92d574a8683f9edc8e4"
          },
          {
            "url": "https://git.kernel.org/stable/c/a90bca2228c0646fc29a72689d308e5fe03e6d78"
          },
          {
            "url": "https://git.kernel.org/stable/c/ac107356aabc362aaeb77463e814fc067a5d3957"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26994",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:17.207",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nspeakup: Avoid crash on very long word\nIn case a console is set up really large and contains a really long word\n(> 256 characters), we have to stop before the length of the word buffer.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0d130158db29f5e0b3893154908cf618896450a8"
          },
          {
            "url": "https://git.kernel.org/stable/c/0efb15c14c493263cb3a5f65f5ddfd4603d19a76"
          },
          {
            "url": "https://git.kernel.org/stable/c/89af25bd4b4bf6a71295f07e07a8ae7dc03c6595"
          },
          {
            "url": "https://git.kernel.org/stable/c/8defb1d22ba0395b81feb963b96e252b097ba76f"
          },
          {
            "url": "https://git.kernel.org/stable/c/c8d2f34ea96ea3bce6ba2535f867f0d4ee3b22e1"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26995",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:17.313",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nusb: typec: tcpm: Correct the PDO counting in pd_set\nOff-by-one errors happen because nr_snk_pdo and nr_src_pdo are\nincorrectly added one. The index of the loop is equal to the number of\nPDOs to be updated when leaving the loop and it doesn't need to be added\none.\nWhen doing the power negotiation, TCPM relies on the \"nr_snk_pdo\" as\nthe size of the local sink PDO array to match the Source capabilities\nof the partner port. If the off-by-one overflow occurs, a wrong RDO\nmight be sent and unexpected power transfer might happen such as over\nvoltage or over current (than expected).\n\"nr_src_pdo\" is used to set the Rp level when the port is in Source\nrole. It is also the array size of the local Source capabilities when\nfilling up the buffer which will be sent as the Source PDOs (such as\nin Power Negotiation). If the off-by-one overflow occurs, a wrong Rp\nlevel might be set and wrong Source PDOs will be sent to the partner\nport. This could potentially cause over current or port resets.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/c4128304c2169b4664ed6fb6200f228cead2ab70"
          },
          {
            "url": "https://git.kernel.org/stable/c/f3da3192cdd3fefe213390e976eec424a8e270b5"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26996",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:17.480",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nusb: gadget: f_ncm: Fix UAF ncm object at re-bind after usb ep transport error\nWhen ncm function is working and then stop usb0 interface for link down,\neth_stop() is called. At this piont, accidentally if usb transport error\nshould happen in usb_ep_enable(), 'in_ep' and/or 'out_ep' may not be enabled.\nAfter that, ncm_disable() is called to disable for ncm unbind\nbut gether_disconnect() is never called since 'in_ep' is not enabled.\nAs the result, ncm object is released in ncm unbind\nbut 'dev->port_usb' associated to 'ncm->port' is not NULL.\nAnd when ncm bind again to recover netdev, ncm object is reallocated\nbut usb0 interface is already associated to previous released ncm object.\nTherefore, once usb0 interface is up and eth_start_xmit() is called,\nreleased ncm object is dereferrenced and it might cause use-after-free memory.\n[function unlink via configfs]\n  usb0: eth_stop dev->port_usb=ffffff9b179c3200\n  --> error happens in usb_ep_enable().\n  NCM: ncm_disable: ncm=ffffff9b179c3200\n  --> no gether_disconnect() since ncm->port.in_ep->enabled is false.\n  NCM: ncm_unbind: ncm unbind ncm=ffffff9b179c3200\n  NCM: ncm_free: ncm free ncm=ffffff9b179c3200   <-- released ncm\n[function link via configfs]\n  NCM: ncm_alloc: ncm alloc ncm=ffffff9ac4f8a000\n  NCM: ncm_bind: ncm bind ncm=ffffff9ac4f8a000\n  NCM: ncm_set_alt: ncm=ffffff9ac4f8a000 alt=0\n  usb0: eth_open dev->port_usb=ffffff9b179c3200  <-- previous released ncm\n  usb0: eth_start dev->port_usb=ffffff9b179c3200 <--\n  eth_start_xmit()\n  --> dev->wrap()\n  Unable to handle kernel paging request at virtual address dead00000000014f\nThis patch addresses the issue by checking if 'ncm->netdev' is not NULL at\nncm_disable() to call gether_disconnect() to deassociate 'dev->port_usb'.\nIt's more reasonable to check 'ncm->netdev' to call gether_connect/disconnect\nrather than check 'ncm->port.in_ep->enabled' since it might not be enabled\nbut the gether connection might be established.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0588bbbd718a8130b98c54518f1e0b569ce60a93"
          },
          {
            "url": "https://git.kernel.org/stable/c/6334b8e4553cc69f51e383c9de545082213d785e"
          },
          {
            "url": "https://git.kernel.org/stable/c/7250326cbb1f4f90391ac511a126b936cefb5bb7"
          },
          {
            "url": "https://git.kernel.org/stable/c/7f67c2020cb08499c400abf0fc32c65e4d9a09ca"
          },
          {
            "url": "https://git.kernel.org/stable/c/f356fd0cbd9c9cbd0854657a80d1608d0d732db3"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26997",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:17.637",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nusb: dwc2: host: Fix dereference issue in DDMA completion flow.\nFixed variable dereference issue in DDMA completion flow.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/55656b2afd5f1efcec4245f3e7e814c2a9ef53f6"
          },
          {
            "url": "https://git.kernel.org/stable/c/8a139fa44870e84ac228b7b76423a49610e5ba9a"
          },
          {
            "url": "https://git.kernel.org/stable/c/8aa5c28ac65cb5e7f1b9c0c3238c00b661dd2b8c"
          },
          {
            "url": "https://git.kernel.org/stable/c/9de10b59d16880a0a3ae2876c142fe54ce45d816"
          },
          {
            "url": "https://git.kernel.org/stable/c/eed04fa96c48790c1cce73c8a248e9d460b088f8"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26998",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:17.780",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nserial: core: Clearing the circular buffer before NULLifying it\nThe circular buffer is NULLified in uart_tty_port_shutdown()\nunder the spin lock. However, the PM or other timer based callbacks\nmay still trigger after this event without knowning that buffer pointer\nis not valid. Since the serial code is a bit inconsistent in checking\nthe buffer state (some rely on the head-tail positions, some on the\nbuffer pointer), it's better to have both aligned, i.e. buffer pointer\nto be NULL and head-tail possitions to be the same, meaning it's empty.\nThis will prevent asynchronous calls to dereference NULL pointer as\nreported recently in 8250 case:\n  BUG: kernel NULL pointer dereference, address: 00000cf5\n  Workqueue: pm pm_runtime_work\n  EIP: serial8250_tx_chars (drivers/tty/serial/8250/8250_port.c:1809)\n  ...\n  ? serial8250_tx_chars (drivers/tty/serial/8250/8250_port.c:1809)\n  __start_tx (drivers/tty/serial/8250/8250_port.c:1551)\n  serial8250_start_tx (drivers/tty/serial/8250/8250_port.c:1654)\n  serial_port_runtime_suspend (include/linux/serial_core.h:667 drivers/tty/serial/serial_port.c:63)\n  __rpm_callback (drivers/base/power/runtime.c:393)\n  ? serial_port_remove (drivers/tty/serial/serial_port.c:50)\n  rpm_suspend (drivers/base/power/runtime.c:447)\nThe proposed change will prevent ->start_tx() to be called during\nsuspend on shut down port.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/7ae7104d54342433a3a73975f6569beefdd86350"
          },
          {
            "url": "https://git.kernel.org/stable/c/9cf7ea2eeb745213dc2a04103e426b960e807940"
          },
          {
            "url": "https://git.kernel.org/stable/c/bb1118905e875c111d7ccef9aee86ac5e4e7f985"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26999",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:17.870",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nserial/pmac_zilog: Remove flawed mitigation for rx irq flood\nThe mitigation was intended to stop the irq completely. That may be\nbetter than a hard lock-up but it turns out that you get a crash anyway\nif you're using pmac_zilog as a serial console:\nttyPZ0: pmz: rx irq flood !\nBUG: spinlock recursion on CPU#0, swapper/0\nThat's because the pr_err() call in pmz_receive_chars() results in\npmz_console_write() attempting to lock a spinlock already locked in\npmz_interrupt(). With CONFIG_DEBUG_SPINLOCK=y, this produces a fatal\nBUG splat. The spinlock in question is the one in struct uart_port.\nEven when it's not fatal, the serial port rx function ceases to work.\nAlso, the iteration limit doesn't play nicely with QEMU, as can be\nseen in the bug report linked below.\nA web search for other reports of the error message \"pmz: rx irq flood\"\ndidn't produce anything. So I don't think this code is needed any more.\nRemove it.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1be3226445362bfbf461c92a5bcdb1723f2e4907"
          },
          {
            "url": "https://git.kernel.org/stable/c/52aaf1ff14622a04148dbb9ccce6d9de5d534ea7"
          },
          {
            "url": "https://git.kernel.org/stable/c/7a3bbe41efa55323b6ea3c35fa15941d4dbecdef"
          },
          {
            "url": "https://git.kernel.org/stable/c/bbaafbb4651fede8d3c3881601ecaa4f834f9d3f"
          },
          {
            "url": "https://git.kernel.org/stable/c/ca09dfc3cfdf89e6af3ac24e1c6c0be5c575a729"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27000",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:18.140",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nserial: mxs-auart: add spinlock around changing cts state\nThe uart_handle_cts_change() function in serial_core expects the caller\nto hold uport->lock. For example, I have seen the below kernel splat,\nwhen the Bluetooth driver is loaded on an i.MX28 board.\n    [   85.119255] ------------[ cut here ]------------\n    [   85.124413] WARNING: CPU: 0 PID: 27 at /drivers/tty/serial/serial_core.c:3453 uart_handle_cts_change+0xb4/0xec\n    [   85.134694] Modules linked in: hci_uart bluetooth ecdh_generic ecc wlcore_sdio configfs\n    [   85.143314] CPU: 0 PID: 27 Comm: kworker/u3:0 Not tainted 6.6.3-00021-gd62a2f068f92 #1\n    [   85.151396] Hardware name: Freescale MXS (Device Tree)\n    [   85.156679] Workqueue: hci0 hci_power_on [bluetooth]\n    (...)\n    [   85.191765]  uart_handle_cts_change from mxs_auart_irq_handle+0x380/0x3f4\n    [   85.198787]  mxs_auart_irq_handle from __handle_irq_event_percpu+0x88/0x210\n    (...)",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2c9b943e9924cf1269e44289bc5e60e51b0f5270"
          },
          {
            "url": "https://git.kernel.org/stable/c/54c4ec5f8c471b7c1137a1f769648549c423c026"
          },
          {
            "url": "https://git.kernel.org/stable/c/5f40fd6ca2cf0bfbc5a5c9e403dfce8ca899ba37"
          },
          {
            "url": "https://git.kernel.org/stable/c/94b0e65c75f4af888ab2dd6c90f060f762924e86"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27001",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:18.330",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ncomedi: vmk80xx: fix incomplete endpoint checking\nWhile vmk80xx does have endpoint checking implemented, some things\ncan fall through the cracks. Depending on the hardware model,\nURBs can have either bulk or interrupt type, and current version\nof vmk80xx_find_usb_endpoints() function does not take that fully\ninto account. While this warning does not seem to be too harmful,\nat the very least it will crash systems with 'panic_on_warn' set on\nthem.\nFix the issue found by Syzkaller [1] by somewhat simplifying the\nendpoint checking process with usb_find_common_endpoints() and\nensuring that only expected endpoint types are present.\nThis patch has not been tested on real hardware.\n[1] Syzkaller report:\nusb 1-1: BOGUS urb xfer, pipe 1 != type 3\nWARNING: CPU: 0 PID: 781 at drivers/usb/core/urb.c:504 usb_submit_urb+0xc4e/0x18c0 drivers/usb/core/urb.c:503\n...\nCall Trace:\n <TASK>\n usb_start_wait_urb+0x113/0x520 drivers/usb/core/message.c:59\n vmk80xx_reset_device drivers/comedi/drivers/vmk80xx.c:227 [inline]\n vmk80xx_auto_attach+0xa1c/0x1a40 drivers/comedi/drivers/vmk80xx.c:818\n comedi_auto_config+0x238/0x380 drivers/comedi/drivers.c:1067\n usb_probe_interface+0x5cd/0xb00 drivers/usb/core/driver.c:399\n...\nSimilar issue also found by Syzkaller:",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/59f33af9796160f851641d960bd93937f282c696"
          },
          {
            "url": "https://git.kernel.org/stable/c/6ec3514a7d35ad9cfab600187612c29f669069d2"
          },
          {
            "url": "https://git.kernel.org/stable/c/ac882d6b21bffecb57bcc4486701239eef5aa67b"
          },
          {
            "url": "https://git.kernel.org/stable/c/b0b268eeb087e324ef3ea71f8e6cabd07630517f"
          },
          {
            "url": "https://git.kernel.org/stable/c/d1718530e3f640b7d5f0050e725216eab57a85d8"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27002",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:18.437",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nclk: mediatek: Do a runtime PM get on controllers during probe\nmt8183-mfgcfg has a mutual dependency with genpd during the probing\nstage, which leads to a deadlock in the following call stack:\nCPU0:  genpd_lock --> clk_prepare_lock\ngenpd_power_off_work_fn()\n genpd_lock()\n generic_pm_domain::power_off()\n    clk_unprepare()\n      clk_prepare_lock()\nCPU1: clk_prepare_lock --> genpd_lock\nclk_register()\n  __clk_core_init()\n    clk_prepare_lock()\n    clk_pm_runtime_get()\n      genpd_lock()\nDo a runtime PM get at the probe function to make sure clk_register()\nwon't acquire the genpd lock. Instead of only modifying mt8183-mfgcfg,\ndo this on all mediatek clock controller probings because we don't\nbelieve this would cause any regression.\nVerified on MT8183 and MT8192 Chromebooks.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/165d226472575b213dd90dfda19d1605dd7c19a8"
          },
          {
            "url": "https://git.kernel.org/stable/c/2f7b1d8b5505efb0057cd1ab85fca206063ea4c3"
          },
          {
            "url": "https://git.kernel.org/stable/c/b62ed25feb342eab052822eff0c554873799a4f5"
          },
          {
            "url": "https://git.kernel.org/stable/c/c0dcd5c072e2a3fff886f673e6a5d9bf8090c4cc"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27003",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:18.597",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nclk: Get runtime PM before walking tree for clk_summary\nSimilar to the previous commit, we should make sure that all devices are\nruntime resumed before printing the clk_summary through debugfs. Failure\nto do so would result in a deadlock if the thread is resuming a device\nto print clk state and that device is also runtime resuming in another\nthread, e.g the screen is turning on and the display driver is starting\nup. We remove the calls to clk_pm_runtime_{get,put}() in this path\nbecause they're superfluous now that we know the devices are runtime\nresumed. This also squashes a bug where the return value of\nclk_pm_runtime_get() wasn't checked, leading to an RPM count underflow\non error paths.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2c077fdfd09dffb31a890e5095c8ab205138a42e"
          },
          {
            "url": "https://git.kernel.org/stable/c/83ada89e4a86e2b28ea2b5113c76d6dc7560a4d0"
          },
          {
            "url": "https://git.kernel.org/stable/c/9d1e795f754db1ac3344528b7af0b17b8146f321"
          },
          {
            "url": "https://git.kernel.org/stable/c/b457105309d388e4081c716cf7b81d517ff74db4"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27004",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:18.763",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nclk: Get runtime PM before walking tree during disable_unused\nDoug reported [1] the following hung task:\n INFO: task swapper/0:1 blocked for more than 122 seconds.\n       Not tainted 5.15.149-21875-gf795ebc40eb8 #1\n \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\n task:swapper/0       state:D stack:    0 pid:    1 ppid:     0 flags:0x00000008\n Call trace:\n  __switch_to+0xf4/0x1f4\n  __schedule+0x418/0xb80\n  schedule+0x5c/0x10c\n  rpm_resume+0xe0/0x52c\n  rpm_resume+0x178/0x52c\n  __pm_runtime_resume+0x58/0x98\n  clk_pm_runtime_get+0x30/0xb0\n  clk_disable_unused_subtree+0x58/0x208\n  clk_disable_unused_subtree+0x38/0x208\n  clk_disable_unused_subtree+0x38/0x208\n  clk_disable_unused_subtree+0x38/0x208\n  clk_disable_unused_subtree+0x38/0x208\n  clk_disable_unused+0x4c/0xe4\n  do_one_initcall+0xcc/0x2d8\n  do_initcall_level+0xa4/0x148\n  do_initcalls+0x5c/0x9c\n  do_basic_setup+0x24/0x30\n  kernel_init_freeable+0xec/0x164\n  kernel_init+0x28/0x120\n  ret_from_fork+0x10/0x20\n INFO: task kworker/u16:0:9 blocked for more than 122 seconds.\n       Not tainted 5.15.149-21875-gf795ebc40eb8 #1\n \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\n task:kworker/u16:0   state:D stack:    0 pid:    9 ppid:     2 flags:0x00000008\n Workqueue: events_unbound deferred_probe_work_func\n Call trace:\n  __switch_to+0xf4/0x1f4\n  __schedule+0x418/0xb80\n  schedule+0x5c/0x10c\n  schedule_preempt_disabled+0x2c/0x48\n  __mutex_lock+0x238/0x488\n  __mutex_lock_slowpath+0x1c/0x28\n  mutex_lock+0x50/0x74\n  clk_prepare_lock+0x7c/0x9c\n  clk_core_prepare_lock+0x20/0x44\n  clk_prepare+0x24/0x30\n  clk_bulk_prepare+0x40/0xb0\n  mdss_runtime_resume+0x54/0x1c8\n  pm_generic_runtime_resume+0x30/0x44\n  __genpd_runtime_resume+0x68/0x7c\n  genpd_runtime_resume+0x108/0x1f4\n  __rpm_callback+0x84/0x144\n  rpm_callback+0x30/0x88\n  rpm_resume+0x1f4/0x52c\n  rpm_resume+0x178/0x52c\n  __pm_runtime_resume+0x58/0x98\n  __device_attach+0xe0/0x170\n  device_initial_probe+0x1c/0x28\n  bus_probe_device+0x3c/0x9c\n  device_add+0x644/0x814\n  mipi_dsi_device_register_full+0xe4/0x170\n  devm_mipi_dsi_device_register_full+0x28/0x70\n  ti_sn_bridge_probe+0x1dc/0x2c0\n  auxiliary_bus_probe+0x4c/0x94\n  really_probe+0xcc/0x2c8\n  __driver_probe_device+0xa8/0x130\n  driver_probe_device+0x48/0x110\n  __device_attach_driver+0xa4/0xcc\n  bus_for_each_drv+0x8c/0xd8\n  __device_attach+0xf8/0x170\n  device_initial_probe+0x1c/0x28\n  bus_probe_device+0x3c/0x9c\n  deferred_probe_work_func+0x9c/0xd8\n  process_one_work+0x148/0x518\n  worker_thread+0x138/0x350\n  kthread+0x138/0x1e0\n  ret_from_fork+0x10/0x20\nThe first thread is walking the clk tree and calling\nclk_pm_runtime_get() to power on devices required to read the clk\nhardware via struct clk_ops::is_enabled(). This thread holds the clk\nprepare_lock, and is trying to runtime PM resume a device, when it finds\nthat the device is in the process of resuming so the thread schedule()s\naway waiting for the device to finish resuming before continuing. The\nsecond thread is runtime PM resuming the same device, but the runtime\nresume callback is calling clk_prepare(), trying to grab the\nprepare_lock waiting on the first thread.\nThis is a classic ABBA deadlock. To properly fix the deadlock, we must\nnever runtime PM resume or suspend a device with the clk prepare_lock\nheld. Actually doing that is near impossible today because the global\nprepare_lock would have to be dropped in the middle of the tree, the\ndevice runtime PM resumed/suspended, and then the prepare_lock grabbed\nagain to ensure consistency of the clk tree topology. If anything\nchanges with the clk tree in the meantime, we've lost and will need to\nstart the operation all over again.\nLuckily, most of the time we're simply incrementing or decrementing the\nruntime PM count on an active device, so we don't have the chance to\nschedule away with the prepare_lock held. Let's fix this immediate\nproblem that can be\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/115554862294397590088ba02f11f2aba6d5016c"
          },
          {
            "url": "https://git.kernel.org/stable/c/60ff482c4205a5aac3b0595ab794cfd62295dab5"
          },
          {
            "url": "https://git.kernel.org/stable/c/a29ec0465dce0b871003698698ac6fa92c9a5034"
          },
          {
            "url": "https://git.kernel.org/stable/c/a424e713e0cc33d4b969cfda25b9f46df4d7b5bc"
          },
          {
            "url": "https://git.kernel.org/stable/c/e581cf5d216289ef292d1a4036d53ce90e122469"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27005",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:18.883",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ninterconnect: Don't access req_list while it's being manipulated\nThe icc_lock mutex was split into separate icc_lock and icc_bw_lock\nmutexes in [1] to avoid lockdep splats. However, this didn't adequately\nprotect access to icc_node::req_list.\nThe icc_set_bw() function will eventually iterate over req_list while\nonly holding icc_bw_lock, but req_list can be modified while only\nholding icc_lock. This causes races between icc_set_bw(), of_icc_get(),\nand icc_put().\nExample A:\n  CPU0                               CPU1\n  ----                               ----\n  icc_set_bw(path_a)\n    mutex_lock(&icc_bw_lock);\n                                     icc_put(path_b)\n                                       mutex_lock(&icc_lock);\n    aggregate_requests()\n      hlist_for_each_entry(r, ...\n                                       hlist_del(...\n        <r = invalid pointer>\nExample B:\n  CPU0                               CPU1\n  ----                               ----\n  icc_set_bw(path_a)\n    mutex_lock(&icc_bw_lock);\n                                     path_b = of_icc_get()\n                                       of_icc_get_by_index()\n                                         mutex_lock(&icc_lock);\n                                         path_find()\n                                           path_init()\n    aggregate_requests()\n      hlist_for_each_entry(r, ...\n                                             hlist_add_head(...\n        <r = invalid pointer>\nFix this by ensuring icc_bw_lock is always held before manipulating\nicc_node::req_list. The additional places icc_bw_lock is held don't\nperform any memory allocations, so we should still be safe from the\noriginal lockdep splats that motivated the separate locks.\n[1] commit af42269c3523 (\"interconnect: Fix locking for runpm vs reclaim\")",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4c65507121ea8e0b47fae6d2049c8688390d46b6"
          },
          {
            "url": "https://git.kernel.org/stable/c/d0d04efa2e367921654b5106cc5c05e3757c2b42"
          },
          {
            "url": "https://git.kernel.org/stable/c/de1bf25b6d771abdb52d43546cf57ad775fb68a1"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27006",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:19.053",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nthermal/debugfs: Add missing count increment to thermal_debug_tz_trip_up()\nThe count field in struct trip_stats, representing the number of times\nthe zone temperature was above the trip point, needs to be incremented\nin thermal_debug_tz_trip_up(), for two reasons.\nFirst, if a trip point is crossed on the way up for the first time,\nthermal_debug_update_temp() called from update_temperature() does\nnot see it because it has not been added to trips_crossed[] array\nin the thermal zone's struct tz_debugfs object yet.  Therefore, when\nthermal_debug_tz_trip_up() is called after that, the trip point's\ncount value is 0, and the attempt to divide by it during the average\ntemperature computation leads to a divide error which causes the kernel\nto crash.  Setting the count to 1 before the division by incrementing it\nfixes this problem.\nSecond, if a trip point is crossed on the way up, but it has been\ncrossed on the way up already before, its count value needs to be\nincremented to make a record of the fact that the zone temperature is\nabove the trip now.  Without doing that, if the mitigations applied\nafter crossing the trip cause the zone temperature to drop below its\nthreshold, the count will not be updated for this episode at all and\nthe average temperature in the trip statistics record will be somewhat\nhigher than it should be.\nCc :6.8+ <stable@vger.kernel.org> # 6.8+",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/9c8215d32e730b597c809a9d2090bf8ec1b79fcf"
          },
          {
            "url": "https://git.kernel.org/stable/c/b552f63cd43735048bbe9bfbb7a9dcfce166fbdd"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27007",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:19.180",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nuserfaultfd: change src_folio after ensuring it's unpinned in UFFDIO_MOVE\nCommit d7a08838ab74 (\"mm: userfaultfd: fix unexpected change to src_folio\nwhen UFFDIO_MOVE fails\") moved the src_folio->{mapping, index} changing to\nafter clearing the page-table and ensuring that it's not pinned.  This\navoids failure of swapout+migration and possibly memory corruption.\nHowever, the commit missed fixing it in the huge-page case.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/c0205eaf3af9f5db14d4b5ee4abacf4a583c3c50"
          },
          {
            "url": "https://git.kernel.org/stable/c/df5f6e683e7f21a15d8be6e7a0c7a46436963ebe"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27008",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:19.240",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm: nv04: Fix out of bounds access\nWhen Output Resource (dcb->or) value is assigned in\nfabricate_dcb_output(), there may be out of bounds access to\ndac_users array in case dcb->or is zero because ffs(dcb->or) is\nused as index there.\nThe 'or' argument of fabricate_dcb_output() must be interpreted as a\nnumber of bit to set, not value.\nUtilize macros from 'enum nouveau_or' in calls instead of hardcoding.\nFound by Linux Verification Center (linuxtesting.org) with SVACE.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/26212da39ee14a52c76a202c6ae5153a84f579a5"
          },
          {
            "url": "https://git.kernel.org/stable/c/5fd4b090304e450aa0e7cc9cc2b4873285c6face"
          },
          {
            "url": "https://git.kernel.org/stable/c/6690cc2732e2a8d0eaca44dcbac032a4b0148042"
          },
          {
            "url": "https://git.kernel.org/stable/c/cf92bb778eda7830e79452c6917efa8474a30c1e"
          },
          {
            "url": "https://git.kernel.org/stable/c/df0991da7db846f7fa4ec6740350f743d3b69b04"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27009",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:19.360",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ns390/cio: fix race condition during online processing\nA race condition exists in ccw_device_set_online() that can cause the\nonline process to fail, leaving the affected device in an inconsistent\nstate. As a result, subsequent attempts to set that device online fail\nwith return code ENODEV.\nThe problem occurs when a path verification request arrives after\na wait for final device state completed, but before the result state\nis evaluated.\nFix this by ensuring that the CCW-device lock is held between\ndetermining final state and checking result state.\nNote that since:\ncommit 2297791c92d0 (\"s390/cio: dont unregister subchannel from child-drivers\")\npath verification requests are much more likely to occur during boot,\nresulting in an increased chance of this race condition occurring.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2d8527f2f911fab84aec04df4788c0c23af3df48"
          },
          {
            "url": "https://git.kernel.org/stable/c/2df56f4ea769ff81e51bbb05699989603bde9c49"
          },
          {
            "url": "https://git.kernel.org/stable/c/3076b3c38a704e10df5e143c213653309d532538"
          },
          {
            "url": "https://git.kernel.org/stable/c/559f3a6333397ab6cd4a696edd65a70b6be62c6e"
          },
          {
            "url": "https://git.kernel.org/stable/c/a4234decd0fe429832ca81c4637be7248b88b49e"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27010",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:19.467",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/sched: Fix mirred deadlock on device recursion\nWhen the mirred action is used on a classful egress qdisc and a packet is\nmirrored or redirected to self we hit a qdisc lock deadlock.\nSee trace below.\n[..... other info removed for brevity....]\n[   82.890906]\n[   82.890906] ============================================\n[   82.890906] WARNING: possible recursive locking detected\n[   82.890906] 6.8.0-05205-g77fadd89fe2d-dirty #213 Tainted: G        W\n[   82.890906] --------------------------------------------\n[   82.890906] ping/418 is trying to acquire lock:\n[   82.890906] ffff888006994110 (&sch->q.lock){+.-.}-{3:3}, at:\n__dev_queue_xmit+0x1778/0x3550\n[   82.890906]\n[   82.890906] but task is already holding lock:\n[   82.890906] ffff888006994110 (&sch->q.lock){+.-.}-{3:3}, at:\n__dev_queue_xmit+0x1778/0x3550\n[   82.890906]\n[   82.890906] other info that might help us debug this:\n[   82.890906]  Possible unsafe locking scenario:\n[   82.890906]\n[   82.890906]        CPU0\n[   82.890906]        ----\n[   82.890906]   lock(&sch->q.lock);\n[   82.890906]   lock(&sch->q.lock);\n[   82.890906]\n[   82.890906]  *** DEADLOCK ***\n[   82.890906]\n[..... other info removed for brevity....]\nExample setup (eth0->eth0) to recreate\ntc qdisc add dev eth0 root handle 1: htb default 30\ntc filter add dev eth0 handle 1: protocol ip prio 2 matchall \\\n     action mirred egress redirect dev eth0\nAnother example(eth0->eth1->eth0) to recreate\ntc qdisc add dev eth0 root handle 1: htb default 30\ntc filter add dev eth0 handle 1: protocol ip prio 2 matchall \\\n     action mirred egress redirect dev eth1\ntc qdisc add dev eth1 root handle 1: htb default 30\ntc filter add dev eth1 handle 1: protocol ip prio 2 matchall \\\n     action mirred egress redirect dev eth0\nWe fix this by adding an owner field (CPU id) to struct Qdisc set after\nroot qdisc is entered. When the softirq enters it a second time, if the\nqdisc owner is the same CPU, the packet is dropped to break the loop.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0f022d32c3eca477fbf79a205243a6123ed0fe11"
          },
          {
            "url": "https://git.kernel.org/stable/c/e6b90468da4dae2281a6e381107f411efb48b0ef"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27011",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:19.583",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnetfilter: nf_tables: fix memleak in map from abort path\nThe delete set command does not rely on the transaction object for\nelement removal, therefore, a combination of delete element + delete set\nfrom the abort path could result in restoring twice the refcount of the\nmapping.\nCheck for inactive element in the next generation for the delete element\ncommand in the abort path, skip restoring state if next generation bit\nhas been already cleared. This is similar to the activate logic using\nthe set walk iterator.\n[ 6170.286929] ------------[ cut here ]------------\n[ 6170.286939] WARNING: CPU: 6 PID: 790302 at net/netfilter/nf_tables_api.c:2086 nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]\n[ 6170.287071] Modules linked in: [...]\n[ 6170.287633] CPU: 6 PID: 790302 Comm: kworker/6:2 Not tainted 6.9.0-rc3+ #365\n[ 6170.287768] RIP: 0010:nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]\n[ 6170.287886] Code: df 48 8d 7d 58 e8 69 2e 3b df 48 8b 7d 58 e8 80 1b 37 df 48 8d 7d 68 e8 57 2e 3b df 48 8b 7d 68 e8 6e 1b 37 df 48 89 ef eb c4 <0f> 0b 48 83 c4 08 5b 5d 41 5c 41 5d 41 5e 41 5f c3 cc cc cc cc 0f\n[ 6170.287895] RSP: 0018:ffff888134b8fd08 EFLAGS: 00010202\n[ 6170.287904] RAX: 0000000000000001 RBX: ffff888125bffb28 RCX: dffffc0000000000\n[ 6170.287912] RDX: 0000000000000003 RSI: ffffffffa20298ab RDI: ffff88811ebe4750\n[ 6170.287919] RBP: ffff88811ebe4700 R08: ffff88838e812650 R09: fffffbfff0623a55\n[ 6170.287926] R10: ffffffff8311d2af R11: 0000000000000001 R12: ffff888125bffb10\n[ 6170.287933] R13: ffff888125bffb10 R14: dead000000000122 R15: dead000000000100\n[ 6170.287940] FS:  0000000000000000(0000) GS:ffff888390b00000(0000) knlGS:0000000000000000\n[ 6170.287948] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 6170.287955] CR2: 00007fd31fc00710 CR3: 0000000133f60004 CR4: 00000000001706f0\n[ 6170.287962] Call Trace:\n[ 6170.287967]  <TASK>\n[ 6170.287973]  ? __warn+0x9f/0x1a0\n[ 6170.287986]  ? nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]\n[ 6170.288092]  ? report_bug+0x1b1/0x1e0\n[ 6170.287986]  ? nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]\n[ 6170.288092]  ? report_bug+0x1b1/0x1e0\n[ 6170.288104]  ? handle_bug+0x3c/0x70\n[ 6170.288112]  ? exc_invalid_op+0x17/0x40\n[ 6170.288120]  ? asm_exc_invalid_op+0x1a/0x20\n[ 6170.288132]  ? nf_tables_chain_destroy+0x2b/0x220 [nf_tables]\n[ 6170.288243]  ? nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]\n[ 6170.288366]  ? nf_tables_chain_destroy+0x2b/0x220 [nf_tables]\n[ 6170.288483]  nf_tables_trans_destroy_work+0x588/0x590 [nf_tables]",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/49d0e656d19dfb2d4d7c230e4a720d37b3decff6"
          },
          {
            "url": "https://git.kernel.org/stable/c/86a1471d7cde792941109b93b558b5dc078b9ee9"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27012",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:19.743",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnetfilter: nf_tables: restore set elements when delete set fails\nFrom abort path, nft_mapelem_activate() needs to restore refcounters to\nthe original state. Currently, it uses the set->ops->walk() to iterate\nover these set elements. The existing set iterator skips inactive\nelements in the next generation, this does not work from the abort path\nto restore the original state since it has to skip active elements\ninstead (not inactive ones).\nThis patch moves the check for inactive elements to the set iterator\ncallback, then it reverses the logic for the .activate case which\nneeds to skip active elements.\nToggle next generation bit for elements when delete set command is\ninvoked and call nft_clear() from .activate (abort) path to restore the\nnext generation bit.\nThe splat below shows an object in mappings memleak:\n[43929.457523] ------------[ cut here ]------------\n[43929.457532] WARNING: CPU: 0 PID: 1139 at include/net/netfilter/nf_tables.h:1237 nft_setelem_data_deactivate+0xe4/0xf0 [nf_tables]\n[...]\n[43929.458014] RIP: 0010:nft_setelem_data_deactivate+0xe4/0xf0 [nf_tables]\n[43929.458076] Code: 83 f8 01 77 ab 49 8d 7c 24 08 e8 37 5e d0 de 49 8b 6c 24 08 48 8d 7d 50 e8 e9 5c d0 de 8b 45 50 8d 50 ff 89 55 50 85 c0 75 86 <0f> 0b eb 82 0f 0b eb b3 0f 1f 40 00 90 90 90 90 90 90 90 90 90 90\n[43929.458081] RSP: 0018:ffff888140f9f4b0 EFLAGS: 00010246\n[43929.458086] RAX: 0000000000000000 RBX: ffff8881434f5288 RCX: dffffc0000000000\n[43929.458090] RDX: 00000000ffffffff RSI: ffffffffa26d28a7 RDI: ffff88810ecc9550\n[43929.458093] RBP: ffff88810ecc9500 R08: 0000000000000001 R09: ffffed10281f3e8f\n[43929.458096] R10: 0000000000000003 R11: ffff0000ffff0000 R12: ffff8881434f52a0\n[43929.458100] R13: ffff888140f9f5f4 R14: ffff888151c7a800 R15: 0000000000000002\n[43929.458103] FS:  00007f0c687c4740(0000) GS:ffff888390800000(0000) knlGS:0000000000000000\n[43929.458107] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[43929.458111] CR2: 00007f58dbe5b008 CR3: 0000000123602005 CR4: 00000000001706f0\n[43929.458114] Call Trace:\n[43929.458118]  <TASK>\n[43929.458121]  ? __warn+0x9f/0x1a0\n[43929.458127]  ? nft_setelem_data_deactivate+0xe4/0xf0 [nf_tables]\n[43929.458188]  ? report_bug+0x1b1/0x1e0\n[43929.458196]  ? handle_bug+0x3c/0x70\n[43929.458200]  ? exc_invalid_op+0x17/0x40\n[43929.458211]  ? nft_setelem_data_deactivate+0xd7/0xf0 [nf_tables]\n[43929.458271]  ? nft_setelem_data_deactivate+0xe4/0xf0 [nf_tables]\n[43929.458332]  nft_mapelem_deactivate+0x24/0x30 [nf_tables]\n[43929.458392]  nft_rhash_walk+0xdd/0x180 [nf_tables]\n[43929.458453]  ? __pfx_nft_rhash_walk+0x10/0x10 [nf_tables]\n[43929.458512]  ? rb_insert_color+0x2e/0x280\n[43929.458520]  nft_map_deactivate+0xdc/0x1e0 [nf_tables]\n[43929.458582]  ? __pfx_nft_map_deactivate+0x10/0x10 [nf_tables]\n[43929.458642]  ? __pfx_nft_mapelem_deactivate+0x10/0x10 [nf_tables]\n[43929.458701]  ? __rcu_read_unlock+0x46/0x70\n[43929.458709]  nft_delset+0xff/0x110 [nf_tables]\n[43929.458769]  nft_flush_table+0x16f/0x460 [nf_tables]\n[43929.458830]  nf_tables_deltable+0x501/0x580 [nf_tables]",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/86658fc7414d4b9e25c2699d751034537503d637"
          },
          {
            "url": "https://git.kernel.org/stable/c/e79b47a8615d42c68aaeb68971593333667382ed"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27013",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:19.857",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ntun: limit printing rate when illegal packet received by tun dev\nvhost_worker will call tun call backs to receive packets. If too many\nillegal packets arrives, tun_do_read will keep dumping packet contents.\nWhen console is enabled, it will costs much more cpu time to dump\npacket and soft lockup will be detected.\nnet_ratelimit mechanism can be used to limit the dumping rate.\nPID: 33036    TASK: ffff949da6f20000  CPU: 23   COMMAND: \"vhost-32980\"\n #0 [fffffe00003fce50] crash_nmi_callback at ffffffff89249253\n #1 [fffffe00003fce58] nmi_handle at ffffffff89225fa3\n #2 [fffffe00003fceb0] default_do_nmi at ffffffff8922642e\n #3 [fffffe00003fced0] do_nmi at ffffffff8922660d\n #4 [fffffe00003fcef0] end_repeat_nmi at ffffffff89c01663\n    [exception RIP: io_serial_in+20]\n    RIP: ffffffff89792594  RSP: ffffa655314979e8  RFLAGS: 00000002\n    RAX: ffffffff89792500  RBX: ffffffff8af428a0  RCX: 0000000000000000\n    RDX: 00000000000003fd  RSI: 0000000000000005  RDI: ffffffff8af428a0\n    RBP: 0000000000002710   R8: 0000000000000004   R9: 000000000000000f\n    R10: 0000000000000000  R11: ffffffff8acbf64f  R12: 0000000000000020\n    R13: ffffffff8acbf698  R14: 0000000000000058  R15: 0000000000000000\n    ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018\n #5 [ffffa655314979e8] io_serial_in at ffffffff89792594\n #6 [ffffa655314979e8] wait_for_xmitr at ffffffff89793470\n #7 [ffffa65531497a08] serial8250_console_putchar at ffffffff897934f6\n #8 [ffffa65531497a20] uart_console_write at ffffffff8978b605\n #9 [ffffa65531497a48] serial8250_console_write at ffffffff89796558\n #10 [ffffa65531497ac8] console_unlock at ffffffff89316124\n #11 [ffffa65531497b10] vprintk_emit at ffffffff89317c07\n #12 [ffffa65531497b68] printk at ffffffff89318306\n #13 [ffffa65531497bc8] print_hex_dump at ffffffff89650765\n #14 [ffffa65531497ca8] tun_do_read at ffffffffc0b06c27 [tun]\n #15 [ffffa65531497d38] tun_recvmsg at ffffffffc0b06e34 [tun]\n #16 [ffffa65531497d68] handle_rx at ffffffffc0c5d682 [vhost_net]\n #17 [ffffa65531497ed0] vhost_worker at ffffffffc0c644dc [vhost]\n #18 [ffffa65531497f10] kthread at ffffffff892d2e72\n #19 [ffffa65531497f50] ret_from_fork at ffffffff89c0022f",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/40f4ced305c6c47487d3cd8da54676e2acc1a6ad"
          },
          {
            "url": "https://git.kernel.org/stable/c/52854101180beccdb9dc2077a3bea31b6ad48dfa"
          },
          {
            "url": "https://git.kernel.org/stable/c/62e27ef18eb4f0d33bbae8e9ef56b99696a74713"
          },
          {
            "url": "https://git.kernel.org/stable/c/a50dbeca28acf7051dfa92786b85f704c75db6eb"
          },
          {
            "url": "https://git.kernel.org/stable/c/f8bbc07ac535593139c875ffa19af924b1084540"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27014",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:20.063",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/mlx5e: Prevent deadlock while disabling aRFS\nWhen disabling aRFS under the `priv->state_lock`, any scheduled\naRFS works are canceled using the `cancel_work_sync` function,\nwhich waits for the work to end if it has already started.\nHowever, while waiting for the work handler, the handler will\ntry to acquire the `state_lock` which is already acquired.\nThe worker acquires the lock to delete the rules if the state\nis down, which is not the worker's responsibility since\ndisabling aRFS deletes the rules.\nAdd an aRFS state variable, which indicates whether the aRFS is\nenabled and prevent adding rules when the aRFS is disabled.\nKernel log:\n======================================================\nWARNING: possible circular locking dependency detected\n6.7.0-rc4_net_next_mlx5_5483eb2 #1 Tainted: G          I\n------------------------------------------------------\nethtool/386089 is trying to acquire lock:\nffff88810f21ce68 ((work_completion)(&rule->arfs_work)){+.+.}-{0:0}, at: __flush_work+0x74/0x4e0\nbut task is already holding lock:\nffff8884a1808cc0 (&priv->state_lock){+.+.}-{3:3}, at: mlx5e_ethtool_set_channels+0x53/0x200 [mlx5_core]\nwhich lock already depends on the new lock.\nthe existing dependency chain (in reverse order) is:\n-> #1 (&priv->state_lock){+.+.}-{3:3}:\n       __mutex_lock+0x80/0xc90\n       arfs_handle_work+0x4b/0x3b0 [mlx5_core]\n       process_one_work+0x1dc/0x4a0\n       worker_thread+0x1bf/0x3c0\n       kthread+0xd7/0x100\n       ret_from_fork+0x2d/0x50\n       ret_from_fork_asm+0x11/0x20\n-> #0 ((work_completion)(&rule->arfs_work)){+.+.}-{0:0}:\n       __lock_acquire+0x17b4/0x2c80\n       lock_acquire+0xd0/0x2b0\n       __flush_work+0x7a/0x4e0\n       __cancel_work_timer+0x131/0x1c0\n       arfs_del_rules+0x143/0x1e0 [mlx5_core]\n       mlx5e_arfs_disable+0x1b/0x30 [mlx5_core]\n       mlx5e_ethtool_set_channels+0xcb/0x200 [mlx5_core]\n       ethnl_set_channels+0x28f/0x3b0\n       ethnl_default_set_doit+0xec/0x240\n       genl_family_rcv_msg_doit+0xd0/0x120\n       genl_rcv_msg+0x188/0x2c0\n       netlink_rcv_skb+0x54/0x100\n       genl_rcv+0x24/0x40\n       netlink_unicast+0x1a1/0x270\n       netlink_sendmsg+0x214/0x460\n       __sock_sendmsg+0x38/0x60\n       __sys_sendto+0x113/0x170\n       __x64_sys_sendto+0x20/0x30\n       do_syscall_64+0x40/0xe0\n       entry_SYSCALL_64_after_hwframe+0x46/0x4e\nother info that might help us debug this:\n Possible unsafe locking scenario:\n       CPU0                    CPU1\n       ----                    ----\n  lock(&priv->state_lock);\n                               lock((work_completion)(&rule->arfs_work));\n                               lock(&priv->state_lock);\n  lock((work_completion)(&rule->arfs_work));\n *** DEADLOCK ***\n3 locks held by ethtool/386089:\n #0: ffffffff82ea7210 (cb_lock){++++}-{3:3}, at: genl_rcv+0x15/0x40\n #1: ffffffff82e94c88 (rtnl_mutex){+.+.}-{3:3}, at: ethnl_default_set_doit+0xd3/0x240\n #2: ffff8884a1808cc0 (&priv->state_lock){+.+.}-{3:3}, at: mlx5e_ethtool_set_channels+0x53/0x200 [mlx5_core]\nstack backtrace:\nCPU: 15 PID: 386089 Comm: ethtool Tainted: G          I        6.7.0-rc4_net_next_mlx5_5483eb2 #1\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\nCall Trace:\n <TASK>\n dump_stack_lvl+0x60/0xa0\n check_noncircular+0x144/0x160\n __lock_acquire+0x17b4/0x2c80\n lock_acquire+0xd0/0x2b0\n ? __flush_work+0x74/0x4e0\n ? save_trace+0x3e/0x360\n ? __flush_work+0x74/0x4e0\n __flush_work+0x7a/0x4e0\n ? __flush_work+0x74/0x4e0\n ? __lock_acquire+0xa78/0x2c80\n ? lock_acquire+0xd0/0x2b0\n ? mark_held_locks+0x49/0x70\n __cancel_work_timer+0x131/0x1c0\n ? mark_held_locks+0x49/0x70\n arfs_del_rules+0x143/0x1e0 [mlx5_core]\n mlx5e_arfs_disable+0x1b/0x30 [mlx5_core]\n mlx5e_ethtool_set_channels+0xcb/0x200 [mlx5_core]\n ethnl_set_channels+0x28f/0x3b0\n ethnl_default_set_doit+0xec/0x240\n genl_family_rcv_msg_doit+0xd0/0x120\n genl_rcv_msg+0x188/0x2c0\n ? ethn\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0080bf99499468030248ebd25dd645e487dcecdc"
          },
          {
            "url": "https://git.kernel.org/stable/c/46efa4d5930cf3c2af8c01f75e0a47e4fc045e3b"
          },
          {
            "url": "https://git.kernel.org/stable/c/48c4bb81df19402d4346032353d0795260255e3b"
          },
          {
            "url": "https://git.kernel.org/stable/c/fef965764cf562f28afb997b626fc7c3cec99693"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27015",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:20.230",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnetfilter: flowtable: incorrect pppoe tuple\npppoe traffic reaching ingress path does not match the flowtable entry\nbecause the pppoe header is expected to be at the network header offset.\nThis bug causes a mismatch in the flow table lookup, so pppoe packets\nenter the classical forwarding path.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4ed82dd368ad883dc4284292937b882f044e625d"
          },
          {
            "url": "https://git.kernel.org/stable/c/6db5dc7b351b9569940cd1cf445e237c42cd6d27"
          },
          {
            "url": "https://git.kernel.org/stable/c/e3f078103421642fcd5f05c5e70777feb10f000d"
          },
          {
            "url": "https://git.kernel.org/stable/c/e719b52d0c56989b0f3475a03a6d64f182c85b56"
          },
          {
            "url": "https://git.kernel.org/stable/c/f1c3c61701a0b12f4906152c1626a5de580ea3d2"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27016",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:20.360",
        "lastModified": "2024-05-01T13:02:20.750",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnetfilter: flowtable: validate pppoe header\nEnsure there is sufficient room to access the protocol field of the\nPPPoe header. Validate it once before the flowtable lookup, then use a\nhelper function to access protocol field.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/87b3593bed1868b2d9fe096c01bcdf0ea86cbebf"
          },
          {
            "url": "https://git.kernel.org/stable/c/8bf7c76a2a207ca2b4cfda0a279192adf27678d7"
          },
          {
            "url": "https://git.kernel.org/stable/c/a2471d271042ea18e8a6babc132a8716bb2f08b9"
          },
          {
            "url": "https://git.kernel.org/stable/c/cf366ee3bc1b7d1c76a882640ba3b3f8f1039163"
          },
          {
            "url": "https://git.kernel.org/stable/c/d06977b9a4109f8738bb276125eb6a0b772bc433"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27017",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:20.483",
        "lastModified": "2024-05-01T13:01:51.263",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnetfilter: nft_set_pipapo: walk over current view on netlink dump\nThe generation mask can be updated while netlink dump is in progress.\nThe pipapo set backend walk iterator cannot rely on it to infer what\nview of the datastructure is to be used. Add notation to specify if user\nwants to read/update the set.\nBased on patch from Florian Westphal.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/29b359cf6d95fd60730533f7f10464e95bd17c73"
          },
          {
            "url": "https://git.kernel.org/stable/c/721715655c72640567e8742567520c99801148ed"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27018",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:20.600",
        "lastModified": "2024-05-01T13:01:51.263",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnetfilter: br_netfilter: skip conntrack input hook for promisc packets\nFor historical reasons, when bridge device is in promisc mode, packets\nthat are directed to the taps follow bridge input hook path. This patch\nadds a workaround to reset conntrack for these packets.\nJianbo Liu reports warning splats in their test infrastructure where\ncloned packets reach the br_netfilter input hook to confirm the\nconntrack object.\nScratch one bit from BR_INPUT_SKB_CB to annotate that this packet has\nreached the input hook because it is passed up to the bridge device to\nreach the taps.\n[   57.571874] WARNING: CPU: 1 PID: 0 at net/bridge/br_netfilter_hooks.c:616 br_nf_local_in+0x157/0x180 [br_netfilter]\n[   57.572749] Modules linked in: xt_MASQUERADE nf_conntrack_netlink nfnetlink iptable_nat xt_addrtype xt_conntrack nf_nat br_netfilter rpcsec_gss_krb5 auth_rpcgss oid_registry overlay rpcrdma rdma_ucm ib_iser libiscsi scsi_transport_isc si ib_umad rdma_cm ib_ipoib iw_cm ib_cm mlx5_ib ib_uverbs ib_core mlx5ctl mlx5_core\n[   57.575158] CPU: 1 PID: 0 Comm: swapper/1 Not tainted 6.8.0+ #19\n[   57.575700] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\n[   57.576662] RIP: 0010:br_nf_local_in+0x157/0x180 [br_netfilter]\n[   57.577195] Code: fe ff ff 41 bd 04 00 00 00 be 04 00 00 00 e9 4a ff ff ff be 04 00 00 00 48 89 ef e8 f3 a9 3c e1 66 83 ad b4 00 00 00 04 eb 91 <0f> 0b e9 f1 fe ff ff 0f 0b e9 df fe ff ff 48 89 df e8 b3 53 47 e1\n[   57.578722] RSP: 0018:ffff88885f845a08 EFLAGS: 00010202\n[   57.579207] RAX: 0000000000000002 RBX: ffff88812dfe8000 RCX: 0000000000000000\n[   57.579830] RDX: ffff88885f845a60 RSI: ffff8881022dc300 RDI: 0000000000000000\n[   57.580454] RBP: ffff88885f845a60 R08: 0000000000000001 R09: 0000000000000003\n[   57.581076] R10: 00000000ffff1300 R11: 0000000000000002 R12: 0000000000000000\n[   57.581695] R13: ffff8881047ffe00 R14: ffff888108dbee00 R15: ffff88814519b800\n[   57.582313] FS:  0000000000000000(0000) GS:ffff88885f840000(0000) knlGS:0000000000000000\n[   57.583040] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[   57.583564] CR2: 000000c4206aa000 CR3: 0000000103847001 CR4: 0000000000370eb0\n[   57.584194] DR0: 0000000000000000 DR1: 0000000000000000 DR2:\n0000000000000000\n[   57.584820] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7:\n0000000000000400\n[   57.585440] Call Trace:\n[   57.585721]  <IRQ>\n[   57.585976]  ? __warn+0x7d/0x130\n[   57.586323]  ? br_nf_local_in+0x157/0x180 [br_netfilter]\n[   57.586811]  ? report_bug+0xf1/0x1c0\n[   57.587177]  ? handle_bug+0x3f/0x70\n[   57.587539]  ? exc_invalid_op+0x13/0x60\n[   57.587929]  ? asm_exc_invalid_op+0x16/0x20\n[   57.588336]  ? br_nf_local_in+0x157/0x180 [br_netfilter]\n[   57.588825]  nf_hook_slow+0x3d/0xd0\n[   57.589188]  ? br_handle_vlan+0x4b/0x110\n[   57.589579]  br_pass_frame_up+0xfc/0x150\n[   57.589970]  ? br_port_flags_change+0x40/0x40\n[   57.590396]  br_handle_frame_finish+0x346/0x5e0\n[   57.590837]  ? ipt_do_table+0x32e/0x430\n[   57.591221]  ? br_handle_local_finish+0x20/0x20\n[   57.591656]  br_nf_hook_thresh+0x4b/0xf0 [br_netfilter]\n[   57.592286]  ? br_handle_local_finish+0x20/0x20\n[   57.592802]  br_nf_pre_routing_finish+0x178/0x480 [br_netfilter]\n[   57.593348]  ? br_handle_local_finish+0x20/0x20\n[   57.593782]  ? nf_nat_ipv4_pre_routing+0x25/0x60 [nf_nat]\n[   57.594279]  br_nf_pre_routing+0x24c/0x550 [br_netfilter]\n[   57.594780]  ? br_nf_hook_thresh+0xf0/0xf0 [br_netfilter]\n[   57.595280]  br_handle_frame+0x1f3/0x3d0\n[   57.595676]  ? br_handle_local_finish+0x20/0x20\n[   57.596118]  ? br_handle_frame_finish+0x5e0/0x5e0\n[   57.596566]  __netif_receive_skb_core+0x25b/0xfc0\n[   57.597017]  ? __napi_build_skb+0x37/0x40\n[   57.597418]  __netif_receive_skb_list_core+0xfb/0x220",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3f59ac29dea0921637053908fe99268d157bbb9d"
          },
          {
            "url": "https://git.kernel.org/stable/c/43193174510ea4f3ce09b796e559a2fd9f148615"
          },
          {
            "url": "https://git.kernel.org/stable/c/751de2012eafa4d46d8081056761fa0e9cc8a178"
          },
          {
            "url": "https://git.kernel.org/stable/c/b13db0d16bc7b2a52abcf5cb71334f63faa5dbd6"
          },
          {
            "url": "https://git.kernel.org/stable/c/dceb683ab87ca3666a9bb5c0158528b646faedc4"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27019",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:20.743",
        "lastModified": "2024-05-01T13:01:51.263",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnetfilter: nf_tables: Fix potential data-race in __nft_obj_type_get()\nnft_unregister_obj() can concurrent with __nft_obj_type_get(),\nand there is not any protection when iterate over nf_tables_objects\nlist in __nft_obj_type_get(). Therefore, there is potential data-race\nof nf_tables_objects list entry.\nUse list_for_each_entry_rcu() to iterate over nf_tables_objects\nlist in __nft_obj_type_get(), and use rcu_read_lock() in the caller\nnft_obj_type_get() to protect the entire type query process.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/379bf7257bc5f2a1b1ca8514e08a871b7bf6d920"
          },
          {
            "url": "https://git.kernel.org/stable/c/4ca946b19caf655a08d5e2266d4d5526025ebb73"
          },
          {
            "url": "https://git.kernel.org/stable/c/ad333578f736d56920e090d7db1f8dec891d815e"
          },
          {
            "url": "https://git.kernel.org/stable/c/d78d867dcea69c328db30df665be5be7d0148484"
          },
          {
            "url": "https://git.kernel.org/stable/c/df7c0fb8c2b9f9cac65659332581b19682a71349"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27020",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:20.840",
        "lastModified": "2024-05-01T13:01:51.263",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnetfilter: nf_tables: Fix potential data-race in __nft_expr_type_get()\nnft_unregister_expr() can concurrent with __nft_expr_type_get(),\nand there is not any protection when iterate over nf_tables_expressions\nlist in __nft_expr_type_get(). Therefore, there is potential data-race\nof nf_tables_expressions list entry.\nUse list_for_each_entry_rcu() to iterate over nf_tables_expressions\nlist in __nft_expr_type_get(), and use rcu_read_lock() in the caller\nnft_expr_type_get() to protect the entire type query process.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/01f1a678b05ade4b1248019c2dcca773aebbeb7f"
          },
          {
            "url": "https://git.kernel.org/stable/c/0b6de00206adbbfc6373b3ae38d2a6f197987907"
          },
          {
            "url": "https://git.kernel.org/stable/c/8d56bad42ac4c43c6c72ddd6a654a2628bf839c5"
          },
          {
            "url": "https://git.kernel.org/stable/c/a9ebf340d123ae12582210407f879d6a5a1bc25b"
          },
          {
            "url": "https://git.kernel.org/stable/c/f969eb84ce482331a991079ab7a5c4dc3b7f89bf"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27021",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:20.960",
        "lastModified": "2024-05-01T13:01:51.263",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nr8169: fix LED-related deadlock on module removal\nBinding devm_led_classdev_register() to the netdev is problematic\nbecause on module removal we get a RTNL-related deadlock. Fix this\nby avoiding the device-managed LED functions.\nNote: We can safely call led_classdev_unregister() for a LED even\nif registering it failed, because led_classdev_unregister() detects\nthis and is a no-op in this case.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/19fa4f2a85d777a8052e869c1b892a2f7556569d"
          },
          {
            "url": "https://git.kernel.org/stable/c/53d986f39acd8ea11c9e460732bfa5add66360d9"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-27022",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-01T06:15:21.110",
        "lastModified": "2024-05-01T13:01:51.263",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nfork: defer linking file vma until vma is fully initialized\nThorvald reported a WARNING [1]. And the root cause is below race:\n CPU 1\t\t\t\t\tCPU 2\n fork\t\t\t\t\thugetlbfs_fallocate\n  dup_mmap\t\t\t\t hugetlbfs_punch_hole\n   i_mmap_lock_write(mapping);\n   vma_interval_tree_insert_after -- Child vma is visible through i_mmap tree.\n   i_mmap_unlock_write(mapping);\n   hugetlb_dup_vma_private -- Clear vma_lock outside i_mmap_rwsem!\n\t\t\t\t\t i_mmap_lock_write(mapping);\n   \t\t\t\t\t hugetlb_vmdelete_list\n\t\t\t\t\t  vma_interval_tree_foreach\n\t\t\t\t\t   hugetlb_vma_trylock_write -- Vma_lock is cleared.\n   tmp->vm_ops->open -- Alloc new vma_lock outside i_mmap_rwsem!\n\t\t\t\t\t   hugetlb_vma_unlock_write -- Vma_lock is assigned!!!\n\t\t\t\t\t i_mmap_unlock_write(mapping);\nhugetlb_dup_vma_private() and hugetlb_vm_op_open() are called outside\ni_mmap_rwsem lock while vma lock can be used in the same time.  Fix this\nby deferring linking file vma until vma is fully initialized.  Those vmas\nshould be initialized first before they can be used.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/35e351780fa9d8240dd6f7e4f245f9ea37e96c19"
          },
          {
            "url": "https://git.kernel.org/stable/c/abdb88dd272bbeb93efe01d8e0b7b17e24af3a34"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-32966",
        "sourceIdentifier": "security-advisories@github.com",
        "published": "2024-05-01T06:15:21.277",
        "lastModified": "2024-05-01T13:01:51.263",
        "baseScore": 5.8,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 1.6,
        "impactScore": 3.7,
        "description": "Static Web Server (SWS) is a tiny and fast production-ready web server suitable to serve static web files or assets. In affected versions if directory listings are enabled for a directory that an untrusted user has upload privileges for, a malicious file name like `<img src=x onerror=alert(1)>.txt` will allow JavaScript code execution in the context of the web server’s domain. SWS generally does not perform escaping of HTML entities on any values inserted in the directory listing. At the very least `file_name` and `current_path` could contain malicious data however. `file_uri` could also be malicious but the relevant scenarios seem to be all caught by hyper. For any web server that allow users to upload files or create directories under a name of their choosing this becomes a stored Cross-site Scripting vulnerability. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "cweIds": [
          {
            "id": "CWE-79",
            "description": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
          },
          {
            "id": "CWE-80",
            "description": "Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS)"
          }
        ],
        "references": [
          {
            "url": "https://github.com/static-web-server/static-web-server/security/advisories/GHSA-rwfq-v4hq-h7fg"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-3591",
        "sourceIdentifier": "contact@wpscan.com",
        "published": "2024-05-01T06:15:21.887",
        "lastModified": "2024-05-01T13:01:51.263",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "The Geo Controller WordPress plugin before 8.6.5 unserializes user input via some of its AJAX actions and REST API routes, which could allow unauthenticated users to perform PHP Object Injection when a suitable gadget is present on the blog.",
        "cweIds": null,
        "references": [
          {
            "url": "https://wpscan.com/vulnerability/f85d8b61-eaeb-433c-b857-06ee4db5c7d5/"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-23335",
        "sourceIdentifier": "security-advisories@github.com",
        "published": "2024-05-01T07:15:38.240",
        "lastModified": "2024-05-01T13:01:51.263",
        "baseScore": 4.7,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 1.2,
        "impactScore": 3.4,
        "description": "MyBB is a free and open source forum software. The backup management module of the Admin CP may accept `.htaccess` as the name of the backup file to be deleted, which may expose the stored backup files over HTTP on Apache servers. MyBB 1.8.38 resolves this issue. Users are advised to upgrade. There are no known workarounds for this vulnerability",
        "cweIds": [
          {
            "id": "CWE-20",
            "description": "Improper Input Validation"
          }
        ],
        "references": [
          {
            "url": "https://github.com/mybb/mybb/commit/450259e501b94c9d483efb167cb2bf875605e111.patch"
          },
          {
            "url": "https://github.com/mybb/mybb/security/advisories/GHSA-94xr-g4ww-j47r"
          },
          {
            "url": "https://mybb.com/versions/1.8.38"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-23336",
        "sourceIdentifier": "security-advisories@github.com",
        "published": "2024-05-01T07:15:38.660",
        "lastModified": "2024-05-01T13:01:51.263",
        "baseScore": 5.0,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 1.6,
        "impactScore": 3.4,
        "description": "MyBB is a free and open source forum software. The default list of disallowed remote hosts does not contain the `127.0.0.0/8` block, which may result in a Server-Side Request Forgery (SSRF) vulnerability. The Configuration File's _Disallowed Remote Addresses_ list (`$config['disallowed_remote_addresses']`) contains the address `127.0.0.1`, but does not include the complete block `127.0.0.0/8`. MyBB 1.8.38 resolves this issue in default installations. Administrators of installed boards should update the existing configuration (`inc/config.php`) to include all addresses blocked by default. Additionally, users are advised to verify that it includes any other IPv4 addresses resolving to the server and other internal resources. Users unable to upgrade may manually add 127.0.0.0/8' to their disallowed address list.",
        "cweIds": [
          {
            "id": "CWE-184",
            "description": "Incomplete List of Disallowed Inputs"
          },
          {
            "id": "CWE-918",
            "description": "Server-Side Request Forgery (SSRF)"
          }
        ],
        "references": [
          {
            "url": "https://docs.mybb.com/1.8/administration/configuration-file"
          },
          {
            "url": "https://github.com/mybb/mybb/commit/d6a96019025de9149014e06b1df252e6122e5630"
          },
          {
            "url": "https://github.com/mybb/mybb/security/advisories/GHSA-qfrj-65mv-h75h"
          },
          {
            "url": "https://mybb.com/versions/1.8.38"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-31225",
        "sourceIdentifier": "security-advisories@github.com",
        "published": "2024-05-01T07:15:38.977",
        "lastModified": "2024-05-01T13:01:51.263",
        "baseScore": 8.3,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 1.6,
        "impactScore": 6.0,
        "description": "RIOT is a real-time multi-threading operating system that supports a range of devices that are typically 8-bit, 16-bit and 32-bit microcontrollers. The `_on_rd_init()` function does not implement a size check before copying data to the `_result_buf` static buffer. If an attacker can craft a long enough payload, they could cause a buffer overflow. If the unchecked input above is attacker-controlled and crosses a security boundary, the impact of the buffer overflow vulnerability could range from denial of service to arbitrary code execution. This issue has yet to be patched. Users are advised to add manual bounds checking.",
        "cweIds": [
          {
            "id": "CWE-120",
            "description": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')"
          }
        ],
        "references": [
          {
            "url": "https://github.com/RIOT-OS/RIOT/blob/master/sys/net/application_layer/cord/lc/cord_lc.c#L218"
          },
          {
            "url": "https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-2572-7q7c-3965"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-32017",
        "sourceIdentifier": "security-advisories@github.com",
        "published": "2024-05-01T07:15:39.280",
        "lastModified": "2024-05-01T13:01:51.263",
        "baseScore": 9.8,
        "baseSeverity": "CRITICAL",
        "exploitabilityScore": 3.9,
        "impactScore": 5.9,
        "description": "RIOT is a real-time multi-threading operating system that supports a range of devices that are typically 8-bit, 16-bit and 32-bit microcontrollers. The size check in the `gcoap_dns_server_proxy_get()` function contains a small typo that may lead to a buffer overflow in the subsequent `strcpy()`. In detail, the length of the `_uri` string is checked instead of the length of the `_proxy` string. The `_gcoap_forward_proxy_copy_options()` function does not implement an explicit size check before copying data to the `cep->req_etag` buffer that is `COAP_ETAG_LENGTH_MAX` bytes long. If an attacker can craft input so that `optlen` becomes larger than `COAP_ETAG_LENGTH_MAX`, they can cause a buffer overflow. If the input above is attacker-controlled and crosses a security boundary, the impact of the buffer overflow vulnerabilities could range from denial of service to arbitrary code execution. This issue has yet to be patched. Users are advised to add manual bounds checking.",
        "cweIds": [
          {
            "id": "CWE-120",
            "description": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')"
          }
        ],
        "references": [
          {
            "url": "https://github.com/RIOT-OS/RIOT/blob/master/sys/net/application_layer/gcoap/dns.c#L319-L325"
          },
          {
            "url": "https://github.com/RIOT-OS/RIOT/blob/master/sys/net/application_layer/gcoap/forward_proxy.c#L352"
          },
          {
            "url": "https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-v97j-w9m6-c4h3"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-32018",
        "sourceIdentifier": "security-advisories@github.com",
        "published": "2024-05-01T07:15:39.590",
        "lastModified": "2024-05-01T13:01:51.263",
        "baseScore": 8.8,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 2.8,
        "impactScore": 5.9,
        "description": "RIOT is a real-time multi-threading operating system that supports a range of devices that are typically 8-bit, 16-bit and 32-bit microcontrollers. Most codebases define assertion macros which compile to a no-op on non-debug builds. If assertions are the only line of defense against untrusted input, the software may be exposed to attacks that leverage the lack of proper input checks. In detail, in the `nimble_scanlist_update()` function below, `len` is checked in an assertion and subsequently used in a call to `memcpy()`. If an attacker is able to provide a larger `len` value while assertions are compiled-out, they can write past the end of the fixed-length `e->ad` buffer. If the unchecked input above is attacker-controlled and crosses a security boundary, the impact of the buffer overflow vulnerability could range from denial of service to arbitrary code execution. This issue has not yet been patched. Users are advised to add manual `len` checking.",
        "cweIds": [
          {
            "id": "CWE-120",
            "description": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')"
          }
        ],
        "references": [
          {
            "url": "https://github.com/RIOT-OS/RIOT/blob/master/pkg/nimble/scanlist/nimble_scanlist.c#L74-L87"
          },
          {
            "url": "https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-899m-q6pp-hmp3"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-32890",
        "sourceIdentifier": "security-advisories@github.com",
        "published": "2024-05-01T07:15:39.900",
        "lastModified": "2024-05-01T13:01:51.263",
        "baseScore": 6.1,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 2.8,
        "impactScore": 2.7,
        "description": "librespeed/speedtest is an open source, self-hosted speed test for HTML5. In affected versions missing neutralization of the ISP information in a speedtest result leads to stored Cross-site scripting in the JSON API. The `processedString` field in the `ispinfo` parameter is missing neutralization. It is stored when a user submits a speedtest result to the telemetry API (`results/telemetry.php`) and returned in the JSON API (`results/json.php`). This vulnerability has been introduced in commit 3937b94. This vulnerability affects LibreSpeed speedtest instances running version 5.2.5 or higher which have telemetry enabled and has been addressed in version 5.3.1. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "cweIds": [
          {
            "id": "CWE-79",
            "description": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
          }
        ],
        "references": [
          {
            "url": "https://github.com/librespeed/speedtest/commit/3937b940e80b734acae36cd41a2a31819593e728"
          },
          {
            "url": "https://github.com/librespeed/speedtest/commit/dd1ce2cb8830d94dcaa0b8e70b9406144a0e5f8d"
          },
          {
            "url": "https://github.com/librespeed/speedtest/security/advisories/GHSA-3954-xrwh-fq4q"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-32963",
        "sourceIdentifier": "security-advisories@github.com",
        "published": "2024-05-01T07:15:40.217",
        "lastModified": "2024-05-01T13:01:51.263",
        "baseScore": 4.2,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 1.6,
        "impactScore": 2.5,
        "description": "Navidrome is an open source web-based music collection server and streamer. In affected versions of Navidrome are subject to a parameter tampering vulnerability where an attacker has the ability to manipulate parameter values in the HTTP requests. The attacker is able to change the parameter values in the body and successfully impersonate another user. In this case, the attacker created a playlist, added song, posted arbitrary comment, set the playlist to be public, and put the admin as the owner of the playlist. The attacker must be able to intercept http traffic for this attack. Each known user is impacted. An attacker can obtain the ownerId from shared playlist information, meaning every user who has shared a playlist is also impacted, as they can be impersonated. This issue has been addressed in version 0.52.0 and users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "cweIds": [
          {
            "id": "CWE-200",
            "description": "Exposure of Sensitive Information to an Unauthorized Actor"
          }
        ],
        "references": [
          {
            "url": "https://github.com/navidrome/navidrome/security/advisories/GHSA-4jrx-5w4h-3gpm"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-32967",
        "sourceIdentifier": "security-advisories@github.com",
        "published": "2024-05-01T07:15:40.537",
        "lastModified": "2024-05-01T13:01:51.263",
        "baseScore": 5.3,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 3.9,
        "impactScore": 1.4,
        "description": "Zitadel is an open source identity management system. In case ZITADEL could not connect to the database, connection information including db name, username and db host name could be returned to the user. This has been addressed in all supported release branches in a point release. There is no workaround since a patch is already available. Users are advised to upgrade.",
        "cweIds": [
          {
            "id": "CWE-200",
            "description": "Exposure of Sensitive Information to an Unauthorized Actor"
          }
        ],
        "references": [
          {
            "url": "https://github.com/zitadel/zitadel/commit/b918603b576d156a08b90917c14c2d019c82ffc6"
          },
          {
            "url": "https://github.com/zitadel/zitadel/releases/tag/v2.45.7"
          },
          {
            "url": "https://github.com/zitadel/zitadel/releases/tag/v2.46.7"
          },
          {
            "url": "https://github.com/zitadel/zitadel/releases/tag/v2.47.10"
          },
          {
            "url": "https://github.com/zitadel/zitadel/releases/tag/v2.48.5"
          },
          {
            "url": "https://github.com/zitadel/zitadel/releases/tag/v2.49.5"
          },
          {
            "url": "https://github.com/zitadel/zitadel/releases/tag/v2.50.3"
          },
          {
            "url": "https://github.com/zitadel/zitadel/security/advisories/GHSA-q5qj-x2h5-3945"
          }
        ]
      }
    }
  ]
}