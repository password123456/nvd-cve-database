{
  "totalResults": 55,
  "datePublished": "2024-05-22T17:00:06.791549Z",
  "vulnerabilities": [
    {
      "cve": {
        "id": "CVE-2020-35165",
        "sourceIdentifier": "security_alert@emc.com",
        "published": "2024-05-22T06:15:09.317",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": 5.1,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 1.4,
        "impactScore": 3.6,
        "description": "Dell BSAFE Crypto-C Micro Edition, versions before 4.1.5, and Dell BSAFE Micro Edition Suite, versions before 4.6, contain an Observable Timing Discrepancy Vulnerability.",
        "cweIds": [
          {
            "id": "CWE-208",
            "description": "Observable Timing Discrepancy"
          }
        ],
        "references": [
          {
            "url": "https://www.dell.com/support/kbdoc/en-us/000181115/dsa-2020-286-dell-bsafe-crypto-c-micro-edition-4-1-5-and-dell-bsafe-micro-edition-suite-4-6-multiple-security-vulnerabilities"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-31340",
        "sourceIdentifier": "vultures@jpcert.or.jp",
        "published": "2024-05-22T06:15:12.350",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "TP-Link Tether versions prior to 4.5.13 and TP-Link Tapo versions prior to 3.3.6 do not properly validate certificates, which may allow a remote unauthenticated attacker to eavesdrop on an encrypted communication via a man-in-the-middle attack.",
        "cweIds": null,
        "references": [
          {
            "url": "https://jvn.jp/en/jp/JVN29471697/"
          },
          {
            "url": "https://play.google.com/store/apps/details?id=com.tplink.iot"
          },
          {
            "url": "https://play.google.com/store/apps/details?id=com.tplink.tether"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-35162",
        "sourceIdentifier": "vultures@jpcert.or.jp",
        "published": "2024-05-22T06:15:12.570",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "Path traversal vulnerability exists in Download Plugins and Themes from Dashboard versions prior to 1.8.6. If this vulnerability is exploited, a remote authenticated attacker with \"switch_themes\" privilege may obtain arbitrary files on the server.",
        "cweIds": null,
        "references": [
          {
            "url": "https://jvn.jp/en/jp/JVN85380030/"
          },
          {
            "url": "https://wordpress.org/plugins/download-plugins-dashboard/"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-3066",
        "sourceIdentifier": "security@wordfence.com",
        "published": "2024-05-22T06:15:12.843",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": 6.4,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 3.1,
        "impactScore": 2.7,
        "description": "The Elegant Addons for elementor plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's widgets in all versions up to, and including, 1.0.8 due to insufficient input sanitization and output escaping on user supplied tag attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.",
        "cweIds": null,
        "references": [
          {
            "url": "https://wordpress.org/plugins/elegant-addons-for-elementor/"
          },
          {
            "url": "https://www.wordfence.com/threat-intel/vulnerabilities/id/affa8b39-94b8-474d-9310-a93ebdb7c1b8?source=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-3611",
        "sourceIdentifier": "security@wordfence.com",
        "published": "2024-05-22T06:15:13.547",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": 6.4,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 3.1,
        "impactScore": 2.7,
        "description": "The Toolbar Extras for Elementor & More – WordPress Admin Bar Enhanced plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's 'tbex-version' shortcode in all versions up to, and including, 1.4.9 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.",
        "cweIds": null,
        "references": [
          {
            "url": "https://wordpress.org/plugins/toolbar-extras/#developers"
          },
          {
            "url": "https://www.wordfence.com/threat-intel/vulnerabilities/id/50631f6c-de8b-408e-ab1f-ef74d3180e7f?source=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-4443",
        "sourceIdentifier": "security@wordfence.com",
        "published": "2024-05-22T06:15:14.110",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": 9.8,
        "baseSeverity": "CRITICAL",
        "exploitabilityScore": 3.9,
        "impactScore": 5.9,
        "description": "The Business Directory Plugin – Easy Listing Directories for WordPress plugin for WordPress is vulnerable to time-based SQL Injection via the ‘listingfields’ parameter in all versions up to, and including, 6.4.2 due to insufficient escaping on the user supplied parameter and lack of sufficient preparation on the existing SQL query.  This makes it possible for unauthenticated attackers to append additional SQL queries into already existing queries that can be used to extract sensitive information from the database.",
        "cweIds": null,
        "references": [
          {
            "url": "https://plugins.trac.wordpress.org/browser/business-directory-plugin/trunk/includes/fields/class-fieldtypes-select.php#L110"
          },
          {
            "url": "https://plugins.trac.wordpress.org/changeset/3089626/"
          },
          {
            "url": "https://www.wordfence.com/threat-intel/vulnerabilities/id/982fb304-08d6-4195-97a3-f18e94295492?source=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-4971",
        "sourceIdentifier": "security@wordfence.com",
        "published": "2024-05-22T06:15:14.637",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": 6.4,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 3.1,
        "impactScore": 2.7,
        "description": "The LearnPress – WordPress LMS Plugin plugin for WordPress is vulnerable to Reflected Cross-Site Scripting via the ‘id’ parameter in all versions up to, and including, 4.2.6.6 due to insufficient input sanitization and output escaping. This makes it possible for unauthenticated attackers to inject arbitrary web scripts in pages that execute if they can successfully trick a user into performing an action such as clicking on a link.",
        "cweIds": null,
        "references": [
          {
            "url": "https://wordpress.org/plugins/learnpress/#developers"
          },
          {
            "url": "https://www.wordfence.com/threat-intel/vulnerabilities/id/10b08a05-3561-4d05-985b-6a2339a547a7?source=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-5092",
        "sourceIdentifier": "security@wordfence.com",
        "published": "2024-05-22T06:15:15.173",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": 6.4,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 3.1,
        "impactScore": 2.7,
        "description": "The Elegant Addons for elementor plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's Switcher, Slider, and Iconbox widgets in all versions up to, and including, 1.0.8 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.",
        "cweIds": null,
        "references": [
          {
            "url": "https://plugins.trac.wordpress.org/browser/elegant-addons-for-elementor/trunk/widgets/eae-iconbox.php#L1667"
          },
          {
            "url": "https://plugins.trac.wordpress.org/browser/elegant-addons-for-elementor/trunk/widgets/eae-slider.php#L1091"
          },
          {
            "url": "https://plugins.trac.wordpress.org/browser/elegant-addons-for-elementor/trunk/widgets/eae-switcher.php#L516"
          },
          {
            "url": "https://www.wordfence.com/threat-intel/vulnerabilities/id/7ab3e286-05db-430e-bbe7-bfaa31134c3c?source=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47433",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:08.347",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbtrfs: fix abort logic in btrfs_replace_file_extents\nError injection testing uncovered a case where we'd end up with a\ncorrupt file system with a missing extent in the middle of a file.  This\noccurs because the if statement to decide if we should abort is wrong.\nThe only way we would abort in this case is if we got a ret !=\n-EOPNOTSUPP and we called from the file clone code.  However the\nprealloc code uses this path too.  Instead we need to abort if there is\nan error, and the only error we _don't_ abort on is -EOPNOTSUPP and only\nif we came from the clone file code.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0e309e1152fc34ef75991d9d69b165dbf75bf26c"
          },
          {
            "url": "https://git.kernel.org/stable/c/0e32a2b85c7d92ece86c17dfef390c5ed79c6378"
          },
          {
            "url": "https://git.kernel.org/stable/c/4afb912f439c4bc4e6a4f3e7547f2e69e354108f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47434",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:08.707",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nxhci: Fix command ring pointer corruption while aborting a command\nThe command ring pointer is located at [6:63] bits of the command\nring control register (CRCR). All the control bits like command stop,\nabort are located at [0:3] bits. While aborting a command, we read the\nCRCR and set the abort bit and write to the CRCR. The read will always\ngive command ring pointer as all zeros. So we essentially write only\nthe control bits. Since we split the 64 bit write into two 32 bit writes,\nthere is a possibility of xHC command ring stopped before the upper\ndword (all zeros) is written. If that happens, xHC updates the upper\ndword of its internal command ring pointer with all zeros. Next time,\nwhen the command ring is restarted, we see xHC memory access failures.\nFix this issue by only writing to the lower dword of CRCR where all\ncontrol bits are located.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/01c2dcb67e71c351006dd17cbba86c26b7f61eaf"
          },
          {
            "url": "https://git.kernel.org/stable/c/22bcb65ea41072ab5d03c0c6290e04e0df6d09a0"
          },
          {
            "url": "https://git.kernel.org/stable/c/62c182b5e763e5f4062e72678e72ce3e02dd4d1b"
          },
          {
            "url": "https://git.kernel.org/stable/c/dec944bb7079b37968cf69c8a438f91f15c4cc61"
          },
          {
            "url": "https://git.kernel.org/stable/c/e54abefe703ab7c4e5983e889babd1447738ca42"
          },
          {
            "url": "https://git.kernel.org/stable/c/ff0e50d3564f33b7f4b35cadeabd951d66cfc570"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47435",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:08.790",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndm: fix mempool NULL pointer race when completing IO\ndm_io_dec_pending() calls end_io_acct() first and will then dec md\nin-flight pending count. But if a task is swapping DM table at same\ntime this can result in a crash due to mempool->elements being NULL:\ntask1                             task2\ndo_resume\n ->do_suspend\n  ->dm_wait_for_completion\n                                  bio_endio\n\t\t\t\t   ->clone_endio\n\t\t\t\t    ->dm_io_dec_pending\n\t\t\t\t     ->end_io_acct\n\t\t\t\t      ->wakeup task1\n ->dm_swap_table\n  ->__bind\n   ->__bind_mempools\n    ->bioset_exit\n     ->mempool_exit\n                                     ->free_io\n[ 67.330330] Unable to handle kernel NULL pointer dereference at\nvirtual address 0000000000000000\n......\n[ 67.330494] pstate: 80400085 (Nzcv daIf +PAN -UAO)\n[ 67.330510] pc : mempool_free+0x70/0xa0\n[ 67.330515] lr : mempool_free+0x4c/0xa0\n[ 67.330520] sp : ffffff8008013b20\n[ 67.330524] x29: ffffff8008013b20 x28: 0000000000000004\n[ 67.330530] x27: ffffffa8c2ff40a0 x26: 00000000ffff1cc8\n[ 67.330535] x25: 0000000000000000 x24: ffffffdada34c800\n[ 67.330541] x23: 0000000000000000 x22: ffffffdada34c800\n[ 67.330547] x21: 00000000ffff1cc8 x20: ffffffd9a1304d80\n[ 67.330552] x19: ffffffdada34c970 x18: 000000b312625d9c\n[ 67.330558] x17: 00000000002dcfbf x16: 00000000000006dd\n[ 67.330563] x15: 000000000093b41e x14: 0000000000000010\n[ 67.330569] x13: 0000000000007f7a x12: 0000000034155555\n[ 67.330574] x11: 0000000000000001 x10: 0000000000000001\n[ 67.330579] x9 : 0000000000000000 x8 : 0000000000000000\n[ 67.330585] x7 : 0000000000000000 x6 : ffffff80148b5c1a\n[ 67.330590] x5 : ffffff8008013ae0 x4 : 0000000000000001\n[ 67.330596] x3 : ffffff80080139c8 x2 : ffffff801083bab8\n[ 67.330601] x1 : 0000000000000000 x0 : ffffffdada34c970\n[ 67.330609] Call trace:\n[ 67.330616] mempool_free+0x70/0xa0\n[ 67.330627] bio_put+0xf8/0x110\n[ 67.330638] dec_pending+0x13c/0x230\n[ 67.330644] clone_endio+0x90/0x180\n[ 67.330649] bio_endio+0x198/0x1b8\n[ 67.330655] dec_pending+0x190/0x230\n[ 67.330660] clone_endio+0x90/0x180\n[ 67.330665] bio_endio+0x198/0x1b8\n[ 67.330673] blk_update_request+0x214/0x428\n[ 67.330683] scsi_end_request+0x2c/0x300\n[ 67.330688] scsi_io_completion+0xa0/0x710\n[ 67.330695] scsi_finish_command+0xd8/0x110\n[ 67.330700] scsi_softirq_done+0x114/0x148\n[ 67.330708] blk_done_softirq+0x74/0xd0\n[ 67.330716] __do_softirq+0x18c/0x374\n[ 67.330724] irq_exit+0xb4/0xb8\n[ 67.330732] __handle_domain_irq+0x84/0xc0\n[ 67.330737] gic_handle_irq+0x148/0x1b0\n[ 67.330744] el1_irq+0xe8/0x190\n[ 67.330753] lpm_cpuidle_enter+0x4f8/0x538\n[ 67.330759] cpuidle_enter_state+0x1fc/0x398\n[ 67.330764] cpuidle_enter+0x18/0x20\n[ 67.330772] do_idle+0x1b4/0x290\n[ 67.330778] cpu_startup_entry+0x20/0x28\n[ 67.330786] secondary_start_kernel+0x160/0x170\nFix this by:\n1) Establishing pointers to 'struct dm_io' members in\ndm_io_dec_pending() so that they may be passed into end_io_acct()\n_after_ free_io() is called.\n2) Moving end_io_acct() after free_io().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/6e506f07c5b561d673dd0b0d8f7f420cc48024fb"
          },
          {
            "url": "https://git.kernel.org/stable/c/9e07272cca2ed76f7f6073f4444b1143828c8d87"
          },
          {
            "url": "https://git.kernel.org/stable/c/9fb7cd5c7fef0f1c982e3cd27745a0dec260eaed"
          },
          {
            "url": "https://git.kernel.org/stable/c/ad1393b92e5059218d055bfec8f4946d85ad04c4"
          },
          {
            "url": "https://git.kernel.org/stable/c/d208b89401e073de986dc891037c5a668f5d5d95"
          },
          {
            "url": "https://git.kernel.org/stable/c/d29c78d3f9c5d2604548c1065bf1ec212728ea61"
          },
          {
            "url": "https://git.kernel.org/stable/c/d35aef9c60d310eff3eaddacce301efe877e2b7c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47436",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:08.883",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nusb: musb: dsps: Fix the probe error path\nCommit 7c75bde329d7 (\"usb: musb: musb_dsps: request_irq() after\ninitializing musb\") has inverted the calls to\ndsps_setup_optional_vbus_irq() and dsps_create_musb_pdev() without\nupdating correctly the error path. dsps_create_musb_pdev() allocates and\nregisters a new platform device which must be unregistered and freed\nwith platform_device_unregister(), and this is missing upon\ndsps_setup_optional_vbus_irq() error.\nWhile on the master branch it seems not to trigger any issue, I observed\na kernel crash because of a NULL pointer dereference with a v5.10.70\nstable kernel where the patch mentioned above was backported. With this\nkernel version, -EPROBE_DEFER is returned the first time\ndsps_setup_optional_vbus_irq() is called which triggers the probe to\nerror out without unregistering the platform device. Unfortunately, on\nthe Beagle Bone Black Wireless, the platform device still living in the\nsystem is being used by the USB Ethernet gadget driver, which during the\nboot phase triggers the crash.\nMy limited knowledge of the musb world prevents me to revert this commit\nwhich was sent to silence a robot warning which, as far as I understand,\ndoes not make sense. The goal of this patch was to prevent an IRQ to\nfire before the platform device being registered. I think this cannot\never happen due to the fact that enabling the interrupts is done by the\n->enable() callback of the platform musb device, and this platform\ndevice must be already registered in order for the core or any other\nuser to use this callback.\nHence, I decided to fix the error path, which might prevent future\nerrors on mainline kernels while also fixing older ones.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/5ed60a430fb5f3d93e7fef66264daef466b4d10c"
          },
          {
            "url": "https://git.kernel.org/stable/c/9ab5d539bc975b8dcde86eca1b58d836b657732e"
          },
          {
            "url": "https://git.kernel.org/stable/c/9d89e287116796bf987cc48f5c8632ef3048f8eb"
          },
          {
            "url": "https://git.kernel.org/stable/c/c2115b2b16421d93d4993f3fe4c520e91d6fe801"
          },
          {
            "url": "https://git.kernel.org/stable/c/e923bce31ffefe4f60edfc6b84f62d4a858f3676"
          },
          {
            "url": "https://git.kernel.org/stable/c/ff9249aab39820be11b6975a10d94253b7d426fc"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47437",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:08.997",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\niio: adis16475: fix deadlock on frequency set\nWith commit 39c024b51b560\n(\"iio: adis16475: improve sync scale mode handling\"), two deadlocks were\nintroduced:\n 1) The call to 'adis_write_reg_16()' was not changed to it's unlocked\n    version.\n 2) The lock was not being released on the success path of the function.\nThis change fixes both these issues.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/04e03b907022ebd876f422f17efcc2c6cc934dc6"
          },
          {
            "url": "https://git.kernel.org/stable/c/9da1b86865ab4376408c58cd9fec332c8bdb5c73"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47438",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:09.080",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/mlx5e: Fix memory leak in mlx5_core_destroy_cq() error path\nPrior to this patch in case mlx5_core_destroy_cq() failed it returns\nwithout completing all destroy operations and that leads to memory leak.\nInstead, complete the destroy flow before return error.\nAlso move mlx5_debug_cq_remove() to the beginning of mlx5_core_destroy_cq()\nto be symmetrical with mlx5_core_create_cq().\nkmemleak complains on:\nunreferenced object 0xc000000038625100 (size 64):\n  comm \"ethtool\", pid 28301, jiffies 4298062946 (age 785.380s)\n  hex dump (first 32 bytes):\n    60 01 48 94 00 00 00 c0 b8 05 34 c3 00 00 00 c0  `.H.......4.....\n    02 00 00 00 00 00 00 00 00 db 7d c1 00 00 00 c0  ..........}.....\n  backtrace:\n    [<000000009e8643cb>] add_res_tree+0xd0/0x270 [mlx5_core]\n    [<00000000e7cb8e6c>] mlx5_debug_cq_add+0x5c/0xc0 [mlx5_core]\n    [<000000002a12918f>] mlx5_core_create_cq+0x1d0/0x2d0 [mlx5_core]\n    [<00000000cef0a696>] mlx5e_create_cq+0x210/0x3f0 [mlx5_core]\n    [<000000009c642c26>] mlx5e_open_cq+0xb4/0x130 [mlx5_core]\n    [<0000000058dfa578>] mlx5e_ptp_open+0x7f4/0xe10 [mlx5_core]\n    [<0000000081839561>] mlx5e_open_channels+0x9cc/0x13e0 [mlx5_core]\n    [<0000000009cf05d4>] mlx5e_switch_priv_channels+0xa4/0x230\n[mlx5_core]\n    [<0000000042bbedd8>] mlx5e_safe_switch_params+0x14c/0x300\n[mlx5_core]\n    [<0000000004bc9db8>] set_pflag_tx_port_ts+0x9c/0x160 [mlx5_core]\n    [<00000000a0553443>] mlx5e_set_priv_flags+0xd0/0x1b0 [mlx5_core]\n    [<00000000a8f3d84b>] ethnl_set_privflags+0x234/0x2d0\n    [<00000000fd27f27c>] genl_family_rcv_msg_doit+0x108/0x1d0\n    [<00000000f495e2bb>] genl_family_rcv_msg+0xe4/0x1f0\n    [<00000000646c5c2c>] genl_rcv_msg+0x78/0x120\n    [<00000000d53e384e>] netlink_rcv_skb+0x74/0x1a0",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4f7bddf8c5c01cac74373443b13a68e1c6723a94"
          },
          {
            "url": "https://git.kernel.org/stable/c/94b960b9deffc02fc0747afc01f72cc62ab099e3"
          },
          {
            "url": "https://git.kernel.org/stable/c/ed8aafea4fec9c654e63445236e0b505e27ed3a7"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47439",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:09.163",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: dsa: microchip: Added the condition for scheduling ksz_mib_read_work\nWhen the ksz module is installed and removed using rmmod, kernel crashes\nwith null pointer dereferrence error. During rmmod, ksz_switch_remove\nfunction tries to cancel the mib_read_workqueue using\ncancel_delayed_work_sync routine and unregister switch from dsa.\nDuring dsa_unregister_switch it calls ksz_mac_link_down, which in turn\nreschedules the workqueue since mib_interval is non-zero.\nDue to which queue executed after mib_interval and it tries to access\ndp->slave. But the slave is unregistered in the ksz_switch_remove\nfunction. Hence kernel crashes.\nTo avoid this crash, before canceling the workqueue, resetted the\nmib_interval to 0.\nv1 -> v2:\n-Removed the if condition in ksz_mib_read_work",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/383239a33cf29ebee9ce0d4e0e5c900b77a16148"
          },
          {
            "url": "https://git.kernel.org/stable/c/ef1100ef20f29aec4e62abeccdb5bdbebba1e378"
          },
          {
            "url": "https://git.kernel.org/stable/c/f2e1de075018cf71bcd7d628e9f759cb8540b0c3"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47440",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:09.250",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: encx24j600: check error in devm_regmap_init_encx24j600\ndevm_regmap_init may return error which caused by like out of memory,\nthis will results in null pointer dereference later when reading\nor writing register:\ngeneral protection fault in encx24j600_spi_probe\nKASAN: null-ptr-deref in range [0x0000000000000090-0x0000000000000097]\nCPU: 0 PID: 286 Comm: spi-encx24j600- Not tainted 5.15.0-rc2-00142-g9978db750e31-dirty #11 9c53a778c1306b1b02359f3c2bbedc0222cba652\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014\nRIP: 0010:regcache_cache_bypass drivers/base/regmap/regcache.c:540\nCode: 54 41 89 f4 55 53 48 89 fb 48 83 ec 08 e8 26 94 a8 fe 48 8d bb a0 00 00 00 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 <80> 3c 02 00 0f 85 4a 03 00 00 4c 8d ab b0 00 00 00 48 8b ab a0 00\nRSP: 0018:ffffc900010476b8 EFLAGS: 00010207\nRAX: dffffc0000000000 RBX: fffffffffffffff4 RCX: 0000000000000000\nRDX: 0000000000000012 RSI: ffff888002de0000 RDI: 0000000000000094\nRBP: ffff888013c9a000 R08: 0000000000000000 R09: fffffbfff3f9cc6a\nR10: ffffc900010476e8 R11: fffffbfff3f9cc69 R12: 0000000000000001\nR13: 000000000000000a R14: ffff888013c9af54 R15: ffff888013c9ad08\nFS:  00007ffa984ab580(0000) GS:ffff88801fe00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000055a6384136c8 CR3: 000000003bbe6003 CR4: 0000000000770ef0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n encx24j600_spi_probe drivers/net/ethernet/microchip/encx24j600.c:459\n spi_probe drivers/spi/spi.c:397\n really_probe drivers/base/dd.c:517\n __driver_probe_device drivers/base/dd.c:751\n driver_probe_device drivers/base/dd.c:782\n __device_attach_driver drivers/base/dd.c:899\n bus_for_each_drv drivers/base/bus.c:427\n __device_attach drivers/base/dd.c:971\n bus_probe_device drivers/base/bus.c:487\n device_add drivers/base/core.c:3364\n __spi_add_device drivers/spi/spi.c:599\n spi_add_device drivers/spi/spi.c:641\n spi_new_device drivers/spi/spi.c:717\n new_device_store+0x18c/0x1f1 [spi_stub 4e02719357f1ff33f5a43d00630982840568e85e]\n dev_attr_store drivers/base/core.c:2074\n sysfs_kf_write fs/sysfs/file.c:139\n kernfs_fop_write_iter fs/kernfs/file.c:300\n new_sync_write fs/read_write.c:508 (discriminator 4)\n vfs_write fs/read_write.c:594\n ksys_write fs/read_write.c:648\n do_syscall_64 arch/x86/entry/common.c:50\n entry_SYSCALL_64_after_hwframe arch/x86/entry/entry_64.S:113\nAdd error check in devm_regmap_init_encx24j600 to avoid this situation.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/322c0e53496309e634d9db7349678eaad1d25b55"
          },
          {
            "url": "https://git.kernel.org/stable/c/4c2eb80fc90b05559ce6ed1b8dfb2348420b5644"
          },
          {
            "url": "https://git.kernel.org/stable/c/5e5494e6fc8a29c927e0478bec4a078a40da8901"
          },
          {
            "url": "https://git.kernel.org/stable/c/66358471fa75a713fd76bc8a4bd74cb14cd50a4f"
          },
          {
            "url": "https://git.kernel.org/stable/c/e19c10d6e07c59c96e90fe053a72683ad8b0397e"
          },
          {
            "url": "https://git.kernel.org/stable/c/f03dca0c9e2297c84a018e306f8a9cd534ee4287"
          },
          {
            "url": "https://git.kernel.org/stable/c/f043fac1133a6c5ef960a8422c0f6dd711dee462"
          },
          {
            "url": "https://git.kernel.org/stable/c/fddc7f678d7fb93caa0d7bc512f968ff1e2bddbc"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47441",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:09.340",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmlxsw: thermal: Fix out-of-bounds memory accesses\nCurrently, mlxsw allows cooling states to be set above the maximum\ncooling state supported by the driver:\n # cat /sys/class/thermal/thermal_zone2/cdev0/type\n mlxsw_fan\n # cat /sys/class/thermal/thermal_zone2/cdev0/max_state\n 10\n # echo 18 > /sys/class/thermal/thermal_zone2/cdev0/cur_state\n # echo $?\n 0\nThis results in out-of-bounds memory accesses when thermal state\ntransition statistics are enabled (CONFIG_THERMAL_STATISTICS=y), as the\ntransition table is accessed with a too large index (state) [1].\nAccording to the thermal maintainer, it is the responsibility of the\ndriver to reject such operations [2].\nTherefore, return an error when the state to be set exceeds the maximum\ncooling state supported by the driver.\nTo avoid dead code, as suggested by the thermal maintainer [3],\npartially revert commit a421ce088ac8 (\"mlxsw: core: Extend cooling\ndevice with cooling levels\") that tried to interpret these invalid\ncooling states (above the maximum) in a special way. The cooling levels\narray is not removed in order to prevent the fans going below 20% PWM,\nwhich would cause them to get stuck at 0% PWM.\n[1]\nBUG: KASAN: slab-out-of-bounds in thermal_cooling_device_stats_update+0x271/0x290\nRead of size 4 at addr ffff8881052f7bf8 by task kworker/0:0/5\nCPU: 0 PID: 5 Comm: kworker/0:0 Not tainted 5.15.0-rc3-custom-45935-gce1adf704b14 #122\nHardware name: Mellanox Technologies Ltd. \"MSN2410-CB2FO\"/\"SA000874\", BIOS 4.6.5 03/08/2016\nWorkqueue: events_freezable_power_ thermal_zone_device_check\nCall Trace:\n dump_stack_lvl+0x8b/0xb3\n print_address_description.constprop.0+0x1f/0x140\n kasan_report.cold+0x7f/0x11b\n thermal_cooling_device_stats_update+0x271/0x290\n __thermal_cdev_update+0x15e/0x4e0\n thermal_cdev_update+0x9f/0xe0\n step_wise_throttle+0x770/0xee0\n thermal_zone_device_update+0x3f6/0xdf0\n process_one_work+0xa42/0x1770\n worker_thread+0x62f/0x13e0\n kthread+0x3ee/0x4e0\n ret_from_fork+0x1f/0x30\nAllocated by task 1:\n kasan_save_stack+0x1b/0x40\n __kasan_kmalloc+0x7c/0x90\n thermal_cooling_device_setup_sysfs+0x153/0x2c0\n __thermal_cooling_device_register.part.0+0x25b/0x9c0\n thermal_cooling_device_register+0xb3/0x100\n mlxsw_thermal_init+0x5c5/0x7e0\n __mlxsw_core_bus_device_register+0xcb3/0x19c0\n mlxsw_core_bus_device_register+0x56/0xb0\n mlxsw_pci_probe+0x54f/0x710\n local_pci_probe+0xc6/0x170\n pci_device_probe+0x2b2/0x4d0\n really_probe+0x293/0xd10\n __driver_probe_device+0x2af/0x440\n driver_probe_device+0x51/0x1e0\n __driver_attach+0x21b/0x530\n bus_for_each_dev+0x14c/0x1d0\n bus_add_driver+0x3ac/0x650\n driver_register+0x241/0x3d0\n mlxsw_sp_module_init+0xa2/0x174\n do_one_initcall+0xee/0x5f0\n kernel_init_freeable+0x45a/0x4de\n kernel_init+0x1f/0x210\n ret_from_fork+0x1f/0x30\nThe buggy address belongs to the object at ffff8881052f7800\n which belongs to the cache kmalloc-1k of size 1024\nThe buggy address is located 1016 bytes inside of\n 1024-byte region [ffff8881052f7800, ffff8881052f7c00)\nThe buggy address belongs to the page:\npage:0000000052355272 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1052f0\nhead:0000000052355272 order:3 compound_mapcount:0 compound_pincount:0\nflags: 0x200000000010200(slab|head|node=0|zone=2)\nraw: 0200000000010200 ffffea0005034800 0000000300000003 ffff888100041dc0\nraw: 0000000000000000 0000000000100010 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\nMemory state around the buggy address:\n ffff8881052f7a80: 00 00 00 00 00 00 04 fc fc fc fc fc fc fc fc fc\n ffff8881052f7b00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n>ffff8881052f7b80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n                                                                ^\n ffff8881052f7c00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff8881052f7c80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[2] https://lore.kernel.org/linux-pm/9aca37cb-1629-5c67-\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/332fdf951df8b870e3da86b122ae304e2aabe88c"
          },
          {
            "url": "https://git.kernel.org/stable/c/ae0993739e14a102d506aa09e11b0065f3144f10"
          },
          {
            "url": "https://git.kernel.org/stable/c/df8e58716afb3bee2b59de66b1ba1033f2e26303"
          },
          {
            "url": "https://git.kernel.org/stable/c/e59d839743b50cb1d3f42a786bea48cc5621d254"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47442",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:09.430",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nNFC: digital: fix possible memory leak in digital_in_send_sdd_req()\n'skb' is allocated in digital_in_send_sdd_req(), but not free when\ndigital_in_send_cmd() failed, which will cause memory leak. Fix it\nby freeing 'skb' if digital_in_send_cmd() return failed.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/071bdef36391958c89af5fa2172f691b31baa212"
          },
          {
            "url": "https://git.kernel.org/stable/c/291c932fc3692e4d211a445ba8aa35663831bac7"
          },
          {
            "url": "https://git.kernel.org/stable/c/2bde4aca56db9fe25405d39ddb062531493a65db"
          },
          {
            "url": "https://git.kernel.org/stable/c/50cb95487c265187289810addec5093d4fed8329"
          },
          {
            "url": "https://git.kernel.org/stable/c/6432d7f1d1c3aa74cfe8f5e3afdf81b786c32e86"
          },
          {
            "url": "https://git.kernel.org/stable/c/74569c78aa84f8c958f1334b465bc530906ec99a"
          },
          {
            "url": "https://git.kernel.org/stable/c/88c890b0b9a1fb9fcd01c61ada515e8b636c34f9"
          },
          {
            "url": "https://git.kernel.org/stable/c/fcce6e5255474ca33c27dda0cdf9bf5087278873"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47443",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:09.570",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nNFC: digital: fix possible memory leak in digital_tg_listen_mdaa()\n'params' is allocated in digital_tg_listen_mdaa(), but not free when\ndigital_send_cmd() failed, which will cause memory leak. Fix it by\nfreeing 'params' if digital_send_cmd() return failed.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3f2960b39f22e26cf8addae93c3f5884d1c183c9"
          },
          {
            "url": "https://git.kernel.org/stable/c/429054ec51e648d241a7e0b465cf44f6633334c5"
          },
          {
            "url": "https://git.kernel.org/stable/c/564249219e5b5673a8416b5181875d828c3f1e8c"
          },
          {
            "url": "https://git.kernel.org/stable/c/58e7dcc9ca29c14e44267a4d0ea61e3229124907"
          },
          {
            "url": "https://git.kernel.org/stable/c/7ab488d7228a9dceb2456867f1f0919decf6efed"
          },
          {
            "url": "https://git.kernel.org/stable/c/9881b0c860649f27ef2565deef011e516390f416"
          },
          {
            "url": "https://git.kernel.org/stable/c/a67d47e32c91e2b10402cb8c081774cbf08edb2e"
          },
          {
            "url": "https://git.kernel.org/stable/c/b7b023e6ff567e991c31cd425b0e1d16779c938b"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47444",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:09.660",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/edid: In connector_bad_edid() cap num_of_ext by num_blocks read\nIn commit e11f5bd8228f (\"drm: Add support for DP 1.4 Compliance edid\ncorruption test\") the function connector_bad_edid() started assuming\nthat the memory for the EDID passed to it was big enough to hold\n`edid[0x7e] + 1` blocks of data (1 extra for the base block). It\ncompletely ignored the fact that the function was passed `num_blocks`\nwhich indicated how much memory had been allocated for the EDID.\nLet's fix this by adding a bounds check.\nThis is important for handling the case where there's an error in the\nfirst block of the EDID. In that case we will call\nconnector_bad_edid() without having re-allocated memory based on\n`edid[0x7e]`.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/09f3946bb452918dbfb1982add56f9ffaae393dc"
          },
          {
            "url": "https://git.kernel.org/stable/c/97794170b696856483f74b47bfb6049780d2d3a0"
          },
          {
            "url": "https://git.kernel.org/stable/c/a7b45024f66f9ec769e8dbb1a51ae83cd05929c7"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47445",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:09.733",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/msm: Fix null pointer dereference on pointer edp\nThe initialization of pointer dev dereferences pointer edp before\nedp is null checked, so there is a potential null pointer deference\nissue. Fix this by only dereferencing edp after edp has been null\nchecked.\nAddresses-Coverity: (\"Dereference before null check\")",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0cd063aa0a09822cc1620fc59a67fe2f9f6338ac"
          },
          {
            "url": "https://git.kernel.org/stable/c/2133c4fc8e1348dcb752f267a143fe2254613b34"
          },
          {
            "url": "https://git.kernel.org/stable/c/46c8ddede0273d1d132beefa9de8b820326982be"
          },
          {
            "url": "https://git.kernel.org/stable/c/7f642b93710b6b1119bdff90be01e6b5a2a5d669"
          },
          {
            "url": "https://git.kernel.org/stable/c/91a340768b012f5b910a203a805b97a345b3db37"
          },
          {
            "url": "https://git.kernel.org/stable/c/bacac7d26849c8e903ceb7466d9ce8dc3c2797eb"
          },
          {
            "url": "https://git.kernel.org/stable/c/f175b9a83e5c252d7c74acddc792840016caae0a"
          },
          {
            "url": "https://git.kernel.org/stable/c/f302be08e3de94db8863a0b2958b2bb3e8e998e6"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47446",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:09.820",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/msm/a4xx: fix error handling in a4xx_gpu_init()\nThis code returns 1 on error instead of a negative error.  It leads to\nan Oops in the caller.  A second problem is that the check for\n\"if (ret != -ENODATA)\" cannot be true because \"ret\" is set to 1.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3962d626eb3e3b23ebb2e2a61537fa764acbfe11"
          },
          {
            "url": "https://git.kernel.org/stable/c/980d74e7d03ccf2eaa11d133416946bd880c7c08"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47447",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:09.897",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/msm/a3xx: fix error handling in a3xx_gpu_init()\nThese error paths returned 1 on failure, instead of a negative error\ncode.  This would lead to an Oops in the caller.  A second problem is\nthat the check for \"if (ret != -ENODATA)\" did not work because \"ret\" was\nset to 1.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3eda901995371d390ef82d0b6462f4ea8efbcfdf"
          },
          {
            "url": "https://git.kernel.org/stable/c/d59e44e7821a8f2bb6f2e846b9167397a5f01608"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47448",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:09.970",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmptcp: fix possible stall on recvmsg()\nrecvmsg() can enter an infinite loop if the caller provides the\nMSG_WAITALL, the data present in the receive queue is not sufficient to\nfulfill the request, and no more data is received by the peer.\nWhen the above happens, mptcp_wait_data() will always return with\nno wait, as the MPTCP_DATA_READY flag checked by such function is\nset and never cleared in such code path.\nLeveraging the above syzbot was able to trigger an RCU stall:\nrcu: INFO: rcu_preempt self-detected stall on CPU\nrcu:    0-...!: (10499 ticks this GP) idle=0af/1/0x4000000000000000 softirq=10678/10678 fqs=1\n        (t=10500 jiffies g=13089 q=109)\nrcu: rcu_preempt kthread starved for 10497 jiffies! g13089 f0x0 RCU_GP_WAIT_FQS(5) ->state=0x0 ->cpu=1\nrcu:    Unless rcu_preempt kthread gets sufficient CPU time, OOM is now expected behavior.\nrcu: RCU grace-period kthread stack dump:\ntask:rcu_preempt     state:R  running task     stack:28696 pid:   14 ppid:     2 flags:0x00004000\nCall Trace:\n context_switch kernel/sched/core.c:4955 [inline]\n __schedule+0x940/0x26f0 kernel/sched/core.c:6236\n schedule+0xd3/0x270 kernel/sched/core.c:6315\n schedule_timeout+0x14a/0x2a0 kernel/time/timer.c:1881\n rcu_gp_fqs_loop+0x186/0x810 kernel/rcu/tree.c:1955\n rcu_gp_kthread+0x1de/0x320 kernel/rcu/tree.c:2128\n kthread+0x405/0x4f0 kernel/kthread.c:327\n ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:295\nrcu: Stack dump where RCU GP kthread last ran:\nSending NMI from CPU 0 to CPUs 1:\nNMI backtrace for cpu 1\nCPU: 1 PID: 8510 Comm: syz-executor827 Not tainted 5.15.0-rc2-next-20210920-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nRIP: 0010:bytes_is_nonzero mm/kasan/generic.c:84 [inline]\nRIP: 0010:memory_is_nonzero mm/kasan/generic.c:102 [inline]\nRIP: 0010:memory_is_poisoned_n mm/kasan/generic.c:128 [inline]\nRIP: 0010:memory_is_poisoned mm/kasan/generic.c:159 [inline]\nRIP: 0010:check_region_inline mm/kasan/generic.c:180 [inline]\nRIP: 0010:kasan_check_range+0xc8/0x180 mm/kasan/generic.c:189\nCode: 38 00 74 ed 48 8d 50 08 eb 09 48 83 c0 01 48 39 d0 74 7a 80 38 00 74 f2 48 89 c2 b8 01 00 00 00 48 85 d2 75 56 5b 5d 41 5c c3 <48> 85 d2 74 5e 48 01 ea eb 09 48 83 c0 01 48 39 d0 74 50 80 38 00\nRSP: 0018:ffffc9000cd676c8 EFLAGS: 00000283\nRAX: ffffed100e9a110e RBX: ffffed100e9a110f RCX: ffffffff88ea062a\nRDX: 0000000000000001 RSI: 0000000000000008 RDI: ffff888074d08870\nRBP: ffffed100e9a110e R08: 0000000000000001 R09: ffff888074d08877\nR10: ffffed100e9a110e R11: 0000000000000000 R12: ffff888074d08000\nR13: ffff888074d08000 R14: ffff888074d08088 R15: ffff888074d08000\nFS:  0000555556d8e300(0000) GS:ffff8880b9d00000(0000) knlGS:0000000000000000\nS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000020000180 CR3: 0000000068909000 CR4: 00000000001506e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n instrument_atomic_read_write include/linux/instrumented.h:101 [inline]\n test_and_clear_bit include/asm-generic/bitops/instrumented-atomic.h:83 [inline]\n mptcp_release_cb+0x14a/0x210 net/mptcp/protocol.c:3016\n release_sock+0xb4/0x1b0 net/core/sock.c:3204\n mptcp_wait_data net/mptcp/protocol.c:1770 [inline]\n mptcp_recvmsg+0xfd1/0x27b0 net/mptcp/protocol.c:2080\n inet6_recvmsg+0x11b/0x5e0 net/ipv6/af_inet6.c:659\n sock_recvmsg_nosec net/socket.c:944 [inline]\n ____sys_recvmsg+0x527/0x600 net/socket.c:2626\n ___sys_recvmsg+0x127/0x200 net/socket.c:2670\n do_recvmmsg+0x24d/0x6d0 net/socket.c:2764\n __sys_recvmmsg net/socket.c:2843 [inline]\n __do_sys_recvmmsg net/socket.c:2866 [inline]\n __se_sys_recvmmsg net/socket.c:2859 [inline]\n __x64_sys_recvmmsg+0x20b/0x260 net/socket.c:2859\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x44/0xae\nRIP: 0033:0x7fc200d2\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1a4554e94f0deff9fc1dc5addf93fa579cc29711"
          },
          {
            "url": "https://git.kernel.org/stable/c/612f71d7328c14369924384ad2170aae2a6abd92"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47449",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:10.050",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nice: fix locking for Tx timestamp tracking flush\nCommit 4dd0d5c33c3e (\"ice: add lock around Tx timestamp tracker flush\")\nadded a lock around the Tx timestamp tracker flow which is used to\ncleanup any left over SKBs and prepare for device removal.\nThis lock is problematic because it is being held around a call to\nice_clear_phy_tstamp. The clear function takes a mutex to send a PHY\nwrite command to firmware. This could lead to a deadlock if the mutex\nactually sleeps, and causes the following warning on a kernel with\npreemption debugging enabled:\n[  715.419426] BUG: sleeping function called from invalid context at kernel/locking/mutex.c:573\n[  715.427900] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 3100, name: rmmod\n[  715.435652] INFO: lockdep is turned off.\n[  715.439591] Preemption disabled at:\n[  715.439594] [<0000000000000000>] 0x0\n[  715.446678] CPU: 52 PID: 3100 Comm: rmmod Tainted: G        W  OE     5.15.0-rc4+ #42 bdd7ec3018e725f159ca0d372ce8c2c0e784891c\n[  715.458058] Hardware name: Intel Corporation S2600STQ/S2600STQ, BIOS SE5C620.86B.02.01.0010.010620200716 01/06/2020\n[  715.468483] Call Trace:\n[  715.470940]  dump_stack_lvl+0x6a/0x9a\n[  715.474613]  ___might_sleep.cold+0x224/0x26a\n[  715.478895]  __mutex_lock+0xb3/0x1440\n[  715.482569]  ? stack_depot_save+0x378/0x500\n[  715.486763]  ? ice_sq_send_cmd+0x78/0x14c0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.494979]  ? kfree+0xc1/0x520\n[  715.498128]  ? mutex_lock_io_nested+0x12a0/0x12a0\n[  715.502837]  ? kasan_set_free_info+0x20/0x30\n[  715.507110]  ? __kasan_slab_free+0x10b/0x140\n[  715.511385]  ? slab_free_freelist_hook+0xc7/0x220\n[  715.516092]  ? kfree+0xc1/0x520\n[  715.519235]  ? ice_deinit_lag+0x16c/0x220 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.527359]  ? ice_remove+0x1cf/0x6a0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.535133]  ? pci_device_remove+0xab/0x1d0\n[  715.539318]  ? __device_release_driver+0x35b/0x690\n[  715.544110]  ? driver_detach+0x214/0x2f0\n[  715.548035]  ? bus_remove_driver+0x11d/0x2f0\n[  715.552309]  ? pci_unregister_driver+0x26/0x250\n[  715.556840]  ? ice_module_exit+0xc/0x2f [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.564799]  ? __do_sys_delete_module.constprop.0+0x2d8/0x4e0\n[  715.570554]  ? do_syscall_64+0x3b/0x90\n[  715.574303]  ? entry_SYSCALL_64_after_hwframe+0x44/0xae\n[  715.579529]  ? start_flush_work+0x542/0x8f0\n[  715.583719]  ? ice_sq_send_cmd+0x78/0x14c0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.591923]  ice_sq_send_cmd+0x78/0x14c0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.599960]  ? wait_for_completion_io+0x250/0x250\n[  715.604662]  ? lock_acquire+0x196/0x200\n[  715.608504]  ? do_raw_spin_trylock+0xa5/0x160\n[  715.612864]  ice_sbq_rw_reg+0x1e6/0x2f0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.620813]  ? ice_reset+0x130/0x130 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.628497]  ? __debug_check_no_obj_freed+0x1e8/0x3c0\n[  715.633550]  ? trace_hardirqs_on+0x1c/0x130\n[  715.637748]  ice_write_phy_reg_e810+0x70/0xf0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.646220]  ? do_raw_spin_trylock+0xa5/0x160\n[  715.650581]  ? ice_ptp_release+0x910/0x910 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.658797]  ? ice_ptp_release+0x255/0x910 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.667013]  ice_clear_phy_tstamp+0x2c/0x110 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.675403]  ice_ptp_release+0x408/0x910 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.683440]  ice_remove+0x560/0x6a0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.691037]  ? _raw_spin_unlock_irqrestore+0x46/0x73\n[  715.696005]  pci_device_remove+0xab/0x1d0\n[  715.700018]  __device_release_driver+0x35b/0x690\n[  715.704637]  driver_detach+0x214/0x2f0\n[  715.708389]  bus_remove_driver+0x11d/0x2f0\n[  715.712489]  pci_unregister_driver+0x26/0x250\n[  71\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4d4a223a86afe658cd878800f09458e8bb54415d"
          },
          {
            "url": "https://git.kernel.org/stable/c/61616be899975404df44c20ab902464b60882cd7"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47450",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:10.143",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nKVM: arm64: Fix host stage-2 PGD refcount\nThe KVM page-table library refcounts the pages of concatenated stage-2\nPGDs individually. However, when running KVM in protected mode, the\nhost's stage-2 PGD is currently managed by EL2 as a single high-order\ncompound page, which can cause the refcount of the tail pages to reach 0\nwhen they shouldn't, hence corrupting the page-table.\nFix this by introducing a new hyp_split_page() helper in the EL2 page\nallocator (matching the kernel's split_page() function), and make use of\nit from host_s2_zalloc_pages_exact().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1d58a17ef54599506d44c45ac95be27273a4d2b1"
          },
          {
            "url": "https://git.kernel.org/stable/c/b372264c66ef78f2cab44e877fbd765ad6d24c39"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47451",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:10.220",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnetfilter: xt_IDLETIMER: fix panic that occurs when timer_type has garbage value\nCurrently, when the rule related to IDLETIMER is added, idletimer_tg timer\nstructure is initialized by kmalloc on executing idletimer_tg_create\nfunction. However, in this process timer->timer_type is not defined to\na specific value. Thus, timer->timer_type has garbage value and it occurs\nkernel panic. So, this commit fixes the panic by initializing\ntimer->timer_type using kzalloc instead of kmalloc.\nTest commands:\n    # iptables -A OUTPUT -j IDLETIMER --timeout 1 --label test\n    $ cat /sys/class/xt_idletimer/timers/test\n      Killed\nSplat looks like:\n    BUG: KASAN: user-memory-access in alarm_expires_remaining+0x49/0x70\n    Read of size 8 at addr 0000002e8c7bc4c8 by task cat/917\n    CPU: 12 PID: 917 Comm: cat Not tainted 5.14.0+ #3 79940a339f71eb14fc81aee1757a20d5bf13eb0e\n    Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-1ubuntu1.1 04/01/2014\n    Call Trace:\n     dump_stack_lvl+0x6e/0x9c\n     kasan_report.cold+0x112/0x117\n     ? alarm_expires_remaining+0x49/0x70\n     __asan_load8+0x86/0xb0\n     alarm_expires_remaining+0x49/0x70\n     idletimer_tg_show+0xe5/0x19b [xt_IDLETIMER 11219304af9316a21bee5ba9d58f76a6b9bccc6d]\n     dev_attr_show+0x3c/0x60\n     sysfs_kf_seq_show+0x11d/0x1f0\n     ? device_remove_bin_file+0x20/0x20\n     kernfs_seq_show+0xa4/0xb0\n     seq_read_iter+0x29c/0x750\n     kernfs_fop_read_iter+0x25a/0x2c0\n     ? __fsnotify_parent+0x3d1/0x570\n     ? iov_iter_init+0x70/0x90\n     new_sync_read+0x2a7/0x3d0\n     ? __x64_sys_llseek+0x230/0x230\n     ? rw_verify_area+0x81/0x150\n     vfs_read+0x17b/0x240\n     ksys_read+0xd9/0x180\n     ? vfs_write+0x460/0x460\n     ? do_syscall_64+0x16/0xc0\n     ? lockdep_hardirqs_on+0x79/0x120\n     __x64_sys_read+0x43/0x50\n     do_syscall_64+0x3b/0xc0\n     entry_SYSCALL_64_after_hwframe+0x44/0xae\n    RIP: 0033:0x7f0cdc819142\n    Code: c0 e9 c2 fe ff ff 50 48 8d 3d 3a ca 0a 00 e8 f5 19 02 00 0f 1f 44 00 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 0f 05 <48> 3d 00 f0 ff ff 77 56 c3 0f 1f 44 00 00 48 83 ec 28 48 89 54 24\n    RSP: 002b:00007fff28eee5b8 EFLAGS: 00000246 ORIG_RAX: 0000000000000000\n    RAX: ffffffffffffffda RBX: 0000000000020000 RCX: 00007f0cdc819142\n    RDX: 0000000000020000 RSI: 00007f0cdc032000 RDI: 0000000000000003\n    RBP: 00007f0cdc032000 R08: 00007f0cdc031010 R09: 0000000000000000\n    R10: 0000000000000022 R11: 0000000000000246 R12: 00005607e9ee31f0\n    R13: 0000000000000003 R14: 0000000000020000 R15: 0000000000020000",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2a670c323055282c9b72794a491d53cef86bbeaf"
          },
          {
            "url": "https://git.kernel.org/stable/c/902c0b1887522a099aa4e1e6b4b476c2fe5dd13e"
          },
          {
            "url": "https://git.kernel.org/stable/c/cae7cab804c943d723d52724a3aeb07a3f4a2650"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47452",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:10.300",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnetfilter: nf_tables: skip netdev events generated on netns removal\nsyzbot reported following (harmless) WARN:\n WARNING: CPU: 1 PID: 2648 at net/netfilter/core.c:468\n  nft_netdev_unregister_hooks net/netfilter/nf_tables_api.c:230 [inline]\n  nf_tables_unregister_hook include/net/netfilter/nf_tables.h:1090 [inline]\n  __nft_release_basechain+0x138/0x640 net/netfilter/nf_tables_api.c:9524\n  nft_netdev_event net/netfilter/nft_chain_filter.c:351 [inline]\n  nf_tables_netdev_event+0x521/0x8a0 net/netfilter/nft_chain_filter.c:382\nreproducer:\nunshare -n bash -c 'ip link add br0 type bridge; nft add table netdev t ; \\\n nft add chain netdev t ingress \\{ type filter hook ingress device \"br0\" \\\n priority 0\\; policy drop\\; \\}'\nProblem is that when netns device exit hooks create the UNREGISTER\nevent, the .pre_exit hook for nf_tables core has already removed the\nbase hook.  Notifier attempts to do this again.\nThe need to do base hook unregister unconditionally was needed in the past,\nbecause notifier was last stage where reg->dev dereference was safe.\nNow that nf_tables does the hook removal in .pre_exit, this isn't\nneeded anymore.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/68a3765c659f809dcaac20030853a054646eb739"
          },
          {
            "url": "https://git.kernel.org/stable/c/90c7c58aa2bd02c65a4c63b7dfe0b16eab12cf9f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47453",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:10.380",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nice: Avoid crash from unnecessary IDA free\nIn the remove path, there is an attempt to free the aux_idx IDA whether\nit was allocated or not.  This can potentially cause a crash when\nunloading the driver on systems that do not initialize support for RDMA.\nBut, this free cannot be gated by the status bit for RDMA, since it is\nallocated if the driver detects support for RDMA at probe time, but the\ndriver can enter into a state where RDMA is not supported after the IDA\nhas been allocated at probe time and this would lead to a memory leak.\nInitialize aux_idx to an invalid value and check for a valid value when\nunloading to determine if an IDA free is necessary.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/73e30a62b19b9fbb4e6a3465c59da186630d5f2e"
          },
          {
            "url": "https://git.kernel.org/stable/c/777682e59840e24e6c5672197e6ffbcf4bff823b"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47454",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:10.453",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\npowerpc/smp: do not decrement idle task preempt count in CPU offline\nWith PREEMPT_COUNT=y, when a CPU is offlined and then onlined again, we\nget:\nBUG: scheduling while atomic: swapper/1/0/0x00000000\nno locks held by swapper/1/0.\nCPU: 1 PID: 0 Comm: swapper/1 Not tainted 5.15.0-rc2+ #100\nCall Trace:\n dump_stack_lvl+0xac/0x108\n __schedule_bug+0xac/0xe0\n __schedule+0xcf8/0x10d0\n schedule_idle+0x3c/0x70\n do_idle+0x2d8/0x4a0\n cpu_startup_entry+0x38/0x40\n start_secondary+0x2ec/0x3a0\n start_secondary_prolog+0x10/0x14\nThis is because powerpc's arch_cpu_idle_dead() decrements the idle task's\npreempt count, for reasons explained in commit a7c2bb8279d2 (\"powerpc:\nRe-enable preemption before cpu_die()\"), specifically \"start_secondary()\nexpects a preempt_count() of 0.\"\nHowever, since commit 2c669ef6979c (\"powerpc/preempt: Don't touch the idle\ntask's preempt_count during hotplug\") and commit f1a0a376ca0c (\"sched/core:\nInitialize the idle task with preemption disabled\"), that justification no\nlonger holds.\nThe idle task isn't supposed to re-enable preemption, so remove the\nvestigial preempt_enable() from the CPU offline path.\nTested with pseries and powernv in qemu, and pseries on PowerVM.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3ea0b497a7a2fff6a4b7090310c9f52c91975934"
          },
          {
            "url": "https://git.kernel.org/stable/c/53770a411559cf7bc0906d1df319cc533d2f4f58"
          },
          {
            "url": "https://git.kernel.org/stable/c/787252a10d9422f3058df9a4821f389e5326c440"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47455",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:10.530",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nptp: Fix possible memory leak in ptp_clock_register()\nI got memory leak as follows when doing fault injection test:\nunreferenced object 0xffff88800906c618 (size 8):\n  comm \"i2c-idt82p33931\", pid 4421, jiffies 4294948083 (age 13.188s)\n  hex dump (first 8 bytes):\n    70 74 70 30 00 00 00 00                          ptp0....\n  backtrace:\n    [<00000000312ed458>] __kmalloc_track_caller+0x19f/0x3a0\n    [<0000000079f6e2ff>] kvasprintf+0xb5/0x150\n    [<0000000026aae54f>] kvasprintf_const+0x60/0x190\n    [<00000000f323a5f7>] kobject_set_name_vargs+0x56/0x150\n    [<000000004e35abdd>] dev_set_name+0xc0/0x100\n    [<00000000f20cfe25>] ptp_clock_register+0x9f4/0xd30 [ptp]\n    [<000000008bb9f0de>] idt82p33_probe.cold+0x8b6/0x1561 [ptp_idt82p33]\nWhen posix_clock_register() returns an error, the name allocated\nin dev_set_name() will be leaked, the put_device() should be used\nto give up the device reference, then the name will be freed in\nkobject_cleanup() and other memory will be freed in ptp_clock_release().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4225fea1cb28370086e17e82c0f69bec2779dca0"
          },
          {
            "url": "https://git.kernel.org/stable/c/95c0a0c5ec8839f8f21672be786e87a100319ca8"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47456",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:10.627",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ncan: peak_pci: peak_pci_remove(): fix UAF\nWhen remove the module peek_pci, referencing 'chan' again after\nreleasing 'dev' will cause UAF.\nFix this by releasing 'dev' later.\nThe following log reveals it:\n[   35.961814 ] BUG: KASAN: use-after-free in peak_pci_remove+0x16f/0x270 [peak_pci]\n[   35.963414 ] Read of size 8 at addr ffff888136998ee8 by task modprobe/5537\n[   35.965513 ] Call Trace:\n[   35.965718 ]  dump_stack_lvl+0xa8/0xd1\n[   35.966028 ]  print_address_description+0x87/0x3b0\n[   35.966420 ]  kasan_report+0x172/0x1c0\n[   35.966725 ]  ? peak_pci_remove+0x16f/0x270 [peak_pci]\n[   35.967137 ]  ? trace_irq_enable_rcuidle+0x10/0x170\n[   35.967529 ]  ? peak_pci_remove+0x16f/0x270 [peak_pci]\n[   35.967945 ]  __asan_report_load8_noabort+0x14/0x20\n[   35.968346 ]  peak_pci_remove+0x16f/0x270 [peak_pci]\n[   35.968752 ]  pci_device_remove+0xa9/0x250",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0e5afdc2315b0737edcf55bede4ee1640d2d464d"
          },
          {
            "url": "https://git.kernel.org/stable/c/1248582e47a9f7ce0ecd156c39fc61f8b6aa3699"
          },
          {
            "url": "https://git.kernel.org/stable/c/1c616528ba4aeb1125a06b407572ab7b56acae38"
          },
          {
            "url": "https://git.kernel.org/stable/c/28f28e4bc3a5e0051faa963f10b778ab38c1db69"
          },
          {
            "url": "https://git.kernel.org/stable/c/34914971bb3244db4ce2be44e9438a9b30c56250"
          },
          {
            "url": "https://git.kernel.org/stable/c/447d44cd2f67a20b596ede3ca3cd67086dfd9ca9"
          },
          {
            "url": "https://git.kernel.org/stable/c/949fe9b35570361bc6ee2652f89a0561b26eec98"
          },
          {
            "url": "https://git.kernel.org/stable/c/adbda14730aacce41c0d3596415aa39ad63eafd9"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47457",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:10.710",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ncan: isotp: isotp_sendmsg(): add result check for wait_event_interruptible()\nUsing wait_event_interruptible() to wait for complete transmission,\nbut do not check the result of wait_event_interruptible() which can be\ninterrupted. It will result in TX buffer has multiple accessors and\nthe later process interferes with the previous process.\nFollowing is one of the problems reported by syzbot.\n=============================================================\nWARNING: CPU: 0 PID: 0 at net/can/isotp.c:840 isotp_tx_timer_handler+0x2e0/0x4c0\nCPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.13.0-rc7+ #68\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1 04/01/2014\nRIP: 0010:isotp_tx_timer_handler+0x2e0/0x4c0\nCall Trace:\n <IRQ>\n ? isotp_setsockopt+0x390/0x390\n __hrtimer_run_queues+0xb8/0x610\n hrtimer_run_softirq+0x91/0xd0\n ? rcu_read_lock_sched_held+0x4d/0x80\n __do_softirq+0xe8/0x553\n irq_exit_rcu+0xf8/0x100\n sysvec_apic_timer_interrupt+0x9e/0xc0\n </IRQ>\n asm_sysvec_apic_timer_interrupt+0x12/0x20\nAdd result check for wait_event_interruptible() in isotp_sendmsg()\nto avoid multiple accessers for tx buffer.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/053bc12df0d6097c1126d0e14fa778a0a8faeb64"
          },
          {
            "url": "https://git.kernel.org/stable/c/9acf636215a6ce9362fe618e7da4913b8bfe84c8"
          },
          {
            "url": "https://git.kernel.org/stable/c/a76abedd2be3926d6deba236a935c7f98abf9110"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47458",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:10.780",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nocfs2: mount fails with buffer overflow in strlen\nStarting with kernel 5.11 built with CONFIG_FORTIFY_SOURCE mouting an\nocfs2 filesystem with either o2cb or pcmk cluster stack fails with the\ntrace below.  Problem seems to be that strings for cluster stack and\ncluster name are not guaranteed to be null terminated in the disk\nrepresentation, while strlcpy assumes that the source string is always\nnull terminated.  This causes a read outside of the source string\ntriggering the buffer overflow detection.\n  detected buffer overflow in strlen\n  ------------[ cut here ]------------\n  kernel BUG at lib/string.c:1149!\n  invalid opcode: 0000 [#1] SMP PTI\n  CPU: 1 PID: 910 Comm: mount.ocfs2 Not tainted 5.14.0-1-amd64 #1\n    Debian 5.14.6-2\n  RIP: 0010:fortify_panic+0xf/0x11\n  ...\n  Call Trace:\n   ocfs2_initialize_super.isra.0.cold+0xc/0x18 [ocfs2]\n   ocfs2_fill_super+0x359/0x19b0 [ocfs2]\n   mount_bdev+0x185/0x1b0\n   legacy_get_tree+0x27/0x40\n   vfs_get_tree+0x25/0xb0\n   path_mount+0x454/0xa20\n   __x64_sys_mount+0x103/0x140\n   do_syscall_64+0x3b/0xc0\n   entry_SYSCALL_64_after_hwframe+0x44/0xae",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0e677ea5b7396f715a76b6b0ef441430e4c4b57f"
          },
          {
            "url": "https://git.kernel.org/stable/c/232ed9752510de4436468b653d145565669c8498"
          },
          {
            "url": "https://git.kernel.org/stable/c/4b74ddcc22ee6455946e80a9c4808801f8f8561e"
          },
          {
            "url": "https://git.kernel.org/stable/c/7623b1035ca2d17bde0f6a086ad6844a34648df1"
          },
          {
            "url": "https://git.kernel.org/stable/c/93be0eeea14cf39235e585c8f56df3b3859deaad"
          },
          {
            "url": "https://git.kernel.org/stable/c/ac011cb3ff7a76b3e0e6e77158ee4ba2f929e1fb"
          },
          {
            "url": "https://git.kernel.org/stable/c/b15fa9224e6e1239414525d8d556d824701849fc"
          },
          {
            "url": "https://git.kernel.org/stable/c/d3a83576378b4c904f711598dde2c5e881c4295c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47459",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:10.863",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ncan: j1939: j1939_netdev_start(): fix UAF for rx_kref of j1939_priv\nIt will trigger UAF for rx_kref of j1939_priv as following.\n        cpu0                                    cpu1\nj1939_sk_bind(socket0, ndev0, ...)\nj1939_netdev_start\n                                        j1939_sk_bind(socket1, ndev0, ...)\n                                        j1939_netdev_start\nj1939_priv_set\n                                        j1939_priv_get_by_ndev_locked\nj1939_jsk_add\n.....\nj1939_netdev_stop\nkref_put_lock(&priv->rx_kref, ...)\n                                        kref_get(&priv->rx_kref, ...)\n                                        REFCOUNT_WARN(\"addition on 0;...\")\n====================================================\nrefcount_t: addition on 0; use-after-free.\nWARNING: CPU: 1 PID: 20874 at lib/refcount.c:25 refcount_warn_saturate+0x169/0x1e0\nRIP: 0010:refcount_warn_saturate+0x169/0x1e0\nCall Trace:\n j1939_netdev_start+0x68b/0x920\n j1939_sk_bind+0x426/0xeb0\n ? security_socket_bind+0x83/0xb0\nThe rx_kref's kref_get() and kref_put() should use j1939_netdev_lock to\nprotect.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/6e8811707e2df0c6ba920f0cad3a3bca7b42132f"
          },
          {
            "url": "https://git.kernel.org/stable/c/864e77771a24c877aaf53aee019f78619cbcd668"
          },
          {
            "url": "https://git.kernel.org/stable/c/a0e47d2833b4f65e6c799f28c6b636d36b8b936d"
          },
          {
            "url": "https://git.kernel.org/stable/c/d9d52a3ebd284882f5562c88e55991add5d01586"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47460",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:10.940",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nocfs2: fix data corruption after conversion from inline format\nCommit 6dbf7bb55598 (\"fs: Don't invalidate page buffers in\nblock_write_full_page()\") uncovered a latent bug in ocfs2 conversion\nfrom inline inode format to a normal inode format.\nThe code in ocfs2_convert_inline_data_to_extents() attempts to zero out\nthe whole cluster allocated for file data by grabbing, zeroing, and\ndirtying all pages covering this cluster.  However these pages are\nbeyond i_size, thus writeback code generally ignores these dirty pages\nand no blocks were ever actually zeroed on the disk.\nThis oversight was fixed by commit 693c241a5f6a (\"ocfs2: No need to zero\npages past i_size.\") for standard ocfs2 write path, inline conversion\npath was apparently forgotten; the commit log also has a reasoning why\nthe zeroing actually is not needed.\nAfter commit 6dbf7bb55598, things became worse as writeback code stopped\ninvalidating buffers on pages beyond i_size and thus these pages end up\nwith clean PageDirty bit but with buffers attached to these pages being\nstill dirty.  So when a file is converted from inline format, then\nwriteback triggers, and then the file is grown so that these pages\nbecome valid, the invalid dirtiness state is preserved,\nmark_buffer_dirty() does nothing on these pages (buffers are already\ndirty) but page is never written back because it is clean.  So data\nwritten to these pages is lost once pages are reclaimed.\nSimple reproducer for the problem is:\n  xfs_io -f -c \"pwrite 0 2000\" -c \"pwrite 2000 2000\" -c \"fsync\" \\\n    -c \"pwrite 4000 2000\" ocfs2_file\nAfter unmounting and mounting the fs again, you can observe that end of\n'ocfs2_file' has lost its contents.\nFix the problem by not doing the pointless zeroing during conversion\nfrom inline format similarly as in the standard write path.\n[akpm@linux-foundation.org: fix whitespace, per Joseph]",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/5314454ea3ff6fc746eaf71b9a7ceebed52888fa"
          },
          {
            "url": "https://git.kernel.org/stable/c/560edd14de2bf9dbc0129681eeb4d5ef87cc105f"
          },
          {
            "url": "https://git.kernel.org/stable/c/8e6bfb4f70168ddfd32fb6dc028ad52faaf1f32e"
          },
          {
            "url": "https://git.kernel.org/stable/c/a3a089c241cd49b33a8cdd7fcb37cc87a086912a"
          },
          {
            "url": "https://git.kernel.org/stable/c/b05caf023b14cbed9223bb5b48ecc7bffe38f632"
          },
          {
            "url": "https://git.kernel.org/stable/c/f1b98569e81c37d7e0deada7172f8f60860c1360"
          },
          {
            "url": "https://git.kernel.org/stable/c/fa9b6b6c953e3f6441ed6cf83b4c771dac2dae08"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47461",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:11.040",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nuserfaultfd: fix a race between writeprotect and exit_mmap()\nA race is possible when a process exits, its VMAs are removed by\nexit_mmap() and at the same time userfaultfd_writeprotect() is called.\nThe race was detected by KASAN on a development kernel, but it appears\nto be possible on vanilla kernels as well.\nUse mmget_not_zero() to prevent the race as done in other userfaultfd\noperations.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/149958ecd0627a9f1e9c678c25c665400054cd6a"
          },
          {
            "url": "https://git.kernel.org/stable/c/3cda4bfffd4f755645577aaa9e96a606657b4525"
          },
          {
            "url": "https://git.kernel.org/stable/c/cb185d5f1ebf900f4ae3bf84cee212e6dd035aca"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47462",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:11.117",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmm/mempolicy: do not allow illegal MPOL_F_NUMA_BALANCING | MPOL_LOCAL in mbind()\nsyzbot reported access to unitialized memory in mbind() [1]\nIssue came with commit bda420b98505 (\"numa balancing: migrate on fault\namong multiple bound nodes\")\nThis commit added a new bit in MPOL_MODE_FLAGS, but only checked valid\ncombination (MPOL_F_NUMA_BALANCING can only be used with MPOL_BIND) in\ndo_set_mempolicy()\nThis patch moves the check in sanitize_mpol_flags() so that it is also\nused by mbind()\n  [1]\n  BUG: KMSAN: uninit-value in __mpol_equal+0x567/0x590 mm/mempolicy.c:2260\n   __mpol_equal+0x567/0x590 mm/mempolicy.c:2260\n   mpol_equal include/linux/mempolicy.h:105 [inline]\n   vma_merge+0x4a1/0x1e60 mm/mmap.c:1190\n   mbind_range+0xcc8/0x1e80 mm/mempolicy.c:811\n   do_mbind+0xf42/0x15f0 mm/mempolicy.c:1333\n   kernel_mbind mm/mempolicy.c:1483 [inline]\n   __do_sys_mbind mm/mempolicy.c:1490 [inline]\n   __se_sys_mbind+0x437/0xb80 mm/mempolicy.c:1486\n   __x64_sys_mbind+0x19d/0x200 mm/mempolicy.c:1486\n   do_syscall_x64 arch/x86/entry/common.c:51 [inline]\n   do_syscall_64+0x54/0xd0 arch/x86/entry/common.c:82\n   entry_SYSCALL_64_after_hwframe+0x44/0xae\n  Uninit was created at:\n   slab_alloc_node mm/slub.c:3221 [inline]\n   slab_alloc mm/slub.c:3230 [inline]\n   kmem_cache_alloc+0x751/0xff0 mm/slub.c:3235\n   mpol_new mm/mempolicy.c:293 [inline]\n   do_mbind+0x912/0x15f0 mm/mempolicy.c:1289\n   kernel_mbind mm/mempolicy.c:1483 [inline]\n   __do_sys_mbind mm/mempolicy.c:1490 [inline]\n   __se_sys_mbind+0x437/0xb80 mm/mempolicy.c:1486\n   __x64_sys_mbind+0x19d/0x200 mm/mempolicy.c:1486\n   do_syscall_x64 arch/x86/entry/common.c:51 [inline]\n   do_syscall_64+0x54/0xd0 arch/x86/entry/common.c:82\n   entry_SYSCALL_64_after_hwframe+0x44/0xae\n  =====================================================\n  Kernel panic - not syncing: panic_on_kmsan set ...\n  CPU: 0 PID: 15049 Comm: syz-executor.0 Tainted: G    B             5.15.0-rc2-syzkaller #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\n  Call Trace:\n   __dump_stack lib/dump_stack.c:88 [inline]\n   dump_stack_lvl+0x1ff/0x28e lib/dump_stack.c:106\n   dump_stack+0x25/0x28 lib/dump_stack.c:113\n   panic+0x44f/0xdeb kernel/panic.c:232\n   kmsan_report+0x2ee/0x300 mm/kmsan/report.c:186\n   __msan_warning+0xd7/0x150 mm/kmsan/instrumentation.c:208\n   __mpol_equal+0x567/0x590 mm/mempolicy.c:2260\n   mpol_equal include/linux/mempolicy.h:105 [inline]\n   vma_merge+0x4a1/0x1e60 mm/mmap.c:1190\n   mbind_range+0xcc8/0x1e80 mm/mempolicy.c:811\n   do_mbind+0xf42/0x15f0 mm/mempolicy.c:1333\n   kernel_mbind mm/mempolicy.c:1483 [inline]\n   __do_sys_mbind mm/mempolicy.c:1490 [inline]\n   __se_sys_mbind+0x437/0xb80 mm/mempolicy.c:1486\n   __x64_sys_mbind+0x19d/0x200 mm/mempolicy.c:1486\n   do_syscall_x64 arch/x86/entry/common.c:51 [inline]\n   do_syscall_64+0x54/0xd0 arch/x86/entry/common.c:82\n   entry_SYSCALL_64_after_hwframe+0x44/0xae",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/6d2aec9e123bb9c49cb5c7fc654f25f81e688e8c"
          },
          {
            "url": "https://git.kernel.org/stable/c/9ee4e9ae98f1f262d6fae0d266cfdf3ba2c321d9"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47463",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:11.193",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmm/secretmem: fix NULL page->mapping dereference in page_is_secretmem()\nCheck for a NULL page->mapping before dereferencing the mapping in\npage_is_secretmem(), as the page's mapping can be nullified while gup()\nis running, e.g.  by reclaim or truncation.\n  BUG: kernel NULL pointer dereference, address: 0000000000000068\n  #PF: supervisor read access in kernel mode\n  #PF: error_code(0x0000) - not-present page\n  PGD 0 P4D 0\n  Oops: 0000 [#1] PREEMPT SMP NOPTI\n  CPU: 6 PID: 4173897 Comm: CPU 3/KVM Tainted: G        W\n  RIP: 0010:internal_get_user_pages_fast+0x621/0x9d0\n  Code: <48> 81 7a 68 80 08 04 bc 0f 85 21 ff ff 8 89 c7 be\n  RSP: 0018:ffffaa90087679b0 EFLAGS: 00010046\n  RAX: ffffe3f37905b900 RBX: 00007f2dd561e000 RCX: ffffe3f37905b934\n  RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffe3f37905b900\n  ...\n  CR2: 0000000000000068 CR3: 00000004c5898003 CR4: 00000000001726e0\n  Call Trace:\n   get_user_pages_fast_only+0x13/0x20\n   hva_to_pfn+0xa9/0x3e0\n   try_async_pf+0xa1/0x270\n   direct_page_fault+0x113/0xad0\n   kvm_mmu_page_fault+0x69/0x680\n   vmx_handle_exit+0xe1/0x5d0\n   kvm_arch_vcpu_ioctl_run+0xd81/0x1c70\n   kvm_vcpu_ioctl+0x267/0x670\n   __x64_sys_ioctl+0x83/0xa0\n   do_syscall_64+0x56/0x80\n   entry_SYSCALL_64_after_hwframe+0x44/0xae",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/79f9bc5843142b649575f887dccdf1c07ad75c20"
          },
          {
            "url": "https://git.kernel.org/stable/c/b77ba1e02345bafd703f0d407bdbd88c3be1f767"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47464",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:11.287",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\naudit: fix possible null-pointer dereference in audit_filter_rules\nFix  possible null-pointer dereference in audit_filter_rules.\naudit_filter_rules() error: we previously assumed 'ctx' could be null",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/16802fa4c33eb1a8efb23f1e93365190e4047d05"
          },
          {
            "url": "https://git.kernel.org/stable/c/4e9e46a700201b4c85081fd478c99c692a9aaa0d"
          },
          {
            "url": "https://git.kernel.org/stable/c/6e3ee990c90494561921c756481d0e2125d8b895"
          },
          {
            "url": "https://git.kernel.org/stable/c/d6f451f1f60c58d73038c7c3177066f8f084e2a2"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47465",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:11.367",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nKVM: PPC: Book3S HV: Fix stack handling in idle_kvm_start_guest()\nIn commit 10d91611f426 (\"powerpc/64s: Reimplement book3s idle code in\nC\") kvm_start_guest() became idle_kvm_start_guest(). The old code\nallocated a stack frame on the emergency stack, but didn't use the\nframe to store anything, and also didn't store anything in its caller's\nframe.\nidle_kvm_start_guest() on the other hand is written more like a normal C\nfunction, it creates a frame on entry, and also stores CR/LR into its\ncallers frame (per the ABI). The problem is that there is no caller\nframe on the emergency stack.\nThe emergency stack for a given CPU is allocated with:\n  paca_ptrs[i]->emergency_sp = alloc_stack(limit, i) + THREAD_SIZE;\nSo emergency_sp actually points to the first address above the emergency\nstack allocation for a given CPU, we must not store above it without\nfirst decrementing it to create a frame. This is different to the\nregular kernel stack, paca->kstack, which is initialised to point at an\ninitial frame that is ready to use.\nidle_kvm_start_guest() stores the backchain, CR and LR all of which\nwrite outside the allocation for the emergency stack. It then creates a\nstack frame and saves the non-volatile registers. Unfortunately the\nframe it creates is not large enough to fit the non-volatiles, and so\nthe saving of the non-volatile registers also writes outside the\nemergency stack allocation.\nThe end result is that we corrupt whatever is at 0-24 bytes, and 112-248\nbytes above the emergency stack allocation.\nIn practice this has gone unnoticed because the memory immediately above\nthe emergency stack happens to be used for other stack allocations,\neither another CPUs mc_emergency_sp or an IRQ stack. See the order of\ncalls to irqstack_early_init() and emergency_stack_init().\nThe low addresses of another stack are the top of that stack, and so are\nonly used if that stack is under extreme pressue, which essentially\nnever happens in practice - and if it did there's a high likelyhood we'd\ncrash due to that stack overflowing.\nStill, we shouldn't be corrupting someone else's stack, and it is purely\nluck that we aren't corrupting something else.\nTo fix it we save CR/LR into the caller's frame using the existing r1 on\nentry, we then create a SWITCH_FRAME_SIZE frame (which has space for\npt_regs) on the emergency stack with the backchain pointing to the\nexisting stack, and then finally we switch to the new frame on the\nemergency stack.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/6d077c37c4643394b1bae9682da48164fc147ea8"
          },
          {
            "url": "https://git.kernel.org/stable/c/80bbb0bc3a0288442f7fe6fc514f4ee1cb06ccb7"
          },
          {
            "url": "https://git.kernel.org/stable/c/9b4416c5095c20e110c82ae602c254099b83b72f"
          },
          {
            "url": "https://git.kernel.org/stable/c/fbd724c49bead048ae9fc1a5b7bff2fb3e54f855"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47466",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:11.450",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmm, slub: fix potential memoryleak in kmem_cache_open()\nIn error path, the random_seq of slub cache might be leaked.  Fix this\nby using __kmem_cache_release() to release all the relevant resources.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/42b81946e3ac9ea0372ba16e05160dc11e02694f"
          },
          {
            "url": "https://git.kernel.org/stable/c/4f5d1c29cfab5cb0ab885059818751bdef32e2bb"
          },
          {
            "url": "https://git.kernel.org/stable/c/568f906340b43120abd6fcc67c37396482f85930"
          },
          {
            "url": "https://git.kernel.org/stable/c/9037c57681d25e4dcc442d940d6dbe24dd31f461"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47467",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:11.533",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nkunit: fix reference count leak in kfree_at_end\nThe reference counting issue happens in the normal path of\nkfree_at_end(). When kunit_alloc_and_get_resource() is invoked, the\nfunction forgets to handle the returned resource object, whose refcount\nincreased inside, causing a refcount leak.\nFix this issue by calling kunit_alloc_resource() instead of\nkunit_alloc_and_get_resource().\nFixed the following when applying:\nShuah Khan <skhan@linuxfoundation.org>\nCHECK: Alignment should match open parenthesis\n+\tkunit_alloc_resource(test, NULL, kfree_res_free, GFP_KERNEL,\n \t\t\t\t     (void *)to_free);",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/bbdd158b40b66a9403391a517f24ef6613573446"
          },
          {
            "url": "https://git.kernel.org/stable/c/f62314b1ced25c58b86e044fc951cd6a1ea234cf"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47468",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:11.603",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nisdn: mISDN: Fix sleeping function called from invalid context\nThe driver can call card->isac.release() function from an atomic\ncontext.\nFix this by calling this function after releasing the lock.\nThe following log reveals it:\n[   44.168226 ] BUG: sleeping function called from invalid context at kernel/workqueue.c:3018\n[   44.168941 ] in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 5475, name: modprobe\n[   44.169574 ] INFO: lockdep is turned off.\n[   44.169899 ] irq event stamp: 0\n[   44.170160 ] hardirqs last  enabled at (0): [<0000000000000000>] 0x0\n[   44.170627 ] hardirqs last disabled at (0): [<ffffffff814209ed>] copy_process+0x132d/0x3e00\n[   44.171240 ] softirqs last  enabled at (0): [<ffffffff81420a1a>] copy_process+0x135a/0x3e00\n[   44.171852 ] softirqs last disabled at (0): [<0000000000000000>] 0x0\n[   44.172318 ] Preemption disabled at:\n[   44.172320 ] [<ffffffffa009b0a9>] nj_release+0x69/0x500 [netjet]\n[   44.174441 ] Call Trace:\n[   44.174630 ]  dump_stack_lvl+0xa8/0xd1\n[   44.174912 ]  dump_stack+0x15/0x17\n[   44.175166 ]  ___might_sleep+0x3a2/0x510\n[   44.175459 ]  ? nj_release+0x69/0x500 [netjet]\n[   44.175791 ]  __might_sleep+0x82/0xe0\n[   44.176063 ]  ? start_flush_work+0x20/0x7b0\n[   44.176375 ]  start_flush_work+0x33/0x7b0\n[   44.176672 ]  ? trace_irq_enable_rcuidle+0x85/0x170\n[   44.177034 ]  ? kasan_quarantine_put+0xaa/0x1f0\n[   44.177372 ]  ? kasan_quarantine_put+0xaa/0x1f0\n[   44.177711 ]  __flush_work+0x11a/0x1a0\n[   44.177991 ]  ? flush_work+0x20/0x20\n[   44.178257 ]  ? lock_release+0x13c/0x8f0\n[   44.178550 ]  ? __kasan_check_write+0x14/0x20\n[   44.178872 ]  ? do_raw_spin_lock+0x148/0x360\n[   44.179187 ]  ? read_lock_is_recursive+0x20/0x20\n[   44.179530 ]  ? __kasan_check_read+0x11/0x20\n[   44.179846 ]  ? do_raw_spin_unlock+0x55/0x900\n[   44.180168 ]  ? ____kasan_slab_free+0x116/0x140\n[   44.180505 ]  ? _raw_spin_unlock_irqrestore+0x41/0x60\n[   44.180878 ]  ? skb_queue_purge+0x1a3/0x1c0\n[   44.181189 ]  ? kfree+0x13e/0x290\n[   44.181438 ]  flush_work+0x17/0x20\n[   44.181695 ]  mISDN_freedchannel+0xe8/0x100\n[   44.182006 ]  isac_release+0x210/0x260 [mISDNipac]\n[   44.182366 ]  nj_release+0xf6/0x500 [netjet]\n[   44.182685 ]  nj_remove+0x48/0x70 [netjet]\n[   44.182989 ]  pci_device_remove+0xa9/0x250",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/37e4f57b22cc5ebb3f80cf0f74fdeb487f082367"
          },
          {
            "url": "https://git.kernel.org/stable/c/4054b869dc263228d30a4755800b78f0f2ba0c89"
          },
          {
            "url": "https://git.kernel.org/stable/c/6510e80a0b81b5d814e3aea6297ba42f5e76f73c"
          },
          {
            "url": "https://git.kernel.org/stable/c/6f95c97e0f9d6eb39c3f2cb45e8fa4268d1b372b"
          },
          {
            "url": "https://git.kernel.org/stable/c/9f591cbdbed3d7822b2bdba89b34a6d7b434317d"
          },
          {
            "url": "https://git.kernel.org/stable/c/a5b34409d3fc52114c828be4adbc30744fa3258b"
          },
          {
            "url": "https://git.kernel.org/stable/c/ef269a8808cb1759245a98a7fe16fceaebad894c"
          },
          {
            "url": "https://git.kernel.org/stable/c/f5966ba53013149bcf94e1536644a958dd00a026"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47469",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:11.690",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nspi: Fix deadlock when adding SPI controllers on SPI buses\nCurrently we have a global spi_add_lock which we take when adding new\ndevices so that we can check that we're not trying to reuse a chip\nselect that's already controlled.  This means that if the SPI device is\nitself a SPI controller and triggers the instantiation of further SPI\ndevices we trigger a deadlock as we try to register and instantiate\nthose devices while in the process of doing so for the parent controller\nand hence already holding the global spi_add_lock.  Since we only care\nabout concurrency within a single SPI bus move the lock to be per\ncontroller, avoiding the deadlock.\nThis can be easily triggered in the case of spi-mux.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/6098475d4cb48d821bdf453c61118c56e26294f0"
          },
          {
            "url": "https://git.kernel.org/stable/c/722ef19a161ce3fffb3d1b01ce2301c306639bdd"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47470",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:11.763",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmm, slub: fix potential use-after-free in slab_debugfs_fops\nWhen sysfs_slab_add failed, we shouldn't call debugfs_slab_add() for s\nbecause s will be freed soon.  And slab_debugfs_fops will use s later\nleading to a use-after-free.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/159d8cfbd0428d487c53be4722f33cdab0d25d83"
          },
          {
            "url": "https://git.kernel.org/stable/c/67823a544414def2a36c212abadb55b23bcda00c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47471",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:11.847",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm: mxsfb: Fix NULL pointer dereference crash on unload\nThe mxsfb->crtc.funcs may already be NULL when unloading the driver,\nin which case calling mxsfb_irq_disable() via drm_irq_uninstall() from\nmxsfb_unload() leads to NULL pointer dereference.\nSince all we care about is masking the IRQ and mxsfb->base is still\nvalid, just use that to clear and mask the IRQ.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3cfc183052c3dbf8eae57b6c1685dab00ed3db4a"
          },
          {
            "url": "https://git.kernel.org/stable/c/b0e6db0656ddfd8bb57303c2ef61ee1c1cc694a8"
          },
          {
            "url": "https://git.kernel.org/stable/c/f40c2281d2c0674d32ba732fee45222d76495472"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47472",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:11.927",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: mdiobus: Fix memory leak in __mdiobus_register\nOnce device_register() failed, we should call put_device() to\ndecrement reference count for cleanup. Or it will cause memory\nleak.\nBUG: memory leak\nunreferenced object 0xffff888114032e00 (size 256):\n  comm \"kworker/1:3\", pid 2960, jiffies 4294943572 (age 15.920s)\n  hex dump (first 32 bytes):\n    00 00 00 00 00 00 00 00 08 2e 03 14 81 88 ff ff  ................\n    08 2e 03 14 81 88 ff ff 90 76 65 82 ff ff ff ff  .........ve.....\n  backtrace:\n    [<ffffffff8265cfab>] kmalloc include/linux/slab.h:591 [inline]\n    [<ffffffff8265cfab>] kzalloc include/linux/slab.h:721 [inline]\n    [<ffffffff8265cfab>] device_private_init drivers/base/core.c:3203 [inline]\n    [<ffffffff8265cfab>] device_add+0x89b/0xdf0 drivers/base/core.c:3253\n    [<ffffffff828dd643>] __mdiobus_register+0xc3/0x450 drivers/net/phy/mdio_bus.c:537\n    [<ffffffff828cb835>] __devm_mdiobus_register+0x75/0xf0 drivers/net/phy/mdio_devres.c:87\n    [<ffffffff82b92a00>] ax88772_init_mdio drivers/net/usb/asix_devices.c:676 [inline]\n    [<ffffffff82b92a00>] ax88772_bind+0x330/0x480 drivers/net/usb/asix_devices.c:786\n    [<ffffffff82baa33f>] usbnet_probe+0x3ff/0xdf0 drivers/net/usb/usbnet.c:1745\n    [<ffffffff82c36e17>] usb_probe_interface+0x177/0x370 drivers/usb/core/driver.c:396\n    [<ffffffff82661d17>] call_driver_probe drivers/base/dd.c:517 [inline]\n    [<ffffffff82661d17>] really_probe.part.0+0xe7/0x380 drivers/base/dd.c:596\n    [<ffffffff826620bc>] really_probe drivers/base/dd.c:558 [inline]\n    [<ffffffff826620bc>] __driver_probe_device+0x10c/0x1e0 drivers/base/dd.c:751\n    [<ffffffff826621ba>] driver_probe_device+0x2a/0x120 drivers/base/dd.c:781\n    [<ffffffff82662a26>] __device_attach_driver+0xf6/0x140 drivers/base/dd.c:898\n    [<ffffffff8265eca7>] bus_for_each_drv+0xb7/0x100 drivers/base/bus.c:427\n    [<ffffffff826625a2>] __device_attach+0x122/0x260 drivers/base/dd.c:969\n    [<ffffffff82660916>] bus_probe_device+0xc6/0xe0 drivers/base/bus.c:487\n    [<ffffffff8265cd0b>] device_add+0x5fb/0xdf0 drivers/base/core.c:3359\n    [<ffffffff82c343b9>] usb_set_configuration+0x9d9/0xb90 drivers/usb/core/message.c:2170\n    [<ffffffff82c4473c>] usb_generic_driver_probe+0x8c/0xc0 drivers/usb/core/generic.c:238\nBUG: memory leak\nunreferenced object 0xffff888116f06900 (size 32):\n  comm \"kworker/0:2\", pid 2670, jiffies 4294944448 (age 7.160s)\n  hex dump (first 32 bytes):\n    75 73 62 2d 30 30 31 3a 30 30 33 00 00 00 00 00  usb-001:003.....\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n  backtrace:\n    [<ffffffff81484516>] kstrdup+0x36/0x70 mm/util.c:60\n    [<ffffffff814845a3>] kstrdup_const+0x53/0x80 mm/util.c:83\n    [<ffffffff82296ba2>] kvasprintf_const+0xc2/0x110 lib/kasprintf.c:48\n    [<ffffffff82358d4b>] kobject_set_name_vargs+0x3b/0xe0 lib/kobject.c:289\n    [<ffffffff826575f3>] dev_set_name+0x63/0x90 drivers/base/core.c:3147\n    [<ffffffff828dd63b>] __mdiobus_register+0xbb/0x450 drivers/net/phy/mdio_bus.c:535\n    [<ffffffff828cb835>] __devm_mdiobus_register+0x75/0xf0 drivers/net/phy/mdio_devres.c:87\n    [<ffffffff82b92a00>] ax88772_init_mdio drivers/net/usb/asix_devices.c:676 [inline]\n    [<ffffffff82b92a00>] ax88772_bind+0x330/0x480 drivers/net/usb/asix_devices.c:786\n    [<ffffffff82baa33f>] usbnet_probe+0x3ff/0xdf0 drivers/net/usb/usbnet.c:1745\n    [<ffffffff82c36e17>] usb_probe_interface+0x177/0x370 drivers/usb/core/driver.c:396\n    [<ffffffff82661d17>] call_driver_probe drivers/base/dd.c:517 [inline]\n    [<ffffffff82661d17>] really_probe.part.0+0xe7/0x380 drivers/base/dd.c:596\n    [<ffffffff826620bc>] really_probe drivers/base/dd.c:558 [inline]\n    [<ffffffff826620bc>] __driver_probe_device+0x10c/0x1e0 drivers/base/dd.c:751\n    [<ffffffff826621ba>] driver_probe_device+0x2a/0x120 drivers/base/dd.c:781\n    [<ffffffff82662a26>] __device_attach_driver+0xf6/0x140 drivers/base/dd.c:898\n    [<ffffffff8265eca7>] bus_for_each\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0c4e87ba11eb331dca2315d484d08441b8c13193"
          },
          {
            "url": "https://git.kernel.org/stable/c/2bc10dca9432fadb09e45127e258fc7127fd346d"
          },
          {
            "url": "https://git.kernel.org/stable/c/3a0dc2e35a5d6546b1db87fe985582dadc64fe7b"
          },
          {
            "url": "https://git.kernel.org/stable/c/4ec0f9abc512cc02fb04daa89ccf6697e80ab417"
          },
          {
            "url": "https://git.kernel.org/stable/c/6a18d155d5b35ad50c8fac2be091212487ae58ec"
          },
          {
            "url": "https://git.kernel.org/stable/c/8121d0d4fd108280f5cd7b7fe8c6592adaa37be9"
          },
          {
            "url": "https://git.kernel.org/stable/c/8ba94a7f7b9fc2a2b808ccceb99b77135deae21a"
          },
          {
            "url": "https://git.kernel.org/stable/c/a9831afa2dc8a18205403907c41aa4e0950ac611"
          },
          {
            "url": "https://git.kernel.org/stable/c/ab609f25d19858513919369ff3d9a63c02cd9e2e"
          },
          {
            "url": "https://git.kernel.org/stable/c/b0feaa8376f52357bf2fd020d0c471713a859728"
          },
          {
            "url": "https://git.kernel.org/stable/c/b89f4537d7fdbd0bafb6d8a66a484e0bc99871a4"
          },
          {
            "url": "https://git.kernel.org/stable/c/bc5f2f3431ced08300e4cb3aff35f1da14c26433"
          },
          {
            "url": "https://git.kernel.org/stable/c/c828115a14eacbf42042770fd68543f134e89efa"
          },
          {
            "url": "https://git.kernel.org/stable/c/fd2400dd4f1b8bd7a309b1b424d9e0d188151b01"
          },
          {
            "url": "https://git.kernel.org/stable/c/fdbffd95c4ce94d2197c504008eaac46b16bc5a4"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47473",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-05-22T07:15:12.027",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nscsi: qla2xxx: Fix a memory leak in an error path of qla2x00_process_els()\nCommit 8c0eb596baa5 (\"[SCSI] qla2xxx: Fix a memory leak in an error path of\nqla2x00_process_els()\"), intended to change:\n        bsg_job->request->msgcode == FC_BSG_HST_ELS_NOLOGIN\n        bsg_job->request->msgcode != FC_BSG_RPT_ELS\nbut changed it to:\n        bsg_job->request->msgcode == FC_BSG_RPT_ELS\ninstead.\nChange the == to a != to avoid leaking the fcport structure or freeing\nunallocated memory.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/7fb223d0ad801f633c78cbe42b1d1b55f5d163ad"
          },
          {
            "url": "https://git.kernel.org/stable/c/96f0aebf29be25254fa585af43924e34aa21fd9a"
          },
          {
            "url": "https://git.kernel.org/stable/c/a7fbb56e6c941d9f59437b96412a348e66388d3e"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-1446",
        "sourceIdentifier": "security@wordfence.com",
        "published": "2024-05-22T07:15:12.147",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": 5.4,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 2.8,
        "impactScore": 2.5,
        "description": "The NextScripts: Social Networks Auto-Poster plugin for WordPress is vulnerable to Cross-Site Request Forgery in all versions up to, and including, 4.4.3. This is due to missing or incorrect nonce validation on the nxssnap-reposter page. This makes it possible for unauthenticated attackers to delete arbitrary posts or pages via a forged request granted they can trick a site administrator into performing an action such as clicking on a link.",
        "cweIds": null,
        "references": [
          {
            "url": "https://plugins.trac.wordpress.org/changeset?sfp_email=&sfph_mail=&reponame=&new=3084635%40social-networks-auto-poster-facebook-twitter-g%2Ftrunk&old=3004433%40social-networks-auto-poster-facebook-twitter-g%2Ftrunk&sfp_email=&sfph_mail=#file17"
          },
          {
            "url": "https://www.wordfence.com/threat-intel/vulnerabilities/id/306b23ee-7dcb-4281-a218-21168998c4b9?source=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-1762",
        "sourceIdentifier": "security@wordfence.com",
        "published": "2024-05-22T07:15:12.617",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": 6.1,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 2.8,
        "impactScore": 2.7,
        "description": "The NextScripts: Social Networks Auto-Poster plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the HTTP_USER_AGENT header in all versions up to, and including, 4.4.3 due to insufficient input sanitization and output escaping. This makes it possible for unauthenticated attackers to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page. This requires the victim to select view \"All Cron Events\" in order for the injection to fire.",
        "cweIds": null,
        "references": [
          {
            "url": "https://plugins.trac.wordpress.org/browser/social-networks-auto-poster-facebook-twitter-g/trunk/NextScripts_SNAP.php#L74"
          },
          {
            "url": "https://plugins.trac.wordpress.org/browser/social-networks-auto-poster-facebook-twitter-g/trunk/inc/nxs_functions_engine.php#L117"
          },
          {
            "url": "https://plugins.trac.wordpress.org/browser/social-networks-auto-poster-facebook-twitter-g/trunk/inc/nxs_functions_engine.php#L125"
          },
          {
            "url": "https://plugins.trac.wordpress.org/changeset?sfp_email=&sfph_mail=&reponame=&new=3084635%40social-networks-auto-poster-facebook-twitter-g%2Ftrunk&old=3004433%40social-networks-auto-poster-facebook-twitter-g%2Ftrunk&sfp_email=&sfph_mail=#file17"
          },
          {
            "url": "https://www.wordfence.com/threat-intel/vulnerabilities/id/8063a545-4792-4ab7-b188-0e51a0fcfed4?source=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-2088",
        "sourceIdentifier": "security@wordfence.com",
        "published": "2024-05-22T07:15:12.907",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": 8.5,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 3.1,
        "impactScore": 4.7,
        "description": "The NextScripts: Social Networks Auto-Poster plugin for WordPress is vulnerable to Sensitive Information Exposure in all versions up to, and including, 4.4.3 via the 'nxs_getExpSettings' function. This makes it possible for authenticated attackers, with subscriber access and above, to extract sensitive data including social network API keys and secrets.",
        "cweIds": null,
        "references": [
          {
            "url": "https://plugins.trac.wordpress.org/browser/social-networks-auto-poster-facebook-twitter-g/trunk/inc/nxs_functions_wp.php#L620"
          },
          {
            "url": "https://plugins.trac.wordpress.org/changeset/3084635/social-networks-auto-poster-facebook-twitter-g/trunk/inc/nxs_functions_wp.php?contextall=1"
          },
          {
            "url": "https://www.wordfence.com/threat-intel/vulnerabilities/id/70724bc7-c1f4-4965-8bba-99b2ed21d34b?source=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-3198",
        "sourceIdentifier": "security@wordfence.com",
        "published": "2024-05-22T07:15:13.167",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": 6.4,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 3.1,
        "impactScore": 2.7,
        "description": "The WP Font Awesome Share Icons plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's \n'wpfai_social' shortcode in all versions up to, and including, 1.1.1 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.",
        "cweIds": null,
        "references": [
          {
            "url": "https://wordpress.org/plugins/wp-font-awesome-share-icons/"
          },
          {
            "url": "https://www.wordfence.com/threat-intel/vulnerabilities/id/cd066a04-8094-4004-8a64-317c6bd4e101?source=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-3663",
        "sourceIdentifier": "security@wordfence.com",
        "published": "2024-05-22T07:15:13.427",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": 4.3,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 2.8,
        "impactScore": 1.4,
        "description": "The WP Scraper plugin for WordPress is vulnerable to unauthorized access due to a missing capability check on the wp_scraper_multi_scrape_action() function in all versions up to, and including, 5.7. This makes it possible for authenticated attackers, with subscriber-level access and above, to create arbitrary pages and posts.",
        "cweIds": null,
        "references": [
          {
            "url": "https://plugins.trac.wordpress.org/browser/wp-scraper/trunk/wp-scraper.php#L1426"
          },
          {
            "url": "https://www.wordfence.com/threat-intel/vulnerabilities/id/1a4bc52d-5771-4e7b-a394-772f2a5edbd7?source=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-3927",
        "sourceIdentifier": "security@wordfence.com",
        "published": "2024-05-22T07:15:13.720",
        "lastModified": "2024-05-22T12:46:53.887",
        "baseScore": 5.3,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 3.9,
        "impactScore": 1.4,
        "description": "The Element Pack Elementor Addons (Header Footer, Template Library, Dynamic Grid & Carousel, Remote Arrows) plugin for WordPress is vulnerable to Form Submission Admin Email Bypass  in all versions up to, and including, 5.6.3. This is due to the plugin not properly checking for all variations of an administrators emails. This makes it possible for unauthenticated attackers to bypass the restriction using a +value when submitting the contact form.",
        "cweIds": null,
        "references": [
          {
            "url": "https://plugins.trac.wordpress.org/browser/bdthemes-element-pack-lite/trunk/modules/contact-form/module.php#L102"
          },
          {
            "url": "https://plugins.trac.wordpress.org/changeset/3089154"
          },
          {
            "url": "https://www.wordfence.com/threat-intel/vulnerabilities/id/3a703fc4-6c61-442e-a637-515e9f501575?source=cve"
          }
        ]
      }
    }
  ]
}