{
  "totalResults": 10,
  "datePublished": "2024-04-25T17:00:03.599879Z",
  "vulnerabilities": [
    {
      "cve": {
        "id": "CVE-2024-23527",
        "sourceIdentifier": "support@hackerone.com",
        "published": "2024-04-25T06:15:54.657",
        "lastModified": "2024-04-25T13:18:20.370",
        "baseScore": 5.3,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 3.9,
        "impactScore": 1.4,
        "description": "An out-of-bounds read vulnerability in WLAvalancheService component of Ivanti Avalanche before 6.4.3, in certain conditions can allow an unauthenticated remote attacker to read sensitive information in memory. ",
        "cweIds": null,
        "references": [
          {
            "url": "https://www.ivanti.com/blog/security-update-for-ivanti-avalanche"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26923",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-25T06:15:57.160",
        "lastModified": "2024-04-25T13:18:20.370",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\naf_unix: Fix garbage collector racing against connect()\nGarbage collector does not take into account the risk of embryo getting\nenqueued during the garbage collection. If such embryo has a peer that\ncarries SCM_RIGHTS, two consecutive passes of scan_children() may see a\ndifferent set of children. Leading to an incorrectly elevated inflight\ncount, and then a dangling pointer within the gc_inflight_list.\nsockets are AF_UNIX/SOCK_STREAM\nS is an unconnected socket\nL is a listening in-flight socket bound to addr, not in fdtable\nV's fd will be passed via sendmsg(), gets inflight count bumped\nconnect(S, addr)\tsendmsg(S, [V]); close(V)\t__unix_gc()\n----------------\t-------------------------\t-----------\nNS = unix_create1()\nskb1 = sock_wmalloc(NS)\nL = unix_find_other(addr)\nunix_state_lock(L)\nunix_peer(S) = NS\n\t\t\t// V count=1 inflight=0\n \t\t\tNS = unix_peer(S)\n \t\t\tskb2 = sock_alloc()\n\t\t\tskb_queue_tail(NS, skb2[V])\n\t\t\t// V became in-flight\n\t\t\t// V count=2 inflight=1\n\t\t\tclose(V)\n\t\t\t// V count=1 inflight=1\n\t\t\t// GC candidate condition met\n\t\t\t\t\t\tfor u in gc_inflight_list:\n\t\t\t\t\t\t  if (total_refs == inflight_refs)\n\t\t\t\t\t\t    add u to gc_candidates\n\t\t\t\t\t\t// gc_candidates={L, V}\n\t\t\t\t\t\tfor u in gc_candidates:\n\t\t\t\t\t\t  scan_children(u, dec_inflight)\n\t\t\t\t\t\t// embryo (skb1) was not\n\t\t\t\t\t\t// reachable from L yet, so V's\n\t\t\t\t\t\t// inflight remains unchanged\n__skb_queue_tail(L, skb1)\nunix_state_unlock(L)\n\t\t\t\t\t\tfor u in gc_candidates:\n\t\t\t\t\t\t  if (u.inflight)\n\t\t\t\t\t\t    scan_children(u, inc_inflight_move_tail)\n\t\t\t\t\t\t// V count=1 inflight=2 (!)\nIf there is a GC-candidate listening socket, lock/unlock its state. This\nmakes GC wait until the end of any ongoing connect() to that socket. After\nflipping the lock, a possibly SCM-laden embryo is already enqueued. And if\nthere is another embryo coming, it can not possibly carry SCM_RIGHTS. At\nthis point, unix_inflight() can not happen because unix_gc_lock is already\ntaken. Inflight graph remains unaffected.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/47d8ac011fe1c9251070e1bd64cb10b48193ec51"
          },
          {
            "url": "https://git.kernel.org/stable/c/507cc232ffe53a352847893f8177d276c3b532a9"
          },
          {
            "url": "https://git.kernel.org/stable/c/b75722be422c276b699200de90527d01c602ea7c"
          },
          {
            "url": "https://git.kernel.org/stable/c/dbdf7bec5c920200077d693193f989cb1513f009"
          },
          {
            "url": "https://git.kernel.org/stable/c/e76c2678228f6aec74b305ae30c9374cc2f28a51"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26924",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-25T06:15:57.407",
        "lastModified": "2024-04-25T13:18:20.370",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnetfilter: nft_set_pipapo: do not free live element\nPablo reports a crash with large batches of elements with a\nback-to-back add/remove pattern.  Quoting Pablo:\n  add_elem(\"00000000\") timeout 100 ms\n  ...\n  add_elem(\"0000000X\") timeout 100 ms\n  del_elem(\"0000000X\") <---------------- delete one that was just added\n  ...\n  add_elem(\"00005000\") timeout 100 ms\n  1) nft_pipapo_remove() removes element 0000000X\n  Then, KASAN shows a splat.\nLooking at the remove function there is a chance that we will drop a\nrule that maps to a non-deactivated element.\nRemoval happens in two steps, first we do a lookup for key k and return the\nto-be-removed element and mark it as inactive in the next generation.\nThen, in a second step, the element gets removed from the set/map.\nThe _remove function does not work correctly if we have more than one\nelement that share the same key.\nThis can happen if we insert an element into a set when the set already\nholds an element with same key, but the element mapping to the existing\nkey has timed out or is not active in the next generation.\nIn such case its possible that removal will unmap the wrong element.\nIf this happens, we will leak the non-deactivated element, it becomes\nunreachable.\nThe element that got deactivated (and will be freed later) will\nremain reachable in the set data structure, this can result in\na crash when such an element is retrieved during lookup (stale\npointer).\nAdd a check that the fully matching key does in fact map to the element\nthat we have marked as inactive in the deactivation step.\nIf not, we need to continue searching.\nAdd a bug/warn trap at the end of the function as well, the remove\nfunction must not ever be called with an invisible/unreachable/non-existent\nelement.\nv2: avoid uneeded temporary variable (Stefano)",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3cfc9ec039af60dbd8965ae085b2c2ccdcfbe1cc"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26925",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-25T06:15:57.590",
        "lastModified": "2024-04-25T13:18:20.370",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnetfilter: nf_tables: release mutex after nft_gc_seq_end from abort path\nThe commit mutex should not be released during the critical section\nbetween nft_gc_seq_begin() and nft_gc_seq_end(), otherwise, async GC\nworker could collect expired objects and get the released commit lock\nwithin the same GC sequence.\nnf_tables_module_autoload() temporarily releases the mutex to load\nmodule dependencies, then it goes back to replay the transaction again.\nMove it at the end of the abort phase after nft_gc_seq_end() is called.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0d459e2ffb541841714839e8228b845458ed3b27"
          },
          {
            "url": "https://git.kernel.org/stable/c/2cee2ff7f8cce12a63a0a23ffe27f08d99541494"
          },
          {
            "url": "https://git.kernel.org/stable/c/61ac7284346c32f9a8c8ceac56102f7914060428"
          },
          {
            "url": "https://git.kernel.org/stable/c/8038ee3c3e5b59bcd78467686db5270c68544e30"
          },
          {
            "url": "https://git.kernel.org/stable/c/8d3a58af50e46167b6f1db47adadad03c0045dae"
          },
          {
            "url": "https://git.kernel.org/stable/c/a34ba4bdeec0c3b629160497594908dc820110f1"
          },
          {
            "url": "https://git.kernel.org/stable/c/eb769ff4e281f751adcaf4f4445cbf30817be139"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-26926",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-25T06:15:57.780",
        "lastModified": "2024-04-25T13:18:20.370",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbinder: check offset alignment in binder_get_object()\nCommit 6d98eb95b450 (\"binder: avoid potential data leakage when copying\ntxn\") introduced changes to how binder objects are copied. In doing so,\nit unintentionally removed an offset alignment check done through calls\nto binder_alloc_copy_from_buffer() -> check_buffer().\nThese calls were replaced in binder_get_object() with copy_from_user(),\nso now an explicit offset alignment check is needed here. This avoids\nlater complications when unwinding the objects gets harder.\nIt is worth noting this check existed prior to commit 7a67a39320df\n(\"binder: add function to copy binder object from buffer\"), likely\nremoved due to redundancy at the time.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/aaef73821a3b0194a01bd23ca77774f704a04d40"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-29205",
        "sourceIdentifier": "support@hackerone.com",
        "published": "2024-04-25T06:15:57.923",
        "lastModified": "2024-04-25T13:18:13.537",
        "baseScore": 7.5,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 3.9,
        "impactScore": 3.6,
        "description": "An Improper Check for Unusual or Exceptional Conditions vulnerability in the web component of Ivanti Connect Secure (9.x, 22.x) and Ivanti Policy Secure (9.x, 22.x) allows a remote unauthenticated attacker to send specially crafted requests in-order-to cause service disruptions.",
        "cweIds": null,
        "references": [
          {
            "url": "https://forums.ivanti.com/s/article/SA-CVE-2024-21894-Heap-Overflow-CVE-2024-22052-Null-Pointer-Dereference-CVE-2024-22053-Heap-Overflow-and-CVE-2024-22023-XML-entity-expansion-or-XXE-for-Ivanti-Connect-Secure-and-Ivanti-Policy-Secure-Gateways?language=en_US"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-2907",
        "sourceIdentifier": "contact@wpscan.com",
        "published": "2024-04-25T06:15:58.887",
        "lastModified": "2024-04-25T13:18:13.537",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "The AGCA  WordPress plugin before 7.2.2 does not sanitise and escape some of its settings, which could allow high privilege users such as admin to perform Stored Cross-Site Scripting attacks even when the unfiltered_html capability is disallowed (for example in multisite setup).",
        "cweIds": null,
        "references": [
          {
            "url": "https://wpscan.com/vulnerability/d2588b47-a518-4cb2-a557-2c7eaffa17e4/"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-4159",
        "sourceIdentifier": "sirt@brocade.com",
        "published": "2024-04-25T06:16:00.560",
        "lastModified": "2024-04-25T13:18:13.537",
        "baseScore": 7.5,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 3.9,
        "impactScore": 3.6,
        "description": "Brocade SANnav before Brocade SANnav v2.3.1 lacks protection mechanisms on port 2377/TCP and 7946/TCP, which could allow an unauthenticated, remote attacker to reach Kafka APIs and send malicious data.",
        "cweIds": [
          {
            "id": "CWE-200",
            "description": "Exposure of Sensitive Information to an Unauthorized Actor"
          }
        ],
        "references": [
          {
            "url": "https://support.broadcom.com/external/content/SecurityAdvisories/0/23282"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-4161",
        "sourceIdentifier": "sirt@brocade.com",
        "published": "2024-04-25T06:16:01.427",
        "lastModified": "2024-04-25T13:18:13.537",
        "baseScore": 8.6,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 3.9,
        "impactScore": 4.0,
        "description": "In Brocade SANnav, before Brocade SANnav v2.3.0, syslog traffic received\n clear text. This could allow an unauthenticated, remote attacker to \ncapture sensitive information.",
        "cweIds": [
          {
            "id": "CWE-319",
            "description": "Cleartext Transmission of Sensitive Information"
          }
        ],
        "references": [
          {
            "url": "https://support.broadcom.com/external/content/SecurityAdvisories/0/23284"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2023-6237",
        "sourceIdentifier": "openssl-security@openssl.org",
        "published": "2024-04-25T07:15:45.270",
        "lastModified": "2024-04-25T13:18:13.537",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "Issue summary: Checking excessively long invalid RSA public keys may take\na long time.\nImpact summary: Applications that use the function EVP_PKEY_public_check()\nto check RSA public keys may experience long delays. Where the key that\nis being checked has been obtained from an untrusted source this may lead\nto a Denial of Service.\nWhen function EVP_PKEY_public_check() is called on RSA public keys,\na computation is done to confirm that the RSA modulus, n, is composite.\nFor valid RSA keys, n is a product of two or more large primes and this\ncomputation completes quickly. However, if n is an overly large prime,\nthen this computation would take a long time.\nAn application that calls EVP_PKEY_public_check() and supplies an RSA key\nobtained from an untrusted source could be vulnerable to a Denial of Service\nattack.\nThe function EVP_PKEY_public_check() is not called from other OpenSSL\nfunctions however it is called from the OpenSSL pkey command line\napplication. For that reason that application is also vulnerable if used\nwith the '-pubin' and '-check' options on untrusted data.\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are affected by this issue.",
        "cweIds": null,
        "references": [
          {
            "url": "https://github.com/openssl/openssl/commit/0b0f7abfb37350794a4b8960fafc292cd5d1b84d"
          },
          {
            "url": "https://github.com/openssl/openssl/commit/18c02492138d1eb8b6548cb26e7b625fb2414a2a"
          },
          {
            "url": "https://github.com/openssl/openssl/commit/a830f551557d3d66a84bbb18a5b889c640c36294"
          },
          {
            "url": "https://www.openssl.org/news/secadv/20240115.txt"
          }
        ]
      }
    }
  ]
}