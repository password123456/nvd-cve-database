{
  "totalResults": 53,
  "datePublished": "2024-04-11T05:00:07.787071Z",
  "vulnerabilities": [
    {
      "cve": {
        "id": "CVE-2024-31214",
        "sourceIdentifier": "security-advisories@github.com",
        "published": "2024-04-10T18:15:07.350",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": 9.6,
        "baseSeverity": "CRITICAL",
        "exploitabilityScore": 2.8,
        "impactScore": 6.0,
        "description": "Traccar is an open source GPS tracking system. Traccar versions 5.1 through 5.12 allow arbitrary files to be uploaded through the device image upload API. Attackers have full control over the file contents, full control over the directory where the file is stored, full control over the file extension, and partial control over the file name. While it's not  for an attacker to overwrite an existing file, an attacker can create new files with certain names and attacker-controlled extensions anywhere on the file system. This can potentially lead to remote code execution, XSS, DOS, etc. The default install of Traccar makes this vulnerability more severe. Self-registration is enabled by default, allowing anyone to create an account to exploit this vulnerability. Traccar also runs by default with root/system privileges, allowing files to be placed anywhere on the file system. Version 6.0 contains a fix for the issue. One may also turn off self-registration by default, as that would make most vulnerabilities in the application much harder to exploit by default and reduce the severity considerably.",
        "cweIds": [
          {
            "id": "CWE-434",
            "description": "Unrestricted Upload of File with Dangerous Type"
          }
        ],
        "references": [
          {
            "url": "https://github.com/traccar/traccar/blob/master/src/main/java/org/traccar/model/Device.java#L56"
          },
          {
            "url": "https://github.com/traccar/traccar/blob/v5.12/src/main/java/org/traccar/api/resource/DeviceResource.java#L191"
          },
          {
            "url": "https://github.com/traccar/traccar/commit/3fbdcd81566bc72e319ec05c77cf8a4120b87b8f"
          },
          {
            "url": "https://github.com/traccar/traccar/security/advisories/GHSA-3gxq-f2qj-c8v9"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-31230",
        "sourceIdentifier": "audit@patchstack.com",
        "published": "2024-04-10T18:15:07.540",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": 5.3,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 3.9,
        "impactScore": 1.4,
        "description": "Missing Authorization vulnerability in ShortPixel ShortPixel Adaptive Images.This issue affects ShortPixel Adaptive Images: from n/a through 3.8.2.",
        "cweIds": [
          {
            "id": "CWE-862",
            "description": "Missing Authorization"
          }
        ],
        "references": [
          {
            "url": "https://patchstack.com/database/vulnerability/shortpixel-adaptive-images/wordpress-shortpixel-adaptive-images-plugin-3-8-2-broken-access-control-vulnerability?_s_id=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-31242",
        "sourceIdentifier": "audit@patchstack.com",
        "published": "2024-04-10T18:15:07.730",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": 5.3,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 3.9,
        "impactScore": 1.4,
        "description": "Missing Authorization vulnerability in Bricksforge.This issue affects Bricksforge: from n/a through 2.0.17.",
        "cweIds": [
          {
            "id": "CWE-862",
            "description": "Missing Authorization"
          }
        ],
        "references": [
          {
            "url": "https://patchstack.com/database/vulnerability/bricksforge/wordpress-bricksforge-plugin-2-0-17-unauthenticated-arbitrary-email-sending-vulnerability?_s_id=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-31461",
        "sourceIdentifier": "security-advisories@github.com",
        "published": "2024-04-10T18:15:07.917",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": 9.1,
        "baseSeverity": "CRITICAL",
        "exploitabilityScore": 3.9,
        "impactScore": 5.2,
        "description": "Plane, an open-source project management tool, has a Server-Side Request Forgery (SSRF) vulnerability in versions prior to 0.17-dev. This issue may allow an attacker to send arbitrary requests from the server hosting the application, potentially leading to unauthorized access to internal systems. The impact of this vulnerability includes, but is not limited to, unauthorized access to internal services accessible from the server, potential leakage of sensitive information from internal services, manipulation of internal systems by interacting with internal APIs. Version 0.17-dev contains a patch for this issue. Those who are unable to update immediately may mitigate the issue by restricting outgoing network connections from servers hosting the application to essential services only and/or implementing strict input validation on URLs or parameters that are used to generate server-side requests.",
        "cweIds": [
          {
            "id": "CWE-918",
            "description": "Server-Side Request Forgery (SSRF)"
          }
        ],
        "references": [
          {
            "url": "https://github.com/makeplane/plane/commit/4b0ccea1461b7ca38761dfe0d0f07c2f94425005"
          },
          {
            "url": "https://github.com/makeplane/plane/commit/d887b780aea5efba3f3d28c47d7d83f8b3e1e21c"
          },
          {
            "url": "https://github.com/makeplane/plane/pull/3323"
          },
          {
            "url": "https://github.com/makeplane/plane/pull/3333"
          },
          {
            "url": "https://github.com/makeplane/plane/security/advisories/GHSA-j77v-w36v-63v6"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-31943",
        "sourceIdentifier": "audit@patchstack.com",
        "published": "2024-04-10T18:15:08.103",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": 4.3,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 2.8,
        "impactScore": 1.4,
        "description": "Cross-Site Request Forgery (CSRF) vulnerability in Octolize USPS Shipping for WooCommerce – Live Rates.This issue affects USPS Shipping for WooCommerce – Live Rates: from n/a through 1.9.2.",
        "cweIds": [
          {
            "id": "CWE-352",
            "description": "Cross-Site Request Forgery (CSRF)"
          }
        ],
        "references": [
          {
            "url": "https://patchstack.com/database/vulnerability/flexible-shipping-usps/wordpress-usps-shipping-for-woocommerce-plugin-1-9-2-cross-site-request-forgery-csrf-vulnerability?_s_id=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-31944",
        "sourceIdentifier": "audit@patchstack.com",
        "published": "2024-04-10T18:15:08.293",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": 4.3,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 2.8,
        "impactScore": 1.4,
        "description": "Cross-Site Request Forgery (CSRF) vulnerability in Octolize WooCommerce UPS Shipping – Live Rates and Access Points.This issue affects WooCommerce UPS Shipping – Live Rates and Access Points: from n/a through 2.2.4.",
        "cweIds": [
          {
            "id": "CWE-352",
            "description": "Cross-Site Request Forgery (CSRF)"
          }
        ],
        "references": [
          {
            "url": "https://patchstack.com/database/vulnerability/flexible-shipping-ups/wordpress-woocommerce-ups-shipping-plugin-2-2-4-cross-site-request-forgery-csrf-leading-to-notice-dismissal-vulnerability?_s_id=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47181",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:47.180",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nusb: musb: tusb6010: check return value after calling platform_get_resource()\nIt will cause null-ptr-deref if platform_get_resource() returns NULL,\nwe need check the return value.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/06cfb4cb2241e704d72e3045cf4d7dfb567fbce0"
          },
          {
            "url": "https://git.kernel.org/stable/c/14651496a3de6807a17c310f63c894ea0c5d858e"
          },
          {
            "url": "https://git.kernel.org/stable/c/1ba7605856e05fa991d4654ac69e5ace66c767b9"
          },
          {
            "url": "https://git.kernel.org/stable/c/28be095eb612a489705d38c210afaf1103c5f4f8"
          },
          {
            "url": "https://git.kernel.org/stable/c/3ee15f1af17407be381bcf06a78fa60b471242dd"
          },
          {
            "url": "https://git.kernel.org/stable/c/679eee466d0f9ffa60a2b0c6ec19be5128927f04"
          },
          {
            "url": "https://git.kernel.org/stable/c/b3f43659eb0b9af2e6ef18a8d829374610b19e7a"
          },
          {
            "url": "https://git.kernel.org/stable/c/f87a79c04a33ab4e5be598c7b0867e6ef193d702"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47182",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:47.243",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nscsi: core: Fix scsi_mode_sense() buffer length handling\nSeveral problems exist with scsi_mode_sense() buffer length handling:\n 1) The allocation length field of the MODE SENSE(10) command is 16-bits,\n    occupying bytes 7 and 8 of the CDB. With this command, access to mode\n    pages larger than 255 bytes is thus possible. However, the CDB\n    allocation length field is set by assigning len to byte 8 only, thus\n    truncating buffer length larger than 255.\n 2) If scsi_mode_sense() is called with len smaller than 8 with\n    sdev->use_10_for_ms set, or smaller than 4 otherwise, the buffer length\n    is increased to 8 and 4 respectively, and the buffer is zero filled\n    with these increased values, thus corrupting the memory following the\n    buffer.\nFix these 2 problems by using put_unaligned_be16() to set the allocation\nlength field of MODE SENSE(10) CDB and by returning an error when len is\ntoo small.\nFurthermore, if len is larger than 255B, always try MODE SENSE(10) first,\neven if the device driver did not set sdev->use_10_for_ms. In case of\ninvalid opcode error for MODE SENSE(10), access to mode pages larger than\n255 bytes are not retried using MODE SENSE(6). To avoid buffer length\noverflows for the MODE_SENSE(10) case, check that len is smaller than 65535\nbytes.\nWhile at it, also fix the folowing:\n * Use get_unaligned_be16() to retrieve the mode data length and block\n   descriptor length fields of the mode sense reply header instead of using\n   an open coded calculation.\n * Fix the kdoc dbd argument explanation: the DBD bit stands for Disable\n   Block Descriptor, which is the opposite of what the dbd argument\n   description was.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/17b49bcbf8351d3dbe57204468ac34f033ed60bc"
          },
          {
            "url": "https://git.kernel.org/stable/c/e15de347faf4a9f494cbd4e9a623d343dc1b5851"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47183",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:47.287",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nscsi: lpfc: Fix link down processing to address NULL pointer dereference\nIf an FC link down transition while PLOGIs are outstanding to fabric well\nknown addresses, outstanding ABTS requests may result in a NULL pointer\ndereference. Driver unload requests may hang with repeated \"2878\" log\nmessages.\nThe Link down processing results in ABTS requests for outstanding ELS\nrequests. The Abort WQEs are sent for the ELSs before the driver had set\nthe link state to down. Thus the driver is sending the Abort with the\nexpectation that an ABTS will be sent on the wire. The Abort request is\nstalled waiting for the link to come up. In some conditions the driver may\nauto-complete the ELSs thus if the link does come up, the Abort completions\nmay reference an invalid structure.\nFix by ensuring that Abort set the flag to avoid link traffic if issued due\nto conditions where the link failed.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1854f53ccd88ad4e7568ddfafafffe71f1ceb0a6"
          },
          {
            "url": "https://git.kernel.org/stable/c/28de48a7cea495ab48082d9ff4ef63f7cb4e563a"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47184",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:47.333",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ni40e: Fix NULL ptr dereference on VSI filter sync\nRemove the reason of null pointer dereference in sync VSI filters.\nAdded new I40E_VSI_RELEASING flag to signalize deleting and releasing\nof VSI resources to sync this thread with sync filters subtask.\nWithout this patch it is possible to start update the VSI filter list\nafter VSI is removed, that's causing a kernel oops.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/37d9e304acd903a445df8208b8a13d707902dea6"
          },
          {
            "url": "https://git.kernel.org/stable/c/78f2a9e831f9610e3655a0be5e675e1aa2472089"
          },
          {
            "url": "https://git.kernel.org/stable/c/87c421ab4a43433cb009fea44bbbc77f46913e1d"
          },
          {
            "url": "https://git.kernel.org/stable/c/c30162da91327e4cdf7cd03079f096bb3654738c"
          },
          {
            "url": "https://git.kernel.org/stable/c/e91e8427a1e1633a0261e3bb0201c836ac5b3890"
          },
          {
            "url": "https://git.kernel.org/stable/c/f866513ead4370402428ef724b03c3312295c178"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47185",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:47.383",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ntty: tty_buffer: Fix the softlockup issue in flush_to_ldisc\nWhen running ltp testcase(ltp/testcases/kernel/pty/pty04.c) with arm64, there is a soft lockup,\nwhich look like this one:\n  Workqueue: events_unbound flush_to_ldisc\n  Call trace:\n   dump_backtrace+0x0/0x1ec\n   show_stack+0x24/0x30\n   dump_stack+0xd0/0x128\n   panic+0x15c/0x374\n   watchdog_timer_fn+0x2b8/0x304\n   __run_hrtimer+0x88/0x2c0\n   __hrtimer_run_queues+0xa4/0x120\n   hrtimer_interrupt+0xfc/0x270\n   arch_timer_handler_phys+0x40/0x50\n   handle_percpu_devid_irq+0x94/0x220\n   __handle_domain_irq+0x88/0xf0\n   gic_handle_irq+0x84/0xfc\n   el1_irq+0xc8/0x180\n   slip_unesc+0x80/0x214 [slip]\n   tty_ldisc_receive_buf+0x64/0x80\n   tty_port_default_receive_buf+0x50/0x90\n   flush_to_ldisc+0xbc/0x110\n   process_one_work+0x1d4/0x4b0\n   worker_thread+0x180/0x430\n   kthread+0x11c/0x120\nIn the testcase pty04, The first process call the write syscall to send\ndata to the pty master. At the same time, the workqueue will do the\nflush_to_ldisc to pop data in a loop until there is no more data left.\nWhen the sender and workqueue running in different core, the sender sends\ndata fastly in full time which will result in workqueue doing work in loop\nfor a long time and occuring softlockup in flush_to_ldisc with kernel\nconfigured without preempt. So I add need_resched check and cond_resched\nin the flush_to_ldisc loop to avoid it.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0380f643f3a7a61b0845cdc738959c2ad5735d61"
          },
          {
            "url": "https://git.kernel.org/stable/c/3968ddcf05fb4b9409cd1859feb06a5b0550a1c1"
          },
          {
            "url": "https://git.kernel.org/stable/c/4c1623651a0936ee197859824cdae6ebbd04d3ed"
          },
          {
            "url": "https://git.kernel.org/stable/c/4f300f47dbcf9c3d4b2ea76c8554c8f360400725"
          },
          {
            "url": "https://git.kernel.org/stable/c/5c34486f04700f1ba04907231dce0cc2705c2d7d"
          },
          {
            "url": "https://git.kernel.org/stable/c/77e9fed33056f2a88eba9dd4d2d5412f0c7d1f41"
          },
          {
            "url": "https://git.kernel.org/stable/c/b1ffc16ec05ae40d82b6e373322d62e9d6b54fbc"
          },
          {
            "url": "https://git.kernel.org/stable/c/d491c84df5c469dd9621863b6a770b3428137063"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47186",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:47.430",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ntipc: check for null after calling kmemdup\nkmemdup can return a null pointer so need to check for it, otherwise\nthe null key will be dereferenced later in tipc_crypto_key_xmit as\ncan be seen in the trace [1].\n[1] https://syzkaller.appspot.com/bug?id=bca180abb29567b189efdbdb34cbf7ba851c2a58",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3e6db079751afd527bf3db32314ae938dc571916"
          },
          {
            "url": "https://git.kernel.org/stable/c/9404c4145542c23019a80ab1bb2ecf73cd057b10"
          },
          {
            "url": "https://git.kernel.org/stable/c/a7d91625863d4ffed63b993b5e6dc1298b6430c9"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47187",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:47.480",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\narm64: dts: qcom: msm8998: Fix CPU/L2 idle state latency and residency\nThe entry/exit latency and minimum residency in state for the idle\nstates of MSM8998 were ..bad: first of all, for all of them the\ntimings were written for CPU sleep but the min-residency-us param\nwas miscalculated (supposedly, while porting this from downstream);\nThen, the power collapse states are setting PC on both the CPU\ncluster *and* the L2 cache, which have different timings: in the\nspecific case of L2 the times are higher so these ones should be\ntaken into account instead of the CPU ones.\nThis parameter misconfiguration was not giving particular issues\nbecause on MSM8998 there was no CPU scaling at all, so cluster/L2\npower collapse was rarely (if ever) hit.\nWhen CPU scaling is enabled, though, the wrong timings will produce\nSoC unstability shown to the user as random, apparently error-less,\nsudden reboots and/or lockups.\nThis set of parameters are stabilizing the SoC when CPU scaling is\nON and when power collapse is frequently hit.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/118c826ef8b43efe0fda8faf419673707ee8c5e5"
          },
          {
            "url": "https://git.kernel.org/stable/c/3f1dcaff642e75c1d2ad03f783fa8a3b1f56dd50"
          },
          {
            "url": "https://git.kernel.org/stable/c/a14d7038ea201c5526375becfc43b9ba281b1e82"
          },
          {
            "url": "https://git.kernel.org/stable/c/e52fecdd0c142b95c720683885b06ee3f0e065c8"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47188",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:47.527",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nscsi: ufs: core: Improve SCSI abort handling\nThe following has been observed on a test setup:\nWARNING: CPU: 4 PID: 250 at drivers/scsi/ufs/ufshcd.c:2737 ufshcd_queuecommand+0x468/0x65c\nCall trace:\n ufshcd_queuecommand+0x468/0x65c\n scsi_send_eh_cmnd+0x224/0x6a0\n scsi_eh_test_devices+0x248/0x418\n scsi_eh_ready_devs+0xc34/0xe58\n scsi_error_handler+0x204/0x80c\n kthread+0x150/0x1b4\n ret_from_fork+0x10/0x30\nThat warning is triggered by the following statement:\n\tWARN_ON(lrbp->cmd);\nFix this warning by clearing lrbp->cmd from the abort handler.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3ff1f6b6ba6f97f50862aa50e79959cc8ddc2566"
          },
          {
            "url": "https://git.kernel.org/stable/c/c36baca06efa833adaefba61f45fefdc49b6d070"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47189",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:47.570",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbtrfs: fix memory ordering between normal and ordered work functions\nOrdered work functions aren't guaranteed to be handled by the same thread\nwhich executed the normal work functions. The only way execution between\nnormal/ordered functions is synchronized is via the WORK_DONE_BIT,\nunfortunately the used bitops don't guarantee any ordering whatsoever.\nThis manifested as seemingly inexplicable crashes on ARM64, where\nasync_chunk::inode is seen as non-null in async_cow_submit which causes\nsubmit_compressed_extents to be called and crash occurs because\nasync_chunk::inode suddenly became NULL. The call trace was similar to:\n    pc : submit_compressed_extents+0x38/0x3d0\n    lr : async_cow_submit+0x50/0xd0\n    sp : ffff800015d4bc20\n    <registers omitted for brevity>\n    Call trace:\n     submit_compressed_extents+0x38/0x3d0\n     async_cow_submit+0x50/0xd0\n     run_ordered_work+0xc8/0x280\n     btrfs_work_helper+0x98/0x250\n     process_one_work+0x1f0/0x4ac\n     worker_thread+0x188/0x504\n     kthread+0x110/0x114\n     ret_from_fork+0x10/0x18\nFix this by adding respective barrier calls which ensure that all\naccesses preceding setting of WORK_DONE_BIT are strictly ordered before\nsetting the flag. At the same time add a read barrier after reading of\nWORK_DONE_BIT in run_ordered_work which ensures all subsequent loads\nwould be strictly ordered after reading the bit. This in turn ensures\nare all accesses before WORK_DONE_BIT are going to be strictly ordered\nbefore any access that can occur in ordered_func.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/45da9c1767ac31857df572f0a909fbe88fd5a7e9"
          },
          {
            "url": "https://git.kernel.org/stable/c/47e6f9f69153247109042010f3a77579e9dc61ff"
          },
          {
            "url": "https://git.kernel.org/stable/c/637d652d351fd4f263ef302dc52f3971d314e500"
          },
          {
            "url": "https://git.kernel.org/stable/c/670f6b3867c8f0f11e5097f353b164cecfec6179"
          },
          {
            "url": "https://git.kernel.org/stable/c/6adbc07ebcaf8bead08b21687d49e0fc94400987"
          },
          {
            "url": "https://git.kernel.org/stable/c/804a9d239ae9cbe88e861a7cd62319cc6ec7b136"
          },
          {
            "url": "https://git.kernel.org/stable/c/bd660a20fea3ec60a49709ef5360f145ec0fe779"
          },
          {
            "url": "https://git.kernel.org/stable/c/ed058d735a70f4b063323f1a7bb33cda0f987513"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47190",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:47.617",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nperf bpf: Avoid memory leak from perf_env__insert_btf()\nperf_env__insert_btf() doesn't insert if a duplicate BTF id is\nencountered and this causes a memory leak. Modify the function to return\na success/error value and then free the memory if insertion didn't\nhappen.\nv2. Adds a return -1 when the insertion error occurs in\n    perf_env__fetch_btf. This doesn't affect anything as the result is\n    never checked.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/11589d3144bc4e272e0aae46ce8156162e99babc"
          },
          {
            "url": "https://git.kernel.org/stable/c/4924b1f7c46711762fd0e65c135ccfbcfd6ded1f"
          },
          {
            "url": "https://git.kernel.org/stable/c/642fc22210a5e59d40b1e4d56d21ec3effd401f2"
          },
          {
            "url": "https://git.kernel.org/stable/c/ab7c3d8d81c511ddfb27823fb07081c96422b56e"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47191",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:47.663",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nscsi: scsi_debug: Fix out-of-bound read in resp_readcap16()\nThe following warning was observed running syzkaller:\n[ 3813.830724] sg_write: data in/out 65466/242 bytes for SCSI command 0x9e-- guessing data in;\n[ 3813.830724]    program syz-executor not setting count and/or reply_len properly\n[ 3813.836956] ==================================================================\n[ 3813.839465] BUG: KASAN: stack-out-of-bounds in sg_copy_buffer+0x157/0x1e0\n[ 3813.841773] Read of size 4096 at addr ffff8883cf80f540 by task syz-executor/1549\n[ 3813.846612] Call Trace:\n[ 3813.846995]  dump_stack+0x108/0x15f\n[ 3813.847524]  print_address_description+0xa5/0x372\n[ 3813.848243]  kasan_report.cold+0x236/0x2a8\n[ 3813.849439]  check_memory_region+0x240/0x270\n[ 3813.850094]  memcpy+0x30/0x80\n[ 3813.850553]  sg_copy_buffer+0x157/0x1e0\n[ 3813.853032]  sg_copy_from_buffer+0x13/0x20\n[ 3813.853660]  fill_from_dev_buffer+0x135/0x370\n[ 3813.854329]  resp_readcap16+0x1ac/0x280\n[ 3813.856917]  schedule_resp+0x41f/0x1630\n[ 3813.858203]  scsi_debug_queuecommand+0xb32/0x17e0\n[ 3813.862699]  scsi_dispatch_cmd+0x330/0x950\n[ 3813.863329]  scsi_request_fn+0xd8e/0x1710\n[ 3813.863946]  __blk_run_queue+0x10b/0x230\n[ 3813.864544]  blk_execute_rq_nowait+0x1d8/0x400\n[ 3813.865220]  sg_common_write.isra.0+0xe61/0x2420\n[ 3813.871637]  sg_write+0x6c8/0xef0\n[ 3813.878853]  __vfs_write+0xe4/0x800\n[ 3813.883487]  vfs_write+0x17b/0x530\n[ 3813.884008]  ksys_write+0x103/0x270\n[ 3813.886268]  __x64_sys_write+0x77/0xc0\n[ 3813.886841]  do_syscall_64+0x106/0x360\n[ 3813.887415]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\nThis issue can be reproduced with the following syzkaller log:\nr0 = openat(0xffffffffffffff9c, &(0x7f0000000040)='./file0\\x00', 0x26e1, 0x0)\nr1 = syz_open_procfs(0xffffffffffffffff, &(0x7f0000000000)='fd/3\\x00')\nopen_by_handle_at(r1, &(0x7f00000003c0)=ANY=[@ANYRESHEX], 0x602000)\nr2 = syz_open_dev$sg(&(0x7f0000000000), 0x0, 0x40782)\nwrite$binfmt_aout(r2, &(0x7f0000000340)=ANY=[@ANYBLOB=\"00000000deff000000000000000000000000000000000000000000000000000047f007af9e107a41ec395f1bded7be24277a1501ff6196a83366f4e6362bc0ff2b247f68a972989b094b2da4fb3607fcf611a22dd04310d28c75039d\"], 0x126)\nIn resp_readcap16() we get \"int alloc_len\" value -1104926854, and then pass\nthe huge arr_len to fill_from_dev_buffer(), but arr is only 32 bytes. This\nleads to OOB in sg_copy_buffer().\nTo solve this issue, define alloc_len as u32.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3e20cb072679bdb47747ccc8bee3233a4cf0765a"
          },
          {
            "url": "https://git.kernel.org/stable/c/4e3ace0051e7e504b55d239daab8789dd89b863c"
          },
          {
            "url": "https://git.kernel.org/stable/c/5b8bed6464ad6653586e30df046185fd816ad999"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47192",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:47.710",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nscsi: core: sysfs: Fix hang when device state is set via sysfs\nThis fixes a regression added with:\ncommit f0f82e2476f6 (\"scsi: core: Fix capacity set to zero after\nofflinining device\")\nThe problem is that after iSCSI recovery, iscsid will call into the kernel\nto set the dev's state to running, and with that patch we now call\nscsi_rescan_device() with the state_mutex held. If the SCSI error handler\nthread is just starting to test the device in scsi_send_eh_cmnd() then it's\ngoing to try to grab the state_mutex.\nWe are then stuck, because when scsi_rescan_device() tries to send its I/O\nscsi_queue_rq() calls -> scsi_host_queue_ready() -> scsi_host_in_recovery()\nwhich will return true (the host state is still in recovery) and I/O will\njust be requeued. scsi_send_eh_cmnd() will then never be able to grab the\nstate_mutex to finish error handling.\nTo prevent the deadlock move the rescan-related code to after we drop the\nstate_mutex.\nThis also adds a check for if we are already in the running state. This\nprevents extra scans and helps the iscsid case where if the transport class\nhas already onlined the device during its recovery process then we don't\nneed userspace to do it again plus possibly block that daemon.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4edd8cd4e86dd3047e5294bbefcc0a08f66a430f"
          },
          {
            "url": "https://git.kernel.org/stable/c/a792e0128d232251edb5fdf42fb0f9fbb0b44a73"
          },
          {
            "url": "https://git.kernel.org/stable/c/bcc0e3175a976b7fa9a353960808adb0bb49ead8"
          },
          {
            "url": "https://git.kernel.org/stable/c/edd783162bf2385b43de6764f2d4c6e9f4f6be27"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47193",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:47.757",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nscsi: pm80xx: Fix memory leak during rmmod\nDriver failed to release all memory allocated. This would lead to memory\nleak during driver removal.\nProperly free memory when the module is removed.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/269a4311b15f68d24e816f43f123888f241ed13d"
          },
          {
            "url": "https://git.kernel.org/stable/c/51e6ed83bb4ade7c360551fa4ae55c4eacea354b"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47194",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:47.807",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ncfg80211: call cfg80211_stop_ap when switch from P2P_GO type\nIf the userspace tools switch from NL80211_IFTYPE_P2P_GO to\nNL80211_IFTYPE_ADHOC via send_msg(NL80211_CMD_SET_INTERFACE), it\ndoes not call the cleanup cfg80211_stop_ap(), this leads to the\ninitialization of in-use data. For example, this path re-init the\nsdata->assigned_chanctx_list while it is still an element of\nassigned_vifs list, and makes that linked list corrupt.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0738cdb636c21ab552eaecf905efa4a6070e3ebc"
          },
          {
            "url": "https://git.kernel.org/stable/c/4e458abbb4a523f1413bfe15c079cf4e24c15b21"
          },
          {
            "url": "https://git.kernel.org/stable/c/52affc201fc22a1ab9a59ef0ed641a9adfcb8d13"
          },
          {
            "url": "https://git.kernel.org/stable/c/563fbefed46ae4c1f70cffb8eb54c02df480b2c2"
          },
          {
            "url": "https://git.kernel.org/stable/c/5a9b671c8d74a3e1b999e7a0c7f366079bcc93dd"
          },
          {
            "url": "https://git.kernel.org/stable/c/7b97b5776daa0b39dbdadfea176f9cc0646d4a66"
          },
          {
            "url": "https://git.kernel.org/stable/c/8f06bb8c216bcd172394f61e557727e691b4cb24"
          },
          {
            "url": "https://git.kernel.org/stable/c/b8a045e2a9b234cfbc06cf36923886164358ddec"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47195",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:47.853",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nspi: fix use-after-free of the add_lock mutex\nCommit 6098475d4cb4 (\"spi: Fix deadlock when adding SPI controllers on\nSPI buses\") introduced a per-controller mutex. But mutex_unlock() of\nsaid lock is called after the controller is already freed:\n  spi_unregister_controller(ctlr)\n  -> put_device(&ctlr->dev)\n    -> spi_controller_release(dev)\n  -> mutex_unlock(&ctrl->add_lock)\nMove the put_device() after the mutex_unlock().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/37330f37f6666c7739a44b2b6b95b047ccdbed2d"
          },
          {
            "url": "https://git.kernel.org/stable/c/6c53b45c71b4920b5e62f0ea8079a1da382b9434"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47196",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:47.897",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nRDMA/core: Set send and receive CQ before forwarding to the driver\nPreset both receive and send CQ pointers prior to call to the drivers and\noverwrite it later again till the mlx4 is going to be changed do not\noverwrite ibqp properties.\nThis change is needed for mlx5, because in case of QP creation failure, it\nwill go to the path of QP destroy which relies on proper CQ pointers.\n BUG: KASAN: use-after-free in create_qp.cold+0x164/0x16e [mlx5_ib]\n Write of size 8 at addr ffff8880064c55c0 by task a.out/246\n CPU: 0 PID: 246 Comm: a.out Not tainted 5.15.0+ #291\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\n Call Trace:\n  dump_stack_lvl+0x45/0x59\n  print_address_description.constprop.0+0x1f/0x140\n  kasan_report.cold+0x83/0xdf\n  create_qp.cold+0x164/0x16e [mlx5_ib]\n  mlx5_ib_create_qp+0x358/0x28a0 [mlx5_ib]\n  create_qp.part.0+0x45b/0x6a0 [ib_core]\n  ib_create_qp_user+0x97/0x150 [ib_core]\n  ib_uverbs_handler_UVERBS_METHOD_QP_CREATE+0x92c/0x1250 [ib_uverbs]\n  ib_uverbs_cmd_verbs+0x1c38/0x3150 [ib_uverbs]\n  ib_uverbs_ioctl+0x169/0x260 [ib_uverbs]\n  __x64_sys_ioctl+0x866/0x14d0\n  do_syscall_64+0x3d/0x90\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\n Allocated by task 246:\n  kasan_save_stack+0x1b/0x40\n  __kasan_kmalloc+0xa4/0xd0\n  create_qp.part.0+0x92/0x6a0 [ib_core]\n  ib_create_qp_user+0x97/0x150 [ib_core]\n  ib_uverbs_handler_UVERBS_METHOD_QP_CREATE+0x92c/0x1250 [ib_uverbs]\n  ib_uverbs_cmd_verbs+0x1c38/0x3150 [ib_uverbs]\n  ib_uverbs_ioctl+0x169/0x260 [ib_uverbs]\n  __x64_sys_ioctl+0x866/0x14d0\n  do_syscall_64+0x3d/0x90\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\n Freed by task 246:\n  kasan_save_stack+0x1b/0x40\n  kasan_set_track+0x1c/0x30\n  kasan_set_free_info+0x20/0x30\n  __kasan_slab_free+0x10c/0x150\n  slab_free_freelist_hook+0xb4/0x1b0\n  kfree+0xe7/0x2a0\n  create_qp.part.0+0x52b/0x6a0 [ib_core]\n  ib_create_qp_user+0x97/0x150 [ib_core]\n  ib_uverbs_handler_UVERBS_METHOD_QP_CREATE+0x92c/0x1250 [ib_uverbs]\n  ib_uverbs_cmd_verbs+0x1c38/0x3150 [ib_uverbs]\n  ib_uverbs_ioctl+0x169/0x260 [ib_uverbs]\n  __x64_sys_ioctl+0x866/0x14d0\n  do_syscall_64+0x3d/0x90\n  entry_SYSCALL_64_after_hwframe+0x44/0xae",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/6cd7397d01c4a3e09757840299e4f114f0aa5fa0"
          },
          {
            "url": "https://git.kernel.org/stable/c/b70e072feffa0ba5c41a99b9524b9878dee7748e"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47197",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:47.940",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/mlx5e: nullify cq->dbg pointer in mlx5_debug_cq_remove()\nPrior to this patch in case mlx5_core_destroy_cq() failed it proceeds\nto rest of destroy operations. mlx5_core_destroy_cq() could be called again\nby user and cause additional call of mlx5_debug_cq_remove().\ncq->dbg was not nullify in previous call and cause the crash.\nFix it by nullify cq->dbg pointer after removal.\nAlso proceed to destroy operations only if FW return 0\nfor MLX5_CMD_OP_DESTROY_CQ command.\ngeneral protection fault, probably for non-canonical address 0x2000300004058: 0000 [#1] SMP PTI\nCPU: 5 PID: 1228 Comm: python Not tainted 5.15.0-rc5_for_upstream_min_debug_2021_10_14_11_06 #1\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\nRIP: 0010:lockref_get+0x1/0x60\nCode: 5d e9 53 ff ff ff 48 8d 7f 70 e8 0a 2e 48 00 c7 85 d0 00 00 00 02\n00 00 00 c6 45 70 00 fb 5d c3 c3 cc cc cc cc cc cc cc cc 53 <48> 8b 17\n48 89 fb 85 d2 75 3d 48 89 d0 bf 64 00 00 00 48 89 c1 48\nRSP: 0018:ffff888137dd7a38 EFLAGS: 00010206\nRAX: 0000000000000000 RBX: ffff888107d5f458 RCX: 00000000fffffffe\nRDX: 000000000002c2b0 RSI: ffffffff8155e2e0 RDI: 0002000300004058\nRBP: ffff888137dd7a88 R08: 0002000300004058 R09: ffff8881144a9f88\nR10: 0000000000000000 R11: 0000000000000000 R12: ffff8881141d4000\nR13: ffff888137dd7c68 R14: ffff888137dd7d58 R15: ffff888137dd7cc0\nFS:  00007f4644f2a4c0(0000) GS:ffff8887a2d40000(0000)\nknlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000055b4500f4380 CR3: 0000000114f7a003 CR4: 0000000000170ea0\nCall Trace:\n  simple_recursive_removal+0x33/0x2e0\n  ? debugfs_remove+0x60/0x60\n  debugfs_remove+0x40/0x60\n  mlx5_debug_cq_remove+0x32/0x70 [mlx5_core]\n  mlx5_core_destroy_cq+0x41/0x1d0 [mlx5_core]\n  devx_obj_cleanup+0x151/0x330 [mlx5_ib]\n  ? __pollwait+0xd0/0xd0\n  ? xas_load+0x5/0x70\n  ? xa_load+0x62/0xa0\n  destroy_hw_idr_uobject+0x20/0x80 [ib_uverbs]\n  uverbs_destroy_uobject+0x3b/0x360 [ib_uverbs]\n  uobj_destroy+0x54/0xa0 [ib_uverbs]\n  ib_uverbs_cmd_verbs+0xaf2/0x1160 [ib_uverbs]\n  ? uverbs_finalize_object+0xd0/0xd0 [ib_uverbs]\n  ib_uverbs_ioctl+0xc4/0x1b0 [ib_uverbs]\n  __x64_sys_ioctl+0x3e4/0x8e0",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2ae38157080616a13a9fe3f0b4b6ec0070aa408a"
          },
          {
            "url": "https://git.kernel.org/stable/c/471c492890557bd58f73314bb4ad85d5a8fd5026"
          },
          {
            "url": "https://git.kernel.org/stable/c/76ded29d3fcda4928da8849ffc446ea46871c1c2"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47198",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:47.990",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nscsi: lpfc: Fix use-after-free in lpfc_unreg_rpi() routine\nAn error is detected with the following report when unloading the driver:\n  \"KASAN: use-after-free in lpfc_unreg_rpi+0x1b1b\"\nThe NLP_REG_LOGIN_SEND nlp_flag is set in lpfc_reg_fab_ctrl_node(), but the\nflag is not cleared upon completion of the login.\nThis allows a second call to lpfc_unreg_rpi() to proceed with nlp_rpi set\nto LPFC_RPI_ALLOW_ERROR.  This results in a use after free access when used\nas an rpi_ids array index.\nFix by clearing the NLP_REG_LOGIN_SEND nlp_flag in\nlpfc_mbx_cmpl_fc_reg_login().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/79b20beccea3a3938a8500acef4e6b9d7c66142f"
          },
          {
            "url": "https://git.kernel.org/stable/c/dbebf865b3239595c1d4dba063b122862583b52a"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47199",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:48.037",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/mlx5e: CT, Fix multiple allocations and memleak of mod acts\nCT clear action offload adds additional mod hdr actions to the\nflow's original mod actions in order to clear the registers which\nhold ct_state.\nWhen such flow also includes encap action, a neigh update event\ncan cause the driver to unoffload the flow and then reoffload it.\nEach time this happens, the ct clear handling adds that same set\nof mod hdr actions to reset ct_state until the max of mod hdr\nactions is reached.\nAlso the driver never releases the allocated mod hdr actions and\ncausing a memleak.\nFix above two issues by moving CT clear mod acts allocation\ninto the parsing actions phase and only use it when offloading the rule.\nThe release of mod acts will be done in the normal flow_put().\n backtrace:\n    [<000000007316e2f3>] krealloc+0x83/0xd0\n    [<00000000ef157de1>] mlx5e_mod_hdr_alloc+0x147/0x300 [mlx5_core]\n    [<00000000970ce4ae>] mlx5e_tc_match_to_reg_set_and_get_id+0xd7/0x240 [mlx5_core]\n    [<0000000067c5fa17>] mlx5e_tc_match_to_reg_set+0xa/0x20 [mlx5_core]\n    [<00000000d032eb98>] mlx5_tc_ct_entry_set_registers.isra.0+0x36/0xc0 [mlx5_core]\n    [<00000000fd23b869>] mlx5_tc_ct_flow_offload+0x272/0x1f10 [mlx5_core]\n    [<000000004fc24acc>] mlx5e_tc_offload_fdb_rules.part.0+0x150/0x620 [mlx5_core]\n    [<00000000dc741c17>] mlx5e_tc_encap_flows_add+0x489/0x690 [mlx5_core]\n    [<00000000e92e49d7>] mlx5e_rep_update_flows+0x6e4/0x9b0 [mlx5_core]\n    [<00000000f60f5602>] mlx5e_rep_neigh_update+0x39a/0x5d0 [mlx5_core]",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/486e8de6e233ff2999493533c6259d1cb538653b"
          },
          {
            "url": "https://git.kernel.org/stable/c/806401c20a0f9c51b6c8fd7035671e6ca841f6c2"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47200",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:48.077",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/prime: Fix use after free in mmap with drm_gem_ttm_mmap\ndrm_gem_ttm_mmap() drops a reference to the gem object on success. If\nthe gem object's refcount == 1 on entry to drm_gem_prime_mmap(), that\ndrop will free the gem object, and the subsequent drm_gem_object_get()\nwill be a UAF. Fix by grabbing a reference before calling the mmap\nhelper.\nThis issue was forseen when the reference dropping was adding in\ncommit 9786b65bc61ac (\"drm/ttm: fix mmap refcounting\"):\n  \"For that to work properly the drm_gem_object_get() call in\n  drm_gem_ttm_mmap() must be moved so it happens before calling\n  obj->funcs->mmap(), otherwise the gem refcount would go down\n  to zero.\"",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4f8e469a2384dfa4047145b0093126462cbb6dc0"
          },
          {
            "url": "https://git.kernel.org/stable/c/8244a3bc27b3efd057da154b8d7e414670d5044f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47201",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:48.123",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\niavf: free q_vectors before queues in iavf_disable_vf\niavf_free_queues() clears adapter->num_active_queues, which\niavf_free_q_vectors() relies on, so swap the order of these two function\ncalls in iavf_disable_vf(). This resolves a panic encountered when the\ninterface is disabled and then later brought up again after PF\ncommunication is restored.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/78638b47132244e3934dc5dc79f6372d5ce8e98c"
          },
          {
            "url": "https://git.kernel.org/stable/c/89f22f129696ab53cfbc608e0a2184d0fea46ac1"
          },
          {
            "url": "https://git.kernel.org/stable/c/926e8c83d4c1c2dac0026637eb0d492df876489e"
          },
          {
            "url": "https://git.kernel.org/stable/c/9ef6589cac9a8c47f5544ccdf4c498093733bb3f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47202",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:48.167",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nthermal: Fix NULL pointer dereferences in of_thermal_ functions\nof_parse_thermal_zones() parses the thermal-zones node and registers a\nthermal_zone device for each subnode. However, if a thermal zone is\nconsuming a thermal sensor and that thermal sensor device hasn't probed\nyet, an attempt to set trip_point_*_temp for that thermal zone device\ncan cause a NULL pointer dereference. Fix it.\n console:/sys/class/thermal/thermal_zone87 # echo 120000 > trip_point_0_temp\n ...\n Unable to handle kernel NULL pointer dereference at virtual address 0000000000000020\n ...\n Call trace:\n  of_thermal_set_trip_temp+0x40/0xc4\n  trip_point_temp_store+0xc0/0x1dc\n  dev_attr_store+0x38/0x88\n  sysfs_kf_write+0x64/0xc0\n  kernfs_fop_write_iter+0x108/0x1d0\n  vfs_write+0x2f4/0x368\n  ksys_write+0x7c/0xec\n  __arm64_sys_write+0x20/0x30\n  el0_svc_common.llvm.7279915941325364641+0xbc/0x1bc\n  do_el0_svc+0x28/0xa0\n  el0_svc+0x14/0x24\n  el0_sync_handler+0x88/0xec\n  el0_sync+0x1c0/0x200\nWhile at it, fix the possible NULL pointer dereference in other\nfunctions as well: of_thermal_get_temp(), of_thermal_set_emul_temp(),\nof_thermal_get_trend().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0750f769b95841b34a9fe8c418dd792ff526bf86"
          },
          {
            "url": "https://git.kernel.org/stable/c/6a315471cb6a07f651e1d3adc8962730f4fcccac"
          },
          {
            "url": "https://git.kernel.org/stable/c/828f4c31684da94ecf0b44a2cbd35bbede04f0bd"
          },
          {
            "url": "https://git.kernel.org/stable/c/96cfe05051fd8543cdedd6807ec59a0e6c409195"
          },
          {
            "url": "https://git.kernel.org/stable/c/ef2590a5305e0b8e9342f84c2214aa478ee7f28e"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47203",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:48.217",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nscsi: lpfc: Fix list_add() corruption in lpfc_drain_txq()\nWhen parsing the txq list in lpfc_drain_txq(), the driver attempts to pass\nthe requests to the adapter. If such an attempt fails, a local \"fail_msg\"\nstring is set and a log message output.  The job is then added to a\ncompletions list for cancellation.\nProcessing of any further jobs from the txq list continues, but since\n\"fail_msg\" remains set, jobs are added to the completions list regardless\nof whether a wqe was passed to the adapter.  If successfully added to\ntxcmplq, jobs are added to both lists resulting in list corruption.\nFix by clearing the fail_msg string after adding a job to the completions\nlist. This stops the subsequent jobs from being added to the completions\nlist unless they had an appropriate failure.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/16bcbfb56d759c25665f786e33ec633b9508a08f"
          },
          {
            "url": "https://git.kernel.org/stable/c/814d3610c4ce86e8cf285b2cdac0057a42e82de5"
          },
          {
            "url": "https://git.kernel.org/stable/c/99154581b05c8fb22607afb7c3d66c1bace6aa5d"
          },
          {
            "url": "https://git.kernel.org/stable/c/ad4776b5eb2e58af1226847fcd3b4f6d051674dd"
          },
          {
            "url": "https://git.kernel.org/stable/c/b291d147d0268e93ad866f8bc820ea14497abc9b"
          },
          {
            "url": "https://git.kernel.org/stable/c/c097bd5a59162156d9c2077a2f58732ffbaa9fca"
          },
          {
            "url": "https://git.kernel.org/stable/c/ec70d80a8642900086447ba0cdc79e3f44d42e8f"
          },
          {
            "url": "https://git.kernel.org/stable/c/f05a0191b90156e539cccc189b9d87ca2a4d9305"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47204",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:48.270",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: dpaa2-eth: fix use-after-free in dpaa2_eth_remove\nAccess to netdev after free_netdev() will cause use-after-free bug.\nMove debug log before free_netdev() call to avoid it.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1c4099dc0d6a01e76e4f7dd98e4b3e0d55d80ad9"
          },
          {
            "url": "https://git.kernel.org/stable/c/32d4686224744819ddcae58b666c21d2a4ef4c88"
          },
          {
            "url": "https://git.kernel.org/stable/c/9b5a333272a48c2f8b30add7a874e46e8b26129c"
          },
          {
            "url": "https://git.kernel.org/stable/c/d74ff10ed2d93dc9b67e99a74b36fb9a83273d8a"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47205",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:48.310",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nclk: sunxi-ng: Unregister clocks/resets when unbinding\nCurrently, unbinding a CCU driver unmaps the device's MMIO region, while\nleaving its clocks/resets and their providers registered. This can cause\na page fault later when some clock operation tries to perform MMIO. Fix\nthis by separating the CCU initialization from the memory allocation,\nand then using a devres callback to unregister the clocks and resets.\nThis also fixes a memory leak of the `struct ccu_reset`, and uses the\ncorrect owner (the specific platform driver) for the clocks and resets.\nEarly OF clock providers are never unregistered, and limited error\nhandling is possible, so they are mostly unchanged. The error reporting\nis made more consistent by moving the message inside of_sunxi_ccu_probe.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/9bec2b9c6134052994115d2d3374e96f2ccb9b9d"
          },
          {
            "url": "https://git.kernel.org/stable/c/b5dd513daa70ee8f6d281a20bd28485ee9bb7db2"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47206",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:48.357",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nusb: host: ohci-tmio: check return value after calling platform_get_resource()\nIt will cause null-ptr-deref if platform_get_resource() returns NULL,\nwe need check the return value.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/065334f6640d074a1caec2f8b0091467a22f9483"
          },
          {
            "url": "https://git.kernel.org/stable/c/2474eb7fc3bfbce10f7b8ea431fcffe5dd5f5100"
          },
          {
            "url": "https://git.kernel.org/stable/c/28e016e02118917e50a667bc72fb80098cf2b460"
          },
          {
            "url": "https://git.kernel.org/stable/c/2f18f97a1a787154a372c0738f1576f14b693d91"
          },
          {
            "url": "https://git.kernel.org/stable/c/951b8239fd24678b56c995c5c0456ab12e059d19"
          },
          {
            "url": "https://git.kernel.org/stable/c/9eff2b2e59fda25051ab36cd1cb5014661df657b"
          },
          {
            "url": "https://git.kernel.org/stable/c/bb6ed2e05eb6e8619b30fa854f9becd50c11723f"
          },
          {
            "url": "https://git.kernel.org/stable/c/f98986b7acb4219f95789095eced93ed69d81d35"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47207",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:48.400",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nALSA: gus: fix null pointer dereference on pointer block\nThe pointer block return from snd_gf1_dma_next_block could be\nnull, so there is a potential null pointer dereference issue.\nFix this by adding a null check before dereference.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/16721797dcef2c7c030ffe73a07f39a65f9323c3"
          },
          {
            "url": "https://git.kernel.org/stable/c/1ac6cd87d8ddd36c43620f82c4d65b058f725f0f"
          },
          {
            "url": "https://git.kernel.org/stable/c/3e28e083dcdf03a18a083f8a47b6bb6b1604b5be"
          },
          {
            "url": "https://git.kernel.org/stable/c/542fa721594a02d2aee0370a764d306ef48d030c"
          },
          {
            "url": "https://git.kernel.org/stable/c/a0d21bb3279476c777434c40d969ea88ca64f9aa"
          },
          {
            "url": "https://git.kernel.org/stable/c/ab4c1ebc40f699f48346f634d7b72b9c5193f315"
          },
          {
            "url": "https://git.kernel.org/stable/c/c6d2cefdd05c4810c416fb8d384b5c377bd977bc"
          },
          {
            "url": "https://git.kernel.org/stable/c/cb09c760c201f82df83babc92a5ffea0a01807fc"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47209",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:48.447",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nsched/fair: Prevent dead task groups from regaining cfs_rq's\nKevin is reporting crashes which point to a use-after-free of a cfs_rq\nin update_blocked_averages(). Initial debugging revealed that we've\nlive cfs_rq's (on_list=1) in an about to be kfree()'d task group in\nfree_fair_sched_group(). However, it was unclear how that can happen.\nHis kernel config happened to lead to a layout of struct sched_entity\nthat put the 'my_q' member directly into the middle of the object\nwhich makes it incidentally overlap with SLUB's freelist pointer.\nThat, in combination with SLAB_FREELIST_HARDENED's freelist pointer\nmangling, leads to a reliable access violation in form of a #GP which\nmade the UAF fail fast.\nMichal seems to have run into the same issue[1]. He already correctly\ndiagnosed that commit a7b359fc6a37 (\"sched/fair: Correctly insert\ncfs_rq's to list on unthrottle\") is causing the preconditions for the\nUAF to happen by re-adding cfs_rq's also to task groups that have no\nmore running tasks, i.e. also to dead ones. His analysis, however,\nmisses the real root cause and it cannot be seen from the crash\nbacktrace only, as the real offender is tg_unthrottle_up() getting\ncalled via sched_cfs_period_timer() via the timer interrupt at an\ninconvenient time.\nWhen unregister_fair_sched_group() unlinks all cfs_rq's from the dying\ntask group, it doesn't protect itself from getting interrupted. If the\ntimer interrupt triggers while we iterate over all CPUs or after\nunregister_fair_sched_group() has finished but prior to unlinking the\ntask group, sched_cfs_period_timer() will execute and walk the list of\ntask groups, trying to unthrottle cfs_rq's, i.e. re-add them to the\ndying task group. These will later -- in free_fair_sched_group() -- be\nkfree()'ed while still being linked, leading to the fireworks Kevin\nand Michal are seeing.\nTo fix this race, ensure the dying task group gets unlinked first.\nHowever, simply switching the order of unregistering and unlinking the\ntask group isn't sufficient, as concurrent RCU walkers might still see\nit, as can be seen below:\n    CPU1:                                      CPU2:\n      :                                        timer IRQ:\n      :                                          do_sched_cfs_period_timer():\n      :                                            :\n      :                                            distribute_cfs_runtime():\n      :                                              rcu_read_lock();\n      :                                              :\n      :                                              unthrottle_cfs_rq():\n    sched_offline_group():                             :\n      :                                                walk_tg_tree_from(…,tg_unthrottle_up,…):\n      list_del_rcu(&tg->list);                           :\n (1)  :                                                  list_for_each_entry_rcu(child, &parent->children, siblings)\n      :                                                    :\n (2)  list_del_rcu(&tg->siblings);                         :\n      :                                                    tg_unthrottle_up():\n      unregister_fair_sched_group():                         struct cfs_rq *cfs_rq = tg->cfs_rq[cpu_of(rq)];\n        :                                                    :\n        list_del_leaf_cfs_rq(tg->cfs_rq[cpu]);               :\n        :                                                    :\n        :                                                    if (!cfs_rq_is_decayed(cfs_rq) || cfs_rq->nr_running)\n (3)    :                                                        list_add_leaf_cfs_rq(cfs_rq);\n      :                                                      :\n      :                                                    :\n      :                                                  :\n      :                                                :\n      :                           \n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/512e21c150c1c3ee298852660f3a796e267e62ec"
          },
          {
            "url": "https://git.kernel.org/stable/c/b027789e5e50494c2325cc70c8642e7fd6059479"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47210",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:48.497",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nusb: typec: tipd: Remove WARN_ON in tps6598x_block_read\nCalling tps6598x_block_read with a higher than allowed len can be\nhandled by just returning an error. There's no need to crash systems\nwith panic-on-warn enabled.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2a897d384513ba7f7ef05611338b9a6ec6aeac00"
          },
          {
            "url": "https://git.kernel.org/stable/c/2c71811c963b6c310a29455d521d31a7ea6c5b5e"
          },
          {
            "url": "https://git.kernel.org/stable/c/30dcfcda8992dc42f18e7d35b6a1fa72372d382d"
          },
          {
            "url": "https://git.kernel.org/stable/c/b7a0a63f3fed57d413bb857de164ea9c3984bc4e"
          },
          {
            "url": "https://git.kernel.org/stable/c/eff8b7628410cb2eb562ca0d5d1f12e27063733e"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47211",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:48.547",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nALSA: usb-audio: fix null pointer dereference on pointer cs_desc\nThe pointer cs_desc return from snd_usb_find_clock_source could\nbe null, so there is a potential null pointer dereference issue.\nFix this by adding a null check before dereference.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/58fa50de595f152900594c28ec9915c169643739"
          },
          {
            "url": "https://git.kernel.org/stable/c/b97053df0f04747c3c1e021ecbe99db675342954"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47212",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:48.597",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/mlx5: Update error handler for UCTX and UMEM\nIn the fast unload flow, the device state is set to internal error,\nwhich indicates that the driver started the destroy process.\nIn this case, when a destroy command is being executed, it should return\nMLX5_CMD_STAT_OK.\nFix MLX5_CMD_OP_DESTROY_UCTX and MLX5_CMD_OP_DESTROY_UMEM to return OK\ninstead of EIO.\nThis fixes a call trace in the umem release process -\n[ 2633.536695] Call Trace:\n[ 2633.537518]  ib_uverbs_remove_one+0xc3/0x140 [ib_uverbs]\n[ 2633.538596]  remove_client_context+0x8b/0xd0 [ib_core]\n[ 2633.539641]  disable_device+0x8c/0x130 [ib_core]\n[ 2633.540615]  __ib_unregister_device+0x35/0xa0 [ib_core]\n[ 2633.541640]  ib_unregister_device+0x21/0x30 [ib_core]\n[ 2633.542663]  __mlx5_ib_remove+0x38/0x90 [mlx5_ib]\n[ 2633.543640]  auxiliary_bus_remove+0x1e/0x30 [auxiliary]\n[ 2633.544661]  device_release_driver_internal+0x103/0x1f0\n[ 2633.545679]  bus_remove_device+0xf7/0x170\n[ 2633.546640]  device_del+0x181/0x410\n[ 2633.547606]  mlx5_rescan_drivers_locked.part.10+0x63/0x160 [mlx5_core]\n[ 2633.548777]  mlx5_unregister_device+0x27/0x40 [mlx5_core]\n[ 2633.549841]  mlx5_uninit_one+0x21/0xc0 [mlx5_core]\n[ 2633.550864]  remove_one+0x69/0xe0 [mlx5_core]\n[ 2633.551819]  pci_device_remove+0x3b/0xc0\n[ 2633.552731]  device_release_driver_internal+0x103/0x1f0\n[ 2633.553746]  unbind_store+0xf6/0x130\n[ 2633.554657]  kernfs_fop_write+0x116/0x190\n[ 2633.555567]  vfs_write+0xa5/0x1a0\n[ 2633.556407]  ksys_write+0x4f/0xb0\n[ 2633.557233]  do_syscall_64+0x5b/0x1a0\n[ 2633.558071]  entry_SYSCALL_64_after_hwframe+0x65/0xca\n[ 2633.559018] RIP: 0033:0x7f9977132648\n[ 2633.559821] Code: 89 02 48 c7 c0 ff ff ff ff eb b3 0f 1f 80 00 00 00 00 f3 0f 1e fa 48 8d 05 55 6f 2d 00 8b 00 85 c0 75 17 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 58 c3 0f 1f 80 00 00 00 00 41 54 49 89 d4 55\n[ 2633.562332] RSP: 002b:00007fffb1a83888 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\n[ 2633.563472] RAX: ffffffffffffffda RBX: 000000000000000c RCX: 00007f9977132648\n[ 2633.564541] RDX: 000000000000000c RSI: 000055b90546e230 RDI: 0000000000000001\n[ 2633.565596] RBP: 000055b90546e230 R08: 00007f9977406860 R09: 00007f9977a54740\n[ 2633.566653] R10: 0000000000000000 R11: 0000000000000246 R12: 00007f99774056e0\n[ 2633.567692] R13: 000000000000000c R14: 00007f9977400880 R15: 000000000000000c\n[ 2633.568725] ---[ end trace 10b4fe52945e544d ]---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/a51a6da375d82aed5c8f83abd13e7d060421bd48"
          },
          {
            "url": "https://git.kernel.org/stable/c/ba50cd9451f6c49cf0841c0a4a146ff6a2822699"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47213",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:48.640",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nNFSD: Fix exposure in nfsd4_decode_bitmap()\nrtm@csail.mit.edu reports:\n> nfsd4_decode_bitmap4() will write beyond bmval[bmlen-1] if the RPC\n> directs it to do so. This can cause nfsd4_decode_state_protect4_a()\n> to write client-supplied data beyond the end of\n> nfsd4_exchange_id.spo_must_allow[] when called by\n> nfsd4_decode_exchange_id().\nRewrite the loops so nfsd4_decode_bitmap() cannot iterate beyond\n@bmlen.\nReported by: rtm@csail.mit.edu",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/10c22d9519f3f5939de61a1500aa3a926b778d3a"
          },
          {
            "url": "https://git.kernel.org/stable/c/c0019b7db1d7ac62c711cda6b357a659d46428fe"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47214",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:48.680",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nhugetlb, userfaultfd: fix reservation restore on userfaultfd error\nCurrently in the is_continue case in hugetlb_mcopy_atomic_pte(), if we\nbail out using \"goto out_release_unlock;\" in the cases where idx >=\nsize, or !huge_pte_none(), the code will detect that new_pagecache_page\n== false, and so call restore_reserve_on_error().  In this case I see\nrestore_reserve_on_error() delete the reservation, and the following\ncall to remove_inode_hugepages() will increment h->resv_hugepages\ncausing a 100% reproducible leak.\nWe should treat the is_continue case similar to adding a page into the\npagecache and set new_pagecache_page to true, to indicate that there is\nno reservation to restore on the error path, and we need not call\nrestore_reserve_on_error().  Rename new_pagecache_page to\npage_in_pagecache to make that clear.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/b5069d44e2fbc4a9093d005b3ef0949add3dd27e"
          },
          {
            "url": "https://git.kernel.org/stable/c/cc30042df6fcc82ea18acf0dace831503e60a0b7"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47215",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:48.727",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/mlx5e: kTLS, Fix crash in RX resync flow\nFor the TLS RX resync flow, we maintain a list of TLS contexts\nthat require some attention, to communicate their resync information\nto the HW.\nHere we fix list corruptions, by protecting the entries against\nmovements coming from resync_handle_seq_match(), until their resync\nhandling in napi is fully completed.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/cc4a9cc03faa6d8db1a6954bb536f2c1e63bdff6"
          },
          {
            "url": "https://git.kernel.org/stable/c/ebeda7a9528ae690e6bf12791a868f0cca8391f2"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47216",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:48.770",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nscsi: advansys: Fix kernel pointer leak\nPointers should be printed with %p or %px rather than cast to 'unsigned\nlong' and printed with %lx.\nChange %lx to %p to print the hashed pointer.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/055eced3edf5b675d12189081303f6285ef26511"
          },
          {
            "url": "https://git.kernel.org/stable/c/06d7d12efb5c62db9dea15141ae2b322c2719515"
          },
          {
            "url": "https://git.kernel.org/stable/c/27490ae6a85a70242d80615ca74d0362a820d6a7"
          },
          {
            "url": "https://git.kernel.org/stable/c/5612287991debe310c914600599bd59511ababfb"
          },
          {
            "url": "https://git.kernel.org/stable/c/ad19f7046c24f95c674fbea21870479b2b9f5bab"
          },
          {
            "url": "https://git.kernel.org/stable/c/cc248790bfdcf879e3094fa248c85bf92cdf9dae"
          },
          {
            "url": "https://git.kernel.org/stable/c/d4996c6eac4c81b8872043e9391563f67f13e406"
          },
          {
            "url": "https://git.kernel.org/stable/c/f5a0ba4a9b5e70e7b2f767636d26523f9d1ac59d"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47217",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:48.813",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nx86/hyperv: Fix NULL deref in set_hv_tscchange_cb() if Hyper-V setup fails\nCheck for a valid hv_vp_index array prior to derefencing hv_vp_index when\nsetting Hyper-V's TSC change callback.  If Hyper-V setup failed in\nhyperv_init(), the kernel will still report that it's running under\nHyper-V, but will have silently disabled nearly all functionality.\n  BUG: kernel NULL pointer dereference, address: 0000000000000010\n  #PF: supervisor read access in kernel mode\n  #PF: error_code(0x0000) - not-present page\n  PGD 0 P4D 0\n  Oops: 0000 [#1] SMP\n  CPU: 4 PID: 1 Comm: swapper/0 Not tainted 5.15.0-rc2+ #75\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015\n  RIP: 0010:set_hv_tscchange_cb+0x15/0xa0\n  Code: <8b> 04 82 8b 15 12 17 85 01 48 c1 e0 20 48 0d ee 00 01 00 f6 c6 08\n  ...\n  Call Trace:\n   kvm_arch_init+0x17c/0x280\n   kvm_init+0x31/0x330\n   vmx_init+0xba/0x13a\n   do_one_initcall+0x41/0x1c0\n   kernel_init_freeable+0x1f2/0x23b\n   kernel_init+0x16/0x120\n   ret_from_fork+0x22/0x30",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/8823ea27fff6084bbb4bc71d15378fae0220b1d8"
          },
          {
            "url": "https://git.kernel.org/stable/c/9c177eee116cf888276d3748cb176e72562cfd5c"
          },
          {
            "url": "https://git.kernel.org/stable/c/b0e44dfb4e4c699cca33ede431b8d127e6e8d661"
          },
          {
            "url": "https://git.kernel.org/stable/c/b20ec58f8a6f4fef32cc71480ddf824584e24743"
          },
          {
            "url": "https://git.kernel.org/stable/c/daf972118c517b91f74ff1731417feb4270625a4"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47218",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:48.860",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nselinux: fix NULL-pointer dereference when hashtab allocation fails\nWhen the hash table slot array allocation fails in hashtab_init(),\nh->size is left initialized with a non-zero value, but the h->htable\npointer is NULL. This may then cause a NULL pointer dereference, since\nthe policydb code relies on the assumption that even after a failed\nhashtab_init(), hashtab_map() and hashtab_destroy() can be safely called\non it. Yet, these detect an empty hashtab only by looking at the size.\nFix this by making sure that hashtab_init() always leaves behind a valid\nempty hashtab when the allocation fails.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/83c8ab8503adf56bf68dafc7a382f4946c87da79"
          },
          {
            "url": "https://git.kernel.org/stable/c/b17dd53cac769dd13031b0ca34f90cc65e523fab"
          },
          {
            "url": "https://git.kernel.org/stable/c/dc27f3c5d10c58069672215787a96b4fae01818b"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2021-47219",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-04-10T19:15:48.903",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nscsi: scsi_debug: Fix out-of-bound read in resp_report_tgtpgs()\nThe following issue was observed running syzkaller:\nBUG: KASAN: slab-out-of-bounds in memcpy include/linux/string.h:377 [inline]\nBUG: KASAN: slab-out-of-bounds in sg_copy_buffer+0x150/0x1c0 lib/scatterlist.c:831\nRead of size 2132 at addr ffff8880aea95dc8 by task syz-executor.0/9815\nCPU: 0 PID: 9815 Comm: syz-executor.0 Not tainted 4.19.202-00874-gfc0fe04215a9 #2\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0xe4/0x14a lib/dump_stack.c:118\n print_address_description+0x73/0x280 mm/kasan/report.c:253\n kasan_report_error mm/kasan/report.c:352 [inline]\n kasan_report+0x272/0x370 mm/kasan/report.c:410\n memcpy+0x1f/0x50 mm/kasan/kasan.c:302\n memcpy include/linux/string.h:377 [inline]\n sg_copy_buffer+0x150/0x1c0 lib/scatterlist.c:831\n fill_from_dev_buffer+0x14f/0x340 drivers/scsi/scsi_debug.c:1021\n resp_report_tgtpgs+0x5aa/0x770 drivers/scsi/scsi_debug.c:1772\n schedule_resp+0x464/0x12f0 drivers/scsi/scsi_debug.c:4429\n scsi_debug_queuecommand+0x467/0x1390 drivers/scsi/scsi_debug.c:5835\n scsi_dispatch_cmd+0x3fc/0x9b0 drivers/scsi/scsi_lib.c:1896\n scsi_request_fn+0x1042/0x1810 drivers/scsi/scsi_lib.c:2034\n __blk_run_queue_uncond block/blk-core.c:464 [inline]\n __blk_run_queue+0x1a4/0x380 block/blk-core.c:484\n blk_execute_rq_nowait+0x1c2/0x2d0 block/blk-exec.c:78\n sg_common_write.isra.19+0xd74/0x1dc0 drivers/scsi/sg.c:847\n sg_write.part.23+0x6e0/0xd00 drivers/scsi/sg.c:716\n sg_write+0x64/0xa0 drivers/scsi/sg.c:622\n __vfs_write+0xed/0x690 fs/read_write.c:485\nkill_bdev:block_device:00000000e138492c\n vfs_write+0x184/0x4c0 fs/read_write.c:549\n ksys_write+0x107/0x240 fs/read_write.c:599\n do_syscall_64+0xc2/0x560 arch/x86/entry/common.c:293\n entry_SYSCALL_64_after_hwframe+0x49/0xbe\nWe get 'alen' from command its type is int. If userspace passes a large\nlength we will get a negative 'alen'.\nSwitch n, alen, and rlen to u32.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/66523553fa62c7878fc5441dc4e82be71934eb77"
          },
          {
            "url": "https://git.kernel.org/stable/c/8440377e1a5644779b4c8d013aa2a917f5fc83c3"
          },
          {
            "url": "https://git.kernel.org/stable/c/f347c26836c270199de1599c3cd466bb7747caa9"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2023-52070",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-04-10T19:15:48.973",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "JFreeChart v1.5.4 was discovered to be vulnerable to ArrayIndexOutOfBounds via the 'setSeriesNeedle(int index, int type)' method.",
        "cweIds": null,
        "references": [
          {
            "url": "http://jfreechart.com"
          },
          {
            "url": "http://jfreeorg.com"
          },
          {
            "url": "https://gist.github.com/LLM4IG/f55de46e65fb5a19b7815adb36fd858b"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-23077",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-04-10T19:15:49.020",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "JFreeChart v1.5.4 was discovered to be vulnerable to ArrayIndexOutOfBounds via the component /chart/plot/CompassPlot.java.",
        "cweIds": null,
        "references": [
          {
            "url": "http://jfreechart.com"
          },
          {
            "url": "https://gist.github.com/LLM4IG/f55de46e65fb5a19b7815adb36fd858b"
          },
          {
            "url": "https://github.com/jfree/jfreechart"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-28344",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-04-10T19:15:49.070",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "An Open Redirect vulnerability was found in Sipwise C5 NGCP Dashboard below mr11.5.1. The Open Redirect vulnerability allows attackers to control the \"back\" parameter in the URL through a double encoded URL.",
        "cweIds": null,
        "references": [
          {
            "url": "https://securitycafe.ro/2024/03/21/cve-2024-28344-cve-2024-28345-in-sipwise-c5/"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-28345",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-04-10T19:15:49.117",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "An issue discovered in Sipwise C5 NGCP Dashboard below mr11.5.1 allows a low privileged user to access the Journal endpoint by directly visit the URL.",
        "cweIds": null,
        "references": [
          {
            "url": "https://securitycafe.ro/2024/03/21/cve-2024-28344-cve-2024-28345-in-sipwise-c5/"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-31386",
        "sourceIdentifier": "audit@patchstack.com",
        "published": "2024-04-10T19:15:49.167",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": 4.3,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 2.8,
        "impactScore": 1.4,
        "description": "Cross-Site Request Forgery (CSRF) vulnerability in Hidekazu Ishikawa X-T9, Hidekazu Ishikawa Lightning, themeinwp Default Mag, Out the Box Namaha, Out the Box CityLogic, Marsian i-max, Jetmonsters Emmet Lite, Macho Themes Decode, Wayneconnor Sliding Door, Out the Box Shopstar!, Modernthemesnet Gridsby, TT Themes HappenStance, Marsian i-excel, Out the Box Panoramic, Modernthemesnet Sensible WP.This issue affects X-T9: from n/a through 1.19.0; Lightning: from n/a through 15.18.0; Default Mag: from n/a through 1.3.5; Namaha: from n/a through 1.0.40; CityLogic: from n/a through 1.1.29; i-max: from n/a through 1.6.2; Emmet Lite: from n/a through 1.7.5; Decode: from n/a through 3.15.3; Sliding Door: from n/a through 3.3; Shopstar!: from n/a through 1.1.33; Gridsby: from n/a through 1.3.0; HappenStance: from n/a through 3.0.1; i-excel: from n/a through 1.7.9; Panoramic: from n/a through 1.1.56; Sensible WP: from n/a through 1.3.1.",
        "cweIds": [
          {
            "id": "CWE-352",
            "description": "Cross-Site Request Forgery (CSRF)"
          }
        ],
        "references": [
          {
            "url": "https://patchstack.com/database/vulnerability/citylogic/wordpress-citylogic-theme-1-1-29-cross-site-request-forgery-csrf-vulnerability?_s_id=cve"
          },
          {
            "url": "https://patchstack.com/database/vulnerability/decode/wordpress-decode-theme-3-15-3-cross-site-request-forgery-csrf-vulnerability?_s_id=cve"
          },
          {
            "url": "https://patchstack.com/database/vulnerability/default-mag/wordpress-default-mag-theme-1-3-5-cross-site-request-forgery-csrf-vulnerability?_s_id=cve"
          },
          {
            "url": "https://patchstack.com/database/vulnerability/emmet-lite/wordpress-emmet-lite-theme-1-7-5-cross-site-request-forgery-csrf-vulnerability?_s_id=cve"
          },
          {
            "url": "https://patchstack.com/database/vulnerability/gridsby/wordpress-gridsby-theme-1-3-0-cross-site-request-forgery-csrf-vulnerability?_s_id=cve"
          },
          {
            "url": "https://patchstack.com/database/vulnerability/happenstance/wordpress-happenstance-theme-3-0-1-cross-site-request-forgery-csrf-vulnerability?_s_id=cve"
          },
          {
            "url": "https://patchstack.com/database/vulnerability/i-excel/wordpress-i-excel-theme-1-7-9-cross-site-request-forgery-csrf-vulnerability?_s_id=cve"
          },
          {
            "url": "https://patchstack.com/database/vulnerability/i-max/wordpress-i-max-theme-1-6-2-cross-site-request-forgery-csrf-vulnerability?_s_id=cve"
          },
          {
            "url": "https://patchstack.com/database/vulnerability/lightning/wordpress-lightning-theme-15-18-0-cross-site-request-forgery-csrf-vulnerability?_s_id=cve"
          },
          {
            "url": "https://patchstack.com/database/vulnerability/namaha/wordpress-namaha-theme-1-0-40-cross-site-request-forgery-csrf-vulnerability?_s_id=cve"
          },
          {
            "url": "https://patchstack.com/database/vulnerability/panoramic/wordpress-panoramic-theme-1-1-56-cross-site-request-forgery-csrf-vulnerability?_s_id=cve"
          },
          {
            "url": "https://patchstack.com/database/vulnerability/sensible-wp/wordpress-sensible-wp-theme-1-3-1-cross-site-request-forgery-csrf-vulnerability?_s_id=cve"
          },
          {
            "url": "https://patchstack.com/database/vulnerability/shopstar/wordpress-shopstar-theme-1-1-33-cross-site-request-forgery-csrf-vulnerability?_s_id=cve"
          },
          {
            "url": "https://patchstack.com/database/vulnerability/sliding-door/wordpress-sliding-door-theme-3-3-cross-site-request-forgery-csrf-vulnerability?_s_id=cve"
          },
          {
            "url": "https://patchstack.com/database/vulnerability/x-t9/wordpress-x-t9-theme-1-19-0-cross-site-request-forgery-csrf-vulnerability?_s_id=cve"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-31464",
        "sourceIdentifier": "security-advisories@github.com",
        "published": "2024-04-10T19:15:49.413",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": 6.8,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 2.3,
        "impactScore": 4.0,
        "description": "XWiki Platform is a generic wiki platform. Starting in version 5.0-rc-1 and prior to versions 14.10.19, 15.5.4, and 15.9-rc-1, it is possible to access the hash of a password by using the diff feature of the history whenever the object storing the password is deleted. Using that vulnerability it's possible for an attacker to have access to the hash password of a user if they have rights to edit the users' page.  With the default right scheme in XWiki this vulnerability is normally prevented on user profiles, except by users with Admin rights. Note that this vulnerability also impacts any extensions that might use passwords stored in xobjects: for those usecases it depends on the right of those pages. There is currently no way to be 100% sure that this vulnerability has been exploited, as an attacker with enough privilege could have deleted the revision where the xobject was deleted after rolling-back the deletion. But again, this operation requires high privileges on the target page (Admin right). A page with a user password xobject which have in its history a revision where the object has been deleted should be considered at risk and the password should be changed there. a diff, to ensure it's not coming from a password field. As another mitigation, admins should ensure that the user pages are properly protected: the edit right shouldn't be allowed for other users than Admin and owner of the profile (which is the default right). There is not much workaround possible for a privileged user other than upgrading XWiki.",
        "cweIds": [
          {
            "id": "CWE-200",
            "description": "Exposure of Sensitive Information to an Unauthorized Actor"
          }
        ],
        "references": [
          {
            "url": "https://github.com/xwiki/xwiki-platform/commit/9075668a4135cce114ef2a4b72eba3161a9e94c4"
          },
          {
            "url": "https://github.com/xwiki/xwiki-platform/commit/955fb097e02a2a7153f527522ee9eef42447e5d7"
          },
          {
            "url": "https://github.com/xwiki/xwiki-platform/commit/f1eaec1e512220fabd970d053c627e435a1652cf"
          },
          {
            "url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-v782-xr4w-3vqx"
          },
          {
            "url": "https://jira.xwiki.org/browse/XWIKI-19948"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-3157",
        "sourceIdentifier": "chrome-cve-admin@google.com",
        "published": "2024-04-10T19:15:49.623",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "Out of bounds memory access in Compositing in Google Chrome prior to 123.0.6312.122 allowed a remote attacker who had compromised the GPU process to potentially perform a sandbox escape via specific UI gestures. (Chromium security severity: High)",
        "cweIds": null,
        "references": [
          {
            "url": "https://chromereleases.googleblog.com/2024/04/stable-channel-update-for-desktop_10.html"
          },
          {
            "url": "https://issues.chromium.org/issues/331237485"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-3515",
        "sourceIdentifier": "chrome-cve-admin@google.com",
        "published": "2024-04-10T19:15:49.670",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "Use after free in Dawn in Google Chrome prior to 123.0.6312.122 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)",
        "cweIds": null,
        "references": [
          {
            "url": "https://chromereleases.googleblog.com/2024/04/stable-channel-update-for-desktop_10.html"
          },
          {
            "url": "https://issues.chromium.org/issues/331123811"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-3516",
        "sourceIdentifier": "chrome-cve-admin@google.com",
        "published": "2024-04-10T19:15:49.717",
        "lastModified": "2024-04-10T19:49:51.183",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "Heap buffer overflow in ANGLE in Google Chrome prior to 123.0.6312.122 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)",
        "cweIds": null,
        "references": [
          {
            "url": "https://chromereleases.googleblog.com/2024/04/stable-channel-update-for-desktop_10.html"
          },
          {
            "url": "https://issues.chromium.org/issues/328859176"
          }
        ]
      }
    }
  ]
}