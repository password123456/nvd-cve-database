{
  "totalResults": 52,
  "datePublished": "2024-09-12T03:00:16.825457Z",
  "vulnerabilities": [
    {
      "cve": {
        "id": "CVE-2024-39378",
        "sourceIdentifier": "psirt@adobe.com",
        "published": "2024-09-11T16:15:05.797",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": 7.8,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 1.8,
        "impactScore": 5.9,
        "description": "Audition versions 24.4.1, 23.6.6 and earlier are affected by an out-of-bounds write vulnerability that could result in arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.",
        "cweIds": [
          {
            "id": "CWE-787",
            "description": "Out-of-bounds Write"
          }
        ],
        "references": [
          {
            "url": "https://helpx.adobe.com/security/products/audition/apsb24-54.html"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-41868",
        "sourceIdentifier": "psirt@adobe.com",
        "published": "2024-09-11T16:15:06.140",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": 5.5,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 1.8,
        "impactScore": 3.6,
        "description": "Audition versions 24.4.1, 23.6.6 and earlier are affected by an out-of-bounds read vulnerability that could lead to disclosure of sensitive memory. An attacker could leverage this vulnerability to bypass mitigations such as ASLR. Exploitation of this issue requires user interaction in that a victim must open a malicious file.",
        "cweIds": [
          {
            "id": "CWE-125",
            "description": "Out-of-bounds Read"
          }
        ],
        "references": [
          {
            "url": "https://helpx.adobe.com/security/products/audition/apsb24-54.html"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44466",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-09-11T16:15:06.330",
        "lastModified": "2024-09-11T18:35:30.960",
        "baseScore": 9.8,
        "baseSeverity": "CRITICAL",
        "exploitabilityScore": 3.9,
        "impactScore": 5.9,
        "description": "COMFAST CF-XR11 V2.7.2 has a command injection vulnerability in function sub_424CB4. Attackers can send POST request messages to /usr/bin/webmgnt and inject commands into parameter iface.",
        "cweIds": [
          {
            "id": "CWE-94",
            "description": "Improper Control of Generation of Code ('Code Injection')"
          }
        ],
        "references": [
          {
            "url": "https://github.com/CurryRaid/iot_vul/tree/main/comfast"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44851",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-09-11T16:15:06.380",
        "lastModified": "2024-09-11T18:35:31.703",
        "baseScore": 5.4,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 2.3,
        "impactScore": 2.7,
        "description": "A stored cross-site scripting (XSS) vulnerability in the Discussion section of Perfex CRM v1.1.0 allows attackers to execute arbitrary web scripts or HTML via a crafted payload injected into the Content parameter.",
        "cweIds": [
          {
            "id": "CWE-79",
            "description": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
          }
        ],
        "references": [
          {
            "url": "https://gist.github.com/0xashfaq/e44a6dece3be498241aebcfaa046e634"
          },
          {
            "url": "https://github.com/0xashfaq/File-Sharing-module-for-Perfex-CRM-XSS/"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45009",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:06.427",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmptcp: pm: only decrement add_addr_accepted for MPJ req\nAdding the following warning ...\n  WARN_ON_ONCE(msk->pm.add_addr_accepted == 0)\n... before decrementing the add_addr_accepted counter helped to find a\nbug when running the \"remove single subflow\" subtest from the\nmptcp_join.sh selftest.\nRemoving a 'subflow' endpoint will first trigger a RM_ADDR, then the\nsubflow closure. Before this patch, and upon the reception of the\nRM_ADDR, the other peer will then try to decrement this\nadd_addr_accepted. That's not correct because the attached subflows have\nnot been created upon the reception of an ADD_ADDR.\nA way to solve that is to decrement the counter only if the attached\nsubflow was an MP_JOIN to a remote id that was not 0, and initiated by\nthe host receiving the RM_ADDR.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1c1f721375989579e46741f59523e39ec9b2a9bd"
          },
          {
            "url": "https://git.kernel.org/stable/c/2060f1efab370b496c4903b840844ecaff324c3c"
          },
          {
            "url": "https://git.kernel.org/stable/c/85b866e4c4e63a1d7afb58f1e24273caad03d0b7"
          },
          {
            "url": "https://git.kernel.org/stable/c/d20bf2c96d7ffd171299b32f562f70e5bf5dc608"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45010",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:06.483",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmptcp: pm: only mark 'subflow' endp as available\nAdding the following warning ...\n  WARN_ON_ONCE(msk->pm.local_addr_used == 0)\n... before decrementing the local_addr_used counter helped to find a bug\nwhen running the \"remove single address\" subtest from the mptcp_join.sh\nselftests.\nRemoving a 'signal' endpoint will trigger the removal of all subflows\nlinked to this endpoint via mptcp_pm_nl_rm_addr_or_subflow() with\nrm_type == MPTCP_MIB_RMSUBFLOW. This will decrement the local_addr_used\ncounter, which is wrong in this case because this counter is linked to\n'subflow' endpoints, and here it is a 'signal' endpoint that is being\nremoved.\nNow, the counter is decremented, only if the ID is being used outside\nof mptcp_pm_nl_rm_addr_or_subflow(), only for 'subflow' endpoints, and\nif the ID is not 0 -- local_addr_used is not taking into account these\nones. This marking of the ID as being available, and the decrement is\ndone no matter if a subflow using this ID is currently available,\nbecause the subflow could have been closed before.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/322ea3778965da72862cca2a0c50253aacf65fe6"
          },
          {
            "url": "https://git.kernel.org/stable/c/43cf912b0b0fc7b4fd12cbc735d1f5afb8e1322d"
          },
          {
            "url": "https://git.kernel.org/stable/c/7fdc870d08960961408a44c569f20f50940e7d4f"
          },
          {
            "url": "https://git.kernel.org/stable/c/9849cfc67383ceb167155186f8f8fe8a896b60b3"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45011",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:06.550",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nchar: xillybus: Check USB endpoints when probing device\nEnsure, as the driver probes the device, that all endpoints that the\ndriver may attempt to access exist and are of the correct type.\nAll XillyUSB devices must have a Bulk IN and Bulk OUT endpoint at\naddress 1. This is verified in xillyusb_setup_base_eps().\nOn top of that, a XillyUSB device may have additional Bulk OUT\nendpoints. The information about these endpoints' addresses is deduced\nfrom a data structure (the IDT) that the driver fetches from the device\nwhile probing it. These endpoints are checked in setup_channels().\nA XillyUSB device never has more than one IN endpoint, as all data\ntowards the host is multiplexed in this single Bulk IN endpoint. This is\nwhy setup_channels() only checks OUT endpoints.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1371d32b95972d39c1e6e4bae8b6d0df1b573731"
          },
          {
            "url": "https://git.kernel.org/stable/c/2374bf7558de915edc6ec8cb10ec3291dfab9594"
          },
          {
            "url": "https://git.kernel.org/stable/c/25ee8b2908200fc862c0434e5ad483817d50ceda"
          },
          {
            "url": "https://git.kernel.org/stable/c/4267131278f5cc98f8db31d035d64bdbbfe18658"
          },
          {
            "url": "https://git.kernel.org/stable/c/5cff754692ad45d5086b75fef8cc3a99c30a1005"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45012",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:06.607",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnouveau/firmware: use dma non-coherent allocator\nCurrently, enabling SG_DEBUG in the kernel will cause nouveau to hit a\nBUG() on startup, when the iommu is enabled:\nkernel BUG at include/linux/scatterlist.h:187!\ninvalid opcode: 0000 [#1] PREEMPT SMP NOPTI\nCPU: 7 PID: 930 Comm: (udev-worker) Not tainted 6.9.0-rc3Lyude-Test+ #30\nHardware name: MSI MS-7A39/A320M GAMING PRO (MS-7A39), BIOS 1.I0 01/22/2019\nRIP: 0010:sg_init_one+0x85/0xa0\nCode: 69 88 32 01 83 e1 03 f6 c3 03 75 20 a8 01 75 1e 48 09 cb 41 89 54\n24 08 49 89 1c 24 41 89 6c 24 0c 5b 5d 41 5c e9 7b b9 88 00 <0f> 0b 0f 0b\n0f 0b 48 8b 05 5e 46 9a 01 eb b2 66 66 2e 0f 1f 84 00\nRSP: 0018:ffffa776017bf6a0 EFLAGS: 00010246\nRAX: 0000000000000000 RBX: ffffa77600d87000 RCX: 000000000000002b\nRDX: 0000000000000001 RSI: 0000000000000000 RDI: ffffa77680d87000\nRBP: 000000000000e000 R08: 0000000000000000 R09: 0000000000000000\nR10: ffff98f4c46aa508 R11: 0000000000000000 R12: ffff98f4c46aa508\nR13: ffff98f4c46aa008 R14: ffffa77600d4a000 R15: ffffa77600d4a018\nFS:  00007feeb5aae980(0000) GS:ffff98f5c4dc0000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f22cb9a4520 CR3: 00000001043ba000 CR4: 00000000003506f0\nCall Trace:\n <TASK>\n ? die+0x36/0x90\n ? do_trap+0xdd/0x100\n ? sg_init_one+0x85/0xa0\n ? do_error_trap+0x65/0x80\n ? sg_init_one+0x85/0xa0\n ? exc_invalid_op+0x50/0x70\n ? sg_init_one+0x85/0xa0\n ? asm_exc_invalid_op+0x1a/0x20\n ? sg_init_one+0x85/0xa0\n nvkm_firmware_ctor+0x14a/0x250 [nouveau]\n nvkm_falcon_fw_ctor+0x42/0x70 [nouveau]\n ga102_gsp_booter_ctor+0xb4/0x1a0 [nouveau]\n r535_gsp_oneinit+0xb3/0x15f0 [nouveau]\n ? srso_return_thunk+0x5/0x5f\n ? srso_return_thunk+0x5/0x5f\n ? nvkm_udevice_new+0x95/0x140 [nouveau]\n ? srso_return_thunk+0x5/0x5f\n ? srso_return_thunk+0x5/0x5f\n ? ktime_get+0x47/0xb0\nFix this by using the non-coherent allocator instead, I think there\nmight be a better answer to this, but it involve ripping up some of\nAPIs using sg lists.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/57ca481fca97ca4553e8c85d6a94baf4cb40c40e"
          },
          {
            "url": "https://git.kernel.org/stable/c/9b340aeb26d50e9a9ec99599e2a39b035fac978e"
          },
          {
            "url": "https://git.kernel.org/stable/c/cc29c5546c6a373648363ac49781f1d74b530707"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45013",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:06.663",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnvme: move stopping keep-alive into nvme_uninit_ctrl()\nCommit 4733b65d82bd (\"nvme: start keep-alive after admin queue setup\")\nmoves starting keep-alive from nvme_start_ctrl() into\nnvme_init_ctrl_finish(), but don't move stopping keep-alive into\nnvme_uninit_ctrl(), so keep-alive work can be started and keep pending\nafter failing to start controller, finally use-after-free is triggered if\nnvme host driver is unloaded.\nThis patch fixes kernel panic when running nvme/004 in case that connection\nfailure is triggered, by moving stopping keep-alive into nvme_uninit_ctrl().\nThis way is reasonable because keep-alive is now started in\nnvme_init_ctrl_finish().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4101af98ab573554c4225e328d506fec2a74bc54"
          },
          {
            "url": "https://git.kernel.org/stable/c/a54a93d0e3599b05856971734e15418ac551a14c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45014",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:06.710",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ns390/boot: Avoid possible physmem_info segment corruption\nWhen physical memory for the kernel image is allocated it does not\nconsider extra memory required for offsetting the image start to\nmatch it with the lower 20 bits of KASLR virtual base address. That\nmight lead to kernel access beyond its memory range.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/a944cba5d57687b747023c3bc074fcf9c790f7df"
          },
          {
            "url": "https://git.kernel.org/stable/c/d7fd2941ae9a67423d1c7bee985f240e4686634f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45015",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:06.763",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/msm/dpu: move dpu_encoder's connector assignment to atomic_enable()\nFor cases where the crtc's connectors_changed was set without enable/active\ngetting toggled , there is an atomic_enable() call followed by an\natomic_disable() but without an atomic_mode_set().\nThis results in a NULL ptr access for the dpu_encoder_get_drm_fmt() call in\nthe atomic_enable() as the dpu_encoder's connector was cleared in the\natomic_disable() but not re-assigned as there was no atomic_mode_set() call.\nFix the NULL ptr access by moving the assignment for atomic_enable() and also\nuse drm_atomic_get_new_connector_for_encoder() to get the connector from\nthe atomic_state.\nPatchwork: https://patchwork.freedesktop.org/patch/606729/",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3bacf814b6a61cc683c68465f175ebd938f09c52"
          },
          {
            "url": "https://git.kernel.org/stable/c/3fb61718bcbe309279205d1cc275a6435611dc77"
          },
          {
            "url": "https://git.kernel.org/stable/c/aedf02e46eb549dac8db4821a6b9f0c6bf6e3990"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45016",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:06.817",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnetem: fix return value if duplicate enqueue fails\nThere is a bug in netem_enqueue() introduced by\ncommit 5845f706388a (\"net: netem: fix skb length BUG_ON in __skb_to_sgvec\")\nthat can lead to a use-after-free.\nThis commit made netem_enqueue() always return NET_XMIT_SUCCESS\nwhen a packet is duplicated, which can cause the parent qdisc's q.qlen\nto be mistakenly incremented. When this happens qlen_notify() may be\nskipped on the parent during destruction, leaving a dangling pointer\nfor some classful qdiscs like DRR.\nThere are two ways for the bug happen:\n- If the duplicated packet is dropped by rootq->enqueue() and then\n  the original packet is also dropped.\n- If rootq->enqueue() sends the duplicated packet to a different qdisc\n  and the original packet is dropped.\nIn both cases NET_XMIT_SUCCESS is returned even though no packets\nare enqueued at the netem qdisc.\nThe fix is to defer the enqueue of the duplicate packet until after\nthe original packet has been guaranteed to return NET_XMIT_SUCCESS.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0486d31dd8198e22b63a4730244b38fffce6d469"
          },
          {
            "url": "https://git.kernel.org/stable/c/52d99a69f3d556c6426048c9d481b912205919d8"
          },
          {
            "url": "https://git.kernel.org/stable/c/577d6c0619467fe90f7e8e57e45cb5bd9d936014"
          },
          {
            "url": "https://git.kernel.org/stable/c/759e3e8c4a6a6b4e52ebc4547123a457f0ce90d4"
          },
          {
            "url": "https://git.kernel.org/stable/c/c07ff8592d57ed258afee5a5e04991a48dbaf382"
          },
          {
            "url": "https://git.kernel.org/stable/c/c414000da1c2ea1ba9a5e5bb1a4ba774e51e202d"
          },
          {
            "url": "https://git.kernel.org/stable/c/e5bb2988a310667abed66c7d3ffa28880cf0f883"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45017",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:06.877",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/mlx5: Fix IPsec RoCE MPV trace call\nPrevent the call trace below from happening, by not allowing IPsec\ncreation over a slave, if master device doesn't support IPsec.\nWARNING: CPU: 44 PID: 16136 at kernel/locking/rwsem.c:240 down_read+0x75/0x94\nModules linked in: esp4_offload esp4 act_mirred act_vlan cls_flower sch_ingress mlx5_vdpa vringh vhost_iotlb vdpa mst_pciconf(OE) nfsv3 nfs_acl nfs lockd grace fscache netfs xt_CHECKSUM xt_MASQUERADE xt_conntrack ipt_REJECT nf_reject_ipv4 nft_compat nft_counter nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 rfkill cuse fuse rpcrdma sunrpc rdma_ucm ib_srpt ib_isert iscsi_target_mod target_core_mod ib_umad ib_iser libiscsi scsi_transport_iscsi rdma_cm ib_ipoib iw_cm ib_cm ipmi_ssif intel_rapl_msr intel_rapl_common amd64_edac edac_mce_amd kvm_amd kvm irqbypass crct10dif_pclmul crc32_pclmul mlx5_ib ghash_clmulni_intel sha1_ssse3 dell_smbios ib_uverbs aesni_intel crypto_simd dcdbas wmi_bmof dell_wmi_descriptor cryptd pcspkr ib_core acpi_ipmi sp5100_tco ccp i2c_piix4 ipmi_si ptdma k10temp ipmi_devintf ipmi_msghandler acpi_power_meter acpi_cpufreq ext4 mbcache jbd2 sd_mod t10_pi sg mgag200 drm_kms_helper syscopyarea sysfillrect mlx5_core sysimgblt fb_sys_fops cec\n ahci libahci mlxfw drm pci_hyperv_intf libata tg3 sha256_ssse3 tls megaraid_sas i2c_algo_bit psample wmi dm_mirror dm_region_hash dm_log dm_mod [last unloaded: mst_pci]\nCPU: 44 PID: 16136 Comm: kworker/44:3 Kdump: loaded Tainted: GOE 5.15.0-20240509.el8uek.uek7_u3_update_v6.6_ipsec_bf.x86_64 #2\nHardware name: Dell Inc. PowerEdge R7525/074H08, BIOS 2.0.3 01/15/2021\nWorkqueue: events xfrm_state_gc_task\nRIP: 0010:down_read+0x75/0x94\nCode: 00 48 8b 45 08 65 48 8b 14 25 80 fc 01 00 83 e0 02 48 09 d0 48 83 c8 01 48 89 45 08 5d 31 c0 89 c2 89 c6 89 c7 e9 cb 88 3b 00 <0f> 0b 48 8b 45 08 a8 01 74 b2 a8 02 75 ae 48 89 c2 48 83 ca 02 f0\nRSP: 0018:ffffb26387773da8 EFLAGS: 00010282\nRAX: 0000000000000000 RBX: ffffa08b658af900 RCX: 0000000000000001\nRDX: 0000000000000000 RSI: ff886bc5e1366f2f RDI: 0000000000000000\nRBP: ffffa08b658af940 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000000 R12: ffffa0a9bfb31540\nR13: ffffa0a9bfb37900 R14: 0000000000000000 R15: ffffa0a9bfb37905\nFS:  0000000000000000(0000) GS:ffffa0a9bfb00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000055a45ed814e8 CR3: 000000109038a000 CR4: 0000000000350ee0\nCall Trace:\n <TASK>\n ? show_trace_log_lvl+0x1d6/0x2f9\n ? show_trace_log_lvl+0x1d6/0x2f9\n ? mlx5_devcom_for_each_peer_begin+0x29/0x60 [mlx5_core]\n ? down_read+0x75/0x94\n ? __warn+0x80/0x113\n ? down_read+0x75/0x94\n ? report_bug+0xa4/0x11d\n ? handle_bug+0x35/0x8b\n ? exc_invalid_op+0x14/0x75\n ? asm_exc_invalid_op+0x16/0x1b\n ? down_read+0x75/0x94\n ? down_read+0xe/0x94\n mlx5_devcom_for_each_peer_begin+0x29/0x60 [mlx5_core]\n mlx5_ipsec_fs_roce_tx_destroy+0xb1/0x130 [mlx5_core]\n tx_destroy+0x1b/0xc0 [mlx5_core]\n tx_ft_put+0x53/0xc0 [mlx5_core]\n mlx5e_xfrm_free_state+0x45/0x90 [mlx5_core]\n ___xfrm_state_destroy+0x10f/0x1a2\n xfrm_state_gc_task+0x81/0xa9\n process_one_work+0x1f1/0x3c6\n worker_thread+0x53/0x3e4\n ? process_one_work.cold+0x46/0x3c\n kthread+0x127/0x144\n ? set_kthread_struct+0x60/0x52\n ret_from_fork+0x22/0x2d\n </TASK>\n---[ end trace 5ef7896144d398e1 ]---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2ae52a65a850ded75a94e8d7ec1e09737f4c6509"
          },
          {
            "url": "https://git.kernel.org/stable/c/607e1df7bd47fe91cab85a97f57870a26d066137"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45018",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:06.933",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnetfilter: flowtable: initialise extack before use\nFix missing initialisation of extack in flow offload.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/119be227bc04f5035efa64cb823b8a5ca5e2d1c1"
          },
          {
            "url": "https://git.kernel.org/stable/c/356beb911b63a8cff34cb57f755c2a2d2ee9dec7"
          },
          {
            "url": "https://git.kernel.org/stable/c/7eafeec6be68ebd6140a830ce9ae68ad5b67ec78"
          },
          {
            "url": "https://git.kernel.org/stable/c/c7b760499f7791352b49b11667ed04b23d7f5b0f"
          },
          {
            "url": "https://git.kernel.org/stable/c/e5ceff2196dc633c995afb080f6f44a72cff6e1d"
          },
          {
            "url": "https://git.kernel.org/stable/c/e9767137308daf906496613fd879808a07f006a2"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45019",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:06.990",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/mlx5e: Take state lock during tx timeout reporter\nmlx5e_safe_reopen_channels() requires the state lock taken. The\nreferenced changed in the Fixes tag removed the lock to fix another\nissue. This patch adds it back but at a later point (when calling\nmlx5e_safe_reopen_channels()) to avoid the deadlock referenced in the\nFixes tag.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/03d3734bd692affe4d0e9c9d638f491aaf37411b"
          },
          {
            "url": "https://git.kernel.org/stable/c/8e57e66ecbdd2fddc9fbf3e984b1c523b70e9809"
          },
          {
            "url": "https://git.kernel.org/stable/c/b3b9a87adee97854bcd71057901d46943076267e"
          },
          {
            "url": "https://git.kernel.org/stable/c/e6b5afd30b99b43682a7764e1a74a42fe4d5f4b3"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45020",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:07.050",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbpf: Fix a kernel verifier crash in stacksafe()\nDaniel Hodges reported a kernel verifier crash when playing with sched-ext.\nFurther investigation shows that the crash is due to invalid memory access\nin stacksafe(). More specifically, it is the following code:\n    if (exact != NOT_EXACT &&\n        old->stack[spi].slot_type[i % BPF_REG_SIZE] !=\n        cur->stack[spi].slot_type[i % BPF_REG_SIZE])\n            return false;\nThe 'i' iterates old->allocated_stack.\nIf cur->allocated_stack < old->allocated_stack the out-of-bound\naccess will happen.\nTo fix the issue add 'i >= cur->allocated_stack' check such that if\nthe condition is true, stacksafe() should fail. Otherwise,\ncur->stack[spi].slot_type[i % BPF_REG_SIZE] memory access is legal.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/6e3987ac310c74bb4dd6a2fa8e46702fe505fb2b"
          },
          {
            "url": "https://git.kernel.org/stable/c/7cad3174cc79519bf5f6c4441780264416822c08"
          },
          {
            "url": "https://git.kernel.org/stable/c/bed2eb964c70b780fb55925892a74f26cb590b25"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45021",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:07.103",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmemcg_write_event_control(): fix a user-triggerable oops\nwe are *not* guaranteed that anything past the terminating NUL\nis mapped (let alone initialized with anything sane).",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/046667c4d3196938e992fba0dfcde570aa85cd0e"
          },
          {
            "url": "https://git.kernel.org/stable/c/0fbe2a72e853a1052abe9bc2b7df8ddb102da227"
          },
          {
            "url": "https://git.kernel.org/stable/c/1b37ec85ad95b612307627758c6018cd9d92cca8"
          },
          {
            "url": "https://git.kernel.org/stable/c/21b578f1d599edb87462f11113c5b0fc7a04ac61"
          },
          {
            "url": "https://git.kernel.org/stable/c/43768fa80fd192558737e24ed6548f74554611d7"
          },
          {
            "url": "https://git.kernel.org/stable/c/ad149f5585345e383baa65f1539d816cd715fd3b"
          },
          {
            "url": "https://git.kernel.org/stable/c/f1aa7c509aa766080db7ab3aec2e31b1df09e57c"
          },
          {
            "url": "https://git.kernel.org/stable/c/fa5bfdf6cb5846a00e712d630a43e3cf55ccb411"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45022",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:07.163",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmm/vmalloc: fix page mapping if vm_area_alloc_pages() with high order fallback to order 0\nThe __vmap_pages_range_noflush() assumes its argument pages** contains\npages with the same page shift.  However, since commit e9c3cda4d86e (\"mm,\nvmalloc: fix high order __GFP_NOFAIL allocations\"), if gfp_flags includes\n__GFP_NOFAIL with high order in vm_area_alloc_pages() and page allocation\nfailed for high order, the pages** may contain two different page shifts\n(high order and order-0).  This could lead __vmap_pages_range_noflush() to\nperform incorrect mappings, potentially resulting in memory corruption.\nUsers might encounter this as follows (vmap_allow_huge = true, 2M is for\nPMD_SIZE):\nkvmalloc(2M, __GFP_NOFAIL|GFP_X)\n    __vmalloc_node_range_noprof(vm_flags=VM_ALLOW_HUGE_VMAP)\n        vm_area_alloc_pages(order=9) ---> order-9 allocation failed and fallback to order-0\n            vmap_pages_range()\n                vmap_pages_range_noflush()\n                    __vmap_pages_range_noflush(page_shift = 21) ----> wrong mapping happens\nWe can remove the fallback code because if a high-order allocation fails,\n__vmalloc_node_range_noprof() will retry with order-0.  Therefore, it is\nunnecessary to fallback to order-0 here.  Therefore, fix this by removing\nthe fallback code.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/61ebe5a747da649057c37be1c37eb934b4af79ca"
          },
          {
            "url": "https://git.kernel.org/stable/c/c91618816f4d21fc574d7577a37722adcd4075b2"
          },
          {
            "url": "https://git.kernel.org/stable/c/de7bad86345c43cd040ed43e20d9fad78a3ee59f"
          },
          {
            "url": "https://git.kernel.org/stable/c/fd1ffbb50ef4da5e1378a46616b6d7407dc795da"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45023",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:07.230",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmd/raid1: Fix data corruption for degraded array with slow disk\nread_balance() will avoid reading from slow disks as much as possible,\nhowever, if valid data only lands in slow disks, and a new normal disk\nis still in recovery, unrecovered data can be read:\nraid1_read_request\n read_balance\n  raid1_should_read_first\n  -> return false\n  choose_best_rdev\n  -> normal disk is not recovered, return -1\n  choose_bb_rdev\n  -> missing the checking of recovery, return the normal disk\n -> read unrecovered data\nRoot cause is that the checking of recovery is missing in\nchoose_bb_rdev(). Hence add such checking to fix the problem.\nAlso fix similar problem in choose_slow_rdev().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2febf5fdbf5d9a52ddc3e986971c8609b1582d67"
          },
          {
            "url": "https://git.kernel.org/stable/c/c916ca35308d3187c9928664f9be249b22a3a701"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45024",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:07.290",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmm/hugetlb: fix hugetlb vs. core-mm PT locking\nWe recently made GUP's common page table walking code to also walk hugetlb\nVMAs without most hugetlb special-casing, preparing for the future of\nhaving less hugetlb-specific page table walking code in the codebase. \nTurns out that we missed one page table locking detail: page table locking\nfor hugetlb folios that are not mapped using a single PMD/PUD.\nAssume we have hugetlb folio that spans multiple PTEs (e.g., 64 KiB\nhugetlb folios on arm64 with 4 KiB base page size).  GUP, as it walks the\npage tables, will perform a pte_offset_map_lock() to grab the PTE table\nlock.\nHowever, hugetlb that concurrently modifies these page tables would\nactually grab the mm->page_table_lock: with USE_SPLIT_PTE_PTLOCKS, the\nlocks would differ.  Something similar can happen right now with hugetlb\nfolios that span multiple PMDs when USE_SPLIT_PMD_PTLOCKS.\nThis issue can be reproduced [1], for example triggering:\n[ 3105.936100] ------------[ cut here ]------------\n[ 3105.939323] WARNING: CPU: 31 PID: 2732 at mm/gup.c:142 try_grab_folio+0x11c/0x188\n[ 3105.944634] Modules linked in: [...]\n[ 3105.974841] CPU: 31 PID: 2732 Comm: reproducer Not tainted 6.10.0-64.eln141.aarch64 #1\n[ 3105.980406] Hardware name: QEMU KVM Virtual Machine, BIOS edk2-20240524-4.fc40 05/24/2024\n[ 3105.986185] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[ 3105.991108] pc : try_grab_folio+0x11c/0x188\n[ 3105.994013] lr : follow_page_pte+0xd8/0x430\n[ 3105.996986] sp : ffff80008eafb8f0\n[ 3105.999346] x29: ffff80008eafb900 x28: ffffffe8d481f380 x27: 00f80001207cff43\n[ 3106.004414] x26: 0000000000000001 x25: 0000000000000000 x24: ffff80008eafba48\n[ 3106.009520] x23: 0000ffff9372f000 x22: ffff7a54459e2000 x21: ffff7a546c1aa978\n[ 3106.014529] x20: ffffffe8d481f3c0 x19: 0000000000610041 x18: 0000000000000001\n[ 3106.019506] x17: 0000000000000001 x16: ffffffffffffffff x15: 0000000000000000\n[ 3106.024494] x14: ffffb85477fdfe08 x13: 0000ffff9372ffff x12: 0000000000000000\n[ 3106.029469] x11: 1fffef4a88a96be1 x10: ffff7a54454b5f0c x9 : ffffb854771b12f0\n[ 3106.034324] x8 : 0008000000000000 x7 : ffff7a546c1aa980 x6 : 0008000000000080\n[ 3106.038902] x5 : 00000000001207cf x4 : 0000ffff9372f000 x3 : ffffffe8d481f000\n[ 3106.043420] x2 : 0000000000610041 x1 : 0000000000000001 x0 : 0000000000000000\n[ 3106.047957] Call trace:\n[ 3106.049522]  try_grab_folio+0x11c/0x188\n[ 3106.051996]  follow_pmd_mask.constprop.0.isra.0+0x150/0x2e0\n[ 3106.055527]  follow_page_mask+0x1a0/0x2b8\n[ 3106.058118]  __get_user_pages+0xf0/0x348\n[ 3106.060647]  faultin_page_range+0xb0/0x360\n[ 3106.063651]  do_madvise+0x340/0x598\nLet's make huge_pte_lockptr() effectively use the same PT locks as any\ncore-mm page table walker would.  Add ptep_lockptr() to obtain the PTE\npage table lock using a pte pointer -- unfortunately we cannot convert\npte_lockptr() because virt_to_page() doesn't work with kmap'ed page tables\nwe can have with CONFIG_HIGHPTE.\nHandle CONFIG_PGTABLE_LEVELS correctly by checking in reverse order, such\nthat when e.g., CONFIG_PGTABLE_LEVELS==2 with\nPGDIR_SIZE==P4D_SIZE==PUD_SIZE==PMD_SIZE will work as expected.  Document\nwhy that works.\nThere is one ugly case: powerpc 8xx, whereby we have an 8 MiB hugetlb\nfolio being mapped using two PTE page tables.  While hugetlb wants to take\nthe PMD table lock, core-mm would grab the PTE table lock of one of both\nPTE page tables.  In such corner cases, we have to make sure that both\nlocks match, which is (fortunately!) currently guaranteed for 8xx as it\ndoes not support SMP and consequently doesn't use split PT locks.\n[1] https://lore.kernel.org/all/1bbfcc7f-f222-45a5-ac44-c5a1381c596d@redhat.com/",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/5f75cfbd6bb02295ddaed48adf667b6c828ce07b"
          },
          {
            "url": "https://git.kernel.org/stable/c/7300dadba49e531af2d890ae4e34c9b115384a62"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45025",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:07.440",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nfix bitmap corruption on close_range() with CLOSE_RANGE_UNSHARE\ncopy_fd_bitmaps(new, old, count) is expected to copy the first\ncount/BITS_PER_LONG bits from old->full_fds_bits[] and fill\nthe rest with zeroes.  What it does is copying enough words\n(BITS_TO_LONGS(count/BITS_PER_LONG)), then memsets the rest.\nThat works fine, *if* all bits past the cutoff point are\nclear.  Otherwise we are risking garbage from the last word\nwe'd copied.\nFor most of the callers that is true - expand_fdtable() has\ncount equal to old->max_fds, so there's no open descriptors\npast count, let alone fully occupied words in ->open_fds[],\nwhich is what bits in ->full_fds_bits[] correspond to.\nThe other caller (dup_fd()) passes sane_fdtable_size(old_fdt, max_fds),\nwhich is the smallest multiple of BITS_PER_LONG that covers all\nopened descriptors below max_fds.  In the common case (copying on\nfork()) max_fds is ~0U, so all opened descriptors will be below\nit and we are fine, by the same reasons why the call in expand_fdtable()\nis safe.\nUnfortunately, there is a case where max_fds is less than that\nand where we might, indeed, end up with junk in ->full_fds_bits[] -\nclose_range(from, to, CLOSE_RANGE_UNSHARE) with\n\t* descriptor table being currently shared\n\t* 'to' being above the current capacity of descriptor table\n\t* 'from' being just under some chunk of opened descriptors.\nIn that case we end up with observably wrong behaviour - e.g. spawn\na child with CLONE_FILES, get all descriptors in range 0..127 open,\nthen close_range(64, ~0U, CLOSE_RANGE_UNSHARE) and watch dup(0) ending\nup with descriptor #128, despite #64 being observably not open.\nThe minimally invasive fix would be to deal with that in dup_fd().\nIf this proves to add measurable overhead, we can go that way, but\nlet's try to fix copy_fd_bitmaps() first.\n* new helper: bitmap_copy_and_expand(to, from, bits_to_copy, size).\n* make copy_fd_bitmaps() take the bitmap size in words, rather than\nbits; it's 'count' argument is always a multiple of BITS_PER_LONG,\nso we are not losing any information, and that way we can use the\nsame helper for all three bitmaps - compiler will see that count\nis a multiple of BITS_PER_LONG for the large ones, so it'll generate\nplain memcpy()+memset().\nReproducer added to tools/testing/selftests/core/close_range_test.c",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/5053581fe5dfb09b58c65dd8462bf5dea71f41ff"
          },
          {
            "url": "https://git.kernel.org/stable/c/8cad3b2b3ab81ca55f37405ffd1315bcc2948058"
          },
          {
            "url": "https://git.kernel.org/stable/c/9a2fa1472083580b6c66bdaf291f591e1170123a"
          },
          {
            "url": "https://git.kernel.org/stable/c/c69d18f0ac7060de724511537810f10f29a27958"
          },
          {
            "url": "https://git.kernel.org/stable/c/dd72ae8b0fce9c0bbe9582b9b50820f0407f8d8a"
          },
          {
            "url": "https://git.kernel.org/stable/c/e807487a1d5fd5d941f26578ae826ca815dbfcd6"
          },
          {
            "url": "https://git.kernel.org/stable/c/ee501f827f3db02d4e599afbbc1a7f8b792d05d7"
          },
          {
            "url": "https://git.kernel.org/stable/c/fe5bf14881701119aeeda7cf685f3c226c7380df"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45026",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:07.507",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ns390/dasd: fix error recovery leading to data corruption on ESE devices\nExtent Space Efficient (ESE) or thin provisioned volumes need to be\nformatted on demand during usual IO processing.\nThe dasd_ese_needs_format function checks for error codes that signal\nthe non existence of a proper track format.\nThe check for incorrect length is to imprecise since other error cases\nleading to transport of insufficient data also have this flag set.\nThis might lead to data corruption in certain error cases for example\nduring a storage server warmstart.\nFix by removing the check for incorrect length and replacing by\nexplicitly checking for invalid track format in transport mode.\nAlso remove the check for file protected since this is not a valid\nESE handling case.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0a228896a1b3654cd461ff654f6a64e97a9c3246"
          },
          {
            "url": "https://git.kernel.org/stable/c/19f60a55b2fda49bc4f6134a5f6356ef62ee69d8"
          },
          {
            "url": "https://git.kernel.org/stable/c/5d4a304338daf83ace2887aaacafd66fe99ed5cc"
          },
          {
            "url": "https://git.kernel.org/stable/c/7db4042336580dfd75cb5faa82c12cd51098c90b"
          },
          {
            "url": "https://git.kernel.org/stable/c/93a7e2856951680cd7fe6ebd705ac10c8a8a5efd"
          },
          {
            "url": "https://git.kernel.org/stable/c/a665e3b7ac7d5cdc26e00e3d0fc8fd490e00316a"
          },
          {
            "url": "https://git.kernel.org/stable/c/e245a18281c252c8dbc467492e09bb5d4b012118"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45027",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:07.570",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nusb: xhci: Check for xhci->interrupters being allocated in xhci_mem_clearup()\nIf xhci_mem_init() fails, it calls into xhci_mem_cleanup() to mop\nup the damage. If it fails early enough, before xhci->interrupters\nis allocated but after xhci->max_interrupters has been set, which\nhappens in most (all?) cases, things get uglier, as xhci_mem_cleanup()\nunconditionally derefences xhci->interrupters. With prejudice.\nGate the interrupt freeing loop with a check on xhci->interrupters\nbeing non-NULL.\nFound while debugging a DMA allocation issue that led the XHCI driver\non this exact path.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/770cacc75b0091ece17349195d72133912c1ca7c"
          },
          {
            "url": "https://git.kernel.org/stable/c/dcdb52d948f3a17ccd3fce757d9bd981d7c32039"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45028",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:07.647",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmmc: mmc_test: Fix NULL dereference on allocation failure\nIf the \"test->highmem = alloc_pages()\" allocation fails then calling\n__free_pages(test->highmem) will result in a NULL dereference.  Also\nchange the error code to -ENOMEM instead of returning success.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2b507b03991f44dfb202fc2a82c9874d1b1f0c06"
          },
          {
            "url": "https://git.kernel.org/stable/c/3b4e76ceae5b5a46c968bd952f551ce173809f63"
          },
          {
            "url": "https://git.kernel.org/stable/c/9b9ba386d7bfdbc38445932c90fa9444c0524bea"
          },
          {
            "url": "https://git.kernel.org/stable/c/a1e627af32ed60713941cbfc8075d44cad07f6dd"
          },
          {
            "url": "https://git.kernel.org/stable/c/cac2815f49d343b2f0acc4973d2c14918ac3ab0c"
          },
          {
            "url": "https://git.kernel.org/stable/c/e40515582141a9e7c84b269be699c05236a499a6"
          },
          {
            "url": "https://git.kernel.org/stable/c/e97be13a9f51284da450dd2a592e3fa87b49cdc9"
          },
          {
            "url": "https://git.kernel.org/stable/c/ecb15b8ca12c0cbdab81e307e9795214d8b90890"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45029",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:07.717",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ni2c: tegra: Do not mark ACPI devices as irq safe\nOn ACPI machines, the tegra i2c module encounters an issue due to a\nmutex being called inside a spinlock. This leads to the following bug:\n\tBUG: sleeping function called from invalid context at kernel/locking/mutex.c:585\n\t...\n\tCall trace:\n\t__might_sleep\n\t__mutex_lock_common\n\tmutex_lock_nested\n\tacpi_subsys_runtime_resume\n\trpm_resume\n\ttegra_i2c_xfer\nThe problem arises because during __pm_runtime_resume(), the spinlock\n&dev->power.lock is acquired before rpm_resume() is called. Later,\nrpm_resume() invokes acpi_subsys_runtime_resume(), which relies on\nmutexes, triggering the error.\nTo address this issue, devices on ACPI are now marked as not IRQ-safe,\nconsidering the dependency of acpi_subsys_runtime_resume() on mutexes.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/14d069d92951a3e150c0a81f2ca3b93e54da913b"
          },
          {
            "url": "https://git.kernel.org/stable/c/2853e1376d8161b04c9ff18ba82b43f08a049905"
          },
          {
            "url": "https://git.kernel.org/stable/c/6861faf4232e4b78878f2de1ed3ee324ddae2287"
          },
          {
            "url": "https://git.kernel.org/stable/c/a89aef1e6cc43fa019a58080ed05c839e6c77876"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45030",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:07.770",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nigb: cope with large MAX_SKB_FRAGS\nSabrina reports that the igb driver does not cope well with large\nMAX_SKB_FRAG values: setting MAX_SKB_FRAG to 45 causes payload\ncorruption on TX.\nAn easy reproducer is to run ssh to connect to the machine.  With\nMAX_SKB_FRAGS=17 it works, with MAX_SKB_FRAGS=45 it fails.  This has\nbeen reported originally in\nhttps://bugzilla.redhat.com/show_bug.cgi?id=2265320\nThe root cause of the issue is that the driver does not take into\naccount properly the (possibly large) shared info size when selecting\nthe ring layout, and will try to fit two packets inside the same 4K\npage even when the 1st fraglist will trump over the 2nd head.\nAddress the issue by checking if 2K buffers are insufficient.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/8aba27c4a5020abdf60149239198297f88338a8d"
          },
          {
            "url": "https://git.kernel.org/stable/c/8ea80ff5d8298356d28077bc30913ed37df65109"
          },
          {
            "url": "https://git.kernel.org/stable/c/b52bd8bcb9e8ff250c79b44f9af8b15cae8911ab"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46672",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-11T16:15:07.840",
        "lastModified": "2024-09-11T16:26:11.920",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nwifi: brcmfmac: cfg80211: Handle SSID based pmksa deletion\nwpa_supplicant 2.11 sends since 1efdba5fdc2c (\"Handle PMKSA flush in the\ndriver for SAE/OWE offload cases\") SSID based PMKSA del commands.\nbrcmfmac is not prepared and tries to dereference the NULL bssid and\npmkid pointers in cfg80211_pmksa. PMKID_V3 operations support SSID based\nupdates so copy the SSID.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1f566eb912d192c83475a919331aea59619e1197"
          },
          {
            "url": "https://git.kernel.org/stable/c/2ad4e1ada8eebafa2d75a4b75eeeca882de6ada1"
          },
          {
            "url": "https://git.kernel.org/stable/c/4291f94f8c6b01505132c22ee27b59ed27c3584f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-5760",
        "sourceIdentifier": "hp-security-alert@hp.com",
        "published": "2024-09-11T16:15:08.020",
        "lastModified": "2024-09-11T18:35:32.460",
        "baseScore": 8.4,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 2.5,
        "impactScore": 5.9,
        "description": "The Samsung Universal Print Driver for Windows is potentially vulnerable to escalation of privilege allowing the creation of a reverse shell in the tool. This is only applicable for products in the application released or manufactured before 2018.",
        "cweIds": [
          {
            "id": "CWE-269",
            "description": "Improper Privilege Management"
          }
        ],
        "references": [
          {
            "url": "https://support.hp.com/us-en/document/ish_11159589-11159645-16/hpsbpi03970"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-7312",
        "sourceIdentifier": "769c9ae7-73c3-4e47-ae19-903170fc3eb8",
        "published": "2024-09-11T16:15:08.080",
        "lastModified": "2024-09-11T20:15:03.383",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "URL Redirection to Untrusted Site ('Open Redirect') vulnerability in Payara Platform Payara Server (REST Management Interface modules) allows Session Hijacking.This issue affects Payara Server: from 6.0.0 before 6.18.0, from 6.2022.1 before 6.2024.9, from 5.2020.2 before 5.2022.5, from 5.20.0 before 5.67.0, from 4.1.2.191.0 before 4.1.2.191.50.",
        "cweIds": [
          {
            "id": "CWE-601",
            "description": "URL Redirection to Untrusted Site ('Open Redirect')"
          }
        ],
        "references": [
          {
            "url": "https://docs.payara.fish/enterprise/docs/5.67.0/Release%20Notes/Release%20Notes%205.67.0.html"
          },
          {
            "url": "https://docs.payara.fish/enterprise/docs/Release%20Notes/Release%20Notes%206.18.0.html"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-20304",
        "sourceIdentifier": "ykramarz@cisco.com",
        "published": "2024-09-11T17:15:11.853",
        "lastModified": "2024-09-11T17:15:11.853",
        "baseScore": 8.6,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 3.9,
        "impactScore": 4.0,
        "description": "A vulnerability in the multicast traceroute version 2 (Mtrace2) feature of Cisco IOS XR Software could allow an unauthenticated, remote attacker to exhaust the UDP packet memory of an affected device.\nThis vulnerability exists because the Mtrace2 code does not properly handle packet memory. An attacker could exploit this vulnerability by sending crafted packets to an affected device. A successful exploit could allow the attacker to exhaust the incoming UDP packet memory. The affected device would not be able to process higher-level UDP-based protocols packets, possibly causing a denial of service (DoS) condition.\nNote: This vulnerability can be exploited using IPv4 or IPv6.",
        "cweIds": [
          {
            "id": "CWE-401",
            "description": "Missing Release of Memory after Effective Lifetime"
          }
        ],
        "references": [
          {
            "url": "https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-pak-mem-exhst-3ke9FeFy"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-20317",
        "sourceIdentifier": "ykramarz@cisco.com",
        "published": "2024-09-11T17:15:12.043",
        "lastModified": "2024-09-11T17:15:12.043",
        "baseScore": 7.4,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 2.8,
        "impactScore": 4.0,
        "description": "A vulnerability in the handling of specific Ethernet frames by Cisco IOS XR Software for various Cisco Network Convergence System (NCS) platforms could allow an unauthenticated, adjacent attacker to cause critical priority packets to be dropped, resulting in a denial of service (DoS) condition.\nThis vulnerability is due to incorrect classification of certain types of Ethernet frames that are received on an interface. An attacker could exploit this vulnerability by sending specific types of Ethernet frames to or through the affected device. A successful exploit could allow the attacker to cause control plane protocol relationships to fail, resulting in a DoS condition. For more information, see the  section of this advisory.\nCisco has released software updates that address this vulnerability. There are no workarounds that address this vulnerability.",
        "cweIds": [
          {
            "id": "CWE-684",
            "description": "Incorrect Provision of Specified Functionality"
          }
        ],
        "references": [
          {
            "url": "https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-l2services-2mvHdNuC"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-20343",
        "sourceIdentifier": "ykramarz@cisco.com",
        "published": "2024-09-11T17:15:12.223",
        "lastModified": "2024-09-11T17:15:12.223",
        "baseScore": 5.5,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 1.8,
        "impactScore": 3.6,
        "description": "A vulnerability in the CLI of Cisco IOS XR Software could allow an authenticated, local attacker to read any file in the file system of the underlying Linux operating system. The attacker must have valid credentials on the affected device.\nThis vulnerability is due to incorrect validation of the arguments that are passed to a specific CLI command. An attacker could exploit this vulnerability by logging in to an affected device with low-privileged credentials and using the affected command. A successful exploit could allow the attacker access files in read-only mode on the Linux file system.",
        "cweIds": [
          {
            "id": "CWE-284",
            "description": "Improper Access Control"
          }
        ],
        "references": [
          {
            "url": "https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-iosxr-shellutil-HCb278wD"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-20381",
        "sourceIdentifier": "ykramarz@cisco.com",
        "published": "2024-09-11T17:15:12.403",
        "lastModified": "2024-09-11T17:15:12.403",
        "baseScore": 8.8,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 2.8,
        "impactScore": 5.9,
        "description": "A vulnerability in the JSON-RPC API feature in ConfD that is used by the web-based management interfaces of Cisco Crosswork Network Services Orchestrator (NSO), Cisco Optical Site Manager, and Cisco RV340 Dual WAN Gigabit VPN Routers could allow an authenticated, remote attacker to modify the configuration of an affected application or device.\nThis vulnerability is due to improper authorization checks on the API. An attacker with privileges sufficient to access the affected application or device could exploit this vulnerability by sending malicious requests to the JSON-RPC API. A successful exploit could allow the attacker to make unauthorized modifications to the configuration of the affected application or device, including creating new user accounts or elevating their own privileges on an affected system.",
        "cweIds": [
          {
            "id": "CWE-285",
            "description": "Improper Authorization"
          }
        ],
        "references": [
          {
            "url": "https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-nso-auth-bypass-QnTEesp"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-20390",
        "sourceIdentifier": "ykramarz@cisco.com",
        "published": "2024-09-11T17:15:12.613",
        "lastModified": "2024-09-11T17:15:12.613",
        "baseScore": 5.3,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 3.9,
        "impactScore": 1.4,
        "description": "A vulnerability in the Dedicated XML Agent feature of Cisco IOS XR Software could allow an unauthenticated, remote attacker to cause a denial of service (DoS) on XML TCP listen port 38751.\nThis vulnerability is due to a lack of proper error validation of ingress XML packets. An attacker could exploit this vulnerability by sending a sustained, crafted stream of XML traffic to a targeted device. A successful exploit could allow the attacker to cause XML TCP port 38751 to become unreachable while the attack traffic persists.",
        "cweIds": [
          {
            "id": "CWE-940",
            "description": "Improper Verification of Source of a Communication Channel"
          }
        ],
        "references": [
          {
            "url": "https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-iosxr-xml-tcpdos-ZEXvrU2S"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-20398",
        "sourceIdentifier": "ykramarz@cisco.com",
        "published": "2024-09-11T17:15:12.860",
        "lastModified": "2024-09-11T17:15:12.860",
        "baseScore": 8.8,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 2.0,
        "impactScore": 6.0,
        "description": "A vulnerability in the CLI of Cisco IOS XR Software could allow an authenticated, local attacker to obtain read/write file system access on the underlying operating system of an affected device.\nThis vulnerability is due to insufficient validation of user arguments that are passed to specific CLI commands. An attacker with a low-privileged account could exploit this vulnerability by using crafted commands at the prompt. A successful exploit could allow the attacker to elevate privileges to root.",
        "cweIds": [
          {
            "id": "CWE-78",
            "description": "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
          }
        ],
        "references": [
          {
            "url": "https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-iosxr-priv-esc-CrG5vhCq"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-20406",
        "sourceIdentifier": "ykramarz@cisco.com",
        "published": "2024-09-11T17:15:13.040",
        "lastModified": "2024-09-11T17:15:13.040",
        "baseScore": 7.4,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 2.8,
        "impactScore": 4.0,
        "description": "A vulnerability in the segment routing feature for the Intermediate System-to-Intermediate System (IS-IS) protocol of Cisco IOS XR Software could allow an unauthenticated, adjacent attacker to cause a denial of service (DoS) condition on an affected device.\nThis vulnerability is due to insufficient input validation of ingress IS-IS packets. An attacker could exploit this vulnerability by sending specific IS-IS packets to an affected device after forming an adjacency. A successful exploit could allow the attacker to cause the IS-IS process on all affected devices that are participating in the Flexible Algorithm to crash and restart, resulting in a DoS condition.\nNote: The IS-IS protocol is a routing protocol. To exploit this vulnerability, an attacker must be Layer 2-adjacent to the affected device and must have formed an adjacency. This vulnerability affects segment routing for IS-IS over IPv4 and IPv6 control planes as well as devices that are configured as level 1, level 2, or multi-level routing IS-IS type.",
        "cweIds": [
          {
            "id": "CWE-20",
            "description": "Improper Input Validation"
          }
        ],
        "references": [
          {
            "url": "https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-isis-xehpbVNe"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-20483",
        "sourceIdentifier": "ykramarz@cisco.com",
        "published": "2024-09-11T17:15:13.213",
        "lastModified": "2024-09-11T17:15:13.213",
        "baseScore": 7.2,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 1.2,
        "impactScore": 5.9,
        "description": "Multiple vulnerabilities in Cisco Routed PON Controller Software, which runs as a docker container on hardware that is supported by Cisco IOS XR Software, could allow an authenticated, remote attacker with Administrator-level privileges on the PON Manager or direct access to the PON Manager MongoDB instance to perform command injection attacks on the PON Controller container and execute arbitrary commands as root.\nThese vulnerabilities are due to insufficient validation of arguments that are passed to specific configuration commands. An attacker could exploit these vulnerabilities by including crafted input as the argument of an affected configuration command. A successful exploit could allow the attacker to execute arbitrary commands as root on the PON controller.",
        "cweIds": [
          {
            "id": "CWE-78",
            "description": "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
          }
        ],
        "references": [
          {
            "url": "https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-iosxr-ponctlr-ci-OHcHmsFL"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-20489",
        "sourceIdentifier": "ykramarz@cisco.com",
        "published": "2024-09-11T17:15:13.393",
        "lastModified": "2024-09-11T17:15:13.393",
        "baseScore": 8.4,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 2.0,
        "impactScore": 5.8,
        "description": "A vulnerability in the storage method of the PON Controller configuration file could allow an authenticated, local attacker with low privileges to obtain the MongoDB credentials.\nThis vulnerability is due to improper storage of the unencrypted database credentials on the device that is running Cisco IOS XR Software. An attacker could exploit this vulnerability by accessing the configuration files on an affected system. A successful exploit could allow the attacker to view MongoDB credentials.",
        "cweIds": [
          {
            "id": "CWE-256",
            "description": "Plaintext Storage of a Password"
          }
        ],
        "references": [
          {
            "url": "https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-iosxr-ponctlr-ci-OHcHmsFL"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44570",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-09-11T17:15:13.580",
        "lastModified": "2024-09-11T21:35:10.697",
        "baseScore": 8.8,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 2.8,
        "impactScore": 5.9,
        "description": "RELY-PCIe v22.2.1 to v23.1.0 was discovered to contain a code injection vulnerability via the getParams function in phpinf.php.",
        "cweIds": [
          {
            "id": "CWE-77",
            "description": "Improper Neutralization of Special Elements used in a Command ('Command Injection')"
          }
        ],
        "references": [
          {
            "url": "http://system-on-chip.com"
          },
          {
            "url": "https://www.relyum.com/web/support/vulnerability-report/"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44571",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-09-11T17:15:13.630",
        "lastModified": "2024-09-11T21:35:11.500",
        "baseScore": 8.8,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 2.8,
        "impactScore": 5.9,
        "description": "RELY-PCIe v22.2.1 to v23.1.0 was discovered to contain incorrect access control in the mService function at phpinf.php.",
        "cweIds": [
          {
            "id": "CWE-284",
            "description": "Improper Access Control"
          }
        ],
        "references": [
          {
            "url": "http://system-on-chip.com"
          },
          {
            "url": "https://www.relyum.com/web/support/vulnerability-report/"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44572",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-09-11T17:15:13.677",
        "lastModified": "2024-09-11T21:35:12.387",
        "baseScore": 8.8,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 2.8,
        "impactScore": 5.9,
        "description": "RELY-PCIe v22.2.1 to v23.1.0 was discovered to contain a command injection vulnerability via the sys_mgmt function.",
        "cweIds": [
          {
            "id": "CWE-77",
            "description": "Improper Neutralization of Special Elements used in a Command ('Command Injection')"
          }
        ],
        "references": [
          {
            "url": "http://system-on-chip.com"
          },
          {
            "url": "https://www.relyum.com/web/support/vulnerability-report/"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44573",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-09-11T17:15:13.727",
        "lastModified": "2024-09-11T17:15:13.727",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "A stored cross-site scripting (XSS) vulnerability in the VLAN configuration of RELY-PCIe v22.2.1 to v23.1.0 allows attackers to execute arbitrary web scripts or HTML via a crafted payload.",
        "cweIds": null,
        "references": [
          {
            "url": "http://system-on-chip.com"
          },
          {
            "url": "https://www.relyum.com/web/support/vulnerability-report/"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44574",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-09-11T17:15:13.770",
        "lastModified": "2024-09-11T20:35:12.833",
        "baseScore": 8.8,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 2.8,
        "impactScore": 5.9,
        "description": "RELY-PCIe v22.2.1 to v23.1.0 was discovered to contain a command injection vulnerability via the sys_conf function.",
        "cweIds": [
          {
            "id": "CWE-77",
            "description": "Improper Neutralization of Special Elements used in a Command ('Command Injection')"
          }
        ],
        "references": [
          {
            "url": "http://system-on-chip.com"
          },
          {
            "url": "https://www.relyum.com/web/support/vulnerability-report/"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44575",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-09-11T17:15:13.820",
        "lastModified": "2024-09-11T17:15:13.820",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "RELY-PCIe v22.2.1 to v23.1.0 does not set the Secure attribute for sensitive cookies in HTTPS sessions, which could cause the user agent to send those cookies in cleartext over an HTTP session.",
        "cweIds": null,
        "references": [
          {
            "url": "http://system-on-chip.com"
          },
          {
            "url": "https://www.relyum.com/web/support/vulnerability-report/"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44577",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-09-11T17:15:13.870",
        "lastModified": "2024-09-11T20:35:13.697",
        "baseScore": 8.8,
        "baseSeverity": "HIGH",
        "exploitabilityScore": 2.8,
        "impactScore": 5.9,
        "description": "RELY-PCIe v22.2.1 to v23.1.0 was discovered to contain a command injection vulnerability via the time_date function.",
        "cweIds": [
          {
            "id": "CWE-77",
            "description": "Improper Neutralization of Special Elements used in a Command ('Command Injection')"
          }
        ],
        "references": [
          {
            "url": "http://system-on-chip.com"
          },
          {
            "url": "https://www.relyum.com/web/support/vulnerability-report/"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-8097",
        "sourceIdentifier": "769c9ae7-73c3-4e47-ae19-903170fc3eb8",
        "published": "2024-09-11T17:15:13.917",
        "lastModified": "2024-09-11T17:15:13.917",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "Exposure of Sensitive Information to an Unauthorized Actor vulnerability in Payara Platform Payara Server (Logging modules) allows Sensitive credentials posted in plain-text on the server log.This issue affects Payara Server: from 6.0.0 before 6.18.0, from 6.2022.1 before 6.2024.9, from 5.20.0 before 5.67.0, from 5.2020.2 before 5.2022.5, from 4.1.2.191.0 before 4.1.2.191.50.",
        "cweIds": [
          {
            "id": "CWE-200",
            "description": "Exposure of Sensitive Information to an Unauthorized Actor"
          }
        ],
        "references": [
          {
            "url": "https://docs.payara.fish/community/docs/Release%20Notes/Release%20Notes%206.2024.9.html"
          },
          {
            "url": "https://docs.payara.fish/enterprise/docs/Release%20Notes/Release%20Notes%206.18.0.html"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-8686",
        "sourceIdentifier": "psirt@paloaltonetworks.com",
        "published": "2024-09-11T17:15:14.033",
        "lastModified": "2024-09-11T17:15:14.033",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "A command injection vulnerability in Palo Alto Networks PAN-OS software enables an authenticated administrator to bypass system restrictions and run arbitrary commands as root on the firewall.",
        "cweIds": [
          {
            "id": "CWE-78",
            "description": "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
          }
        ],
        "references": [
          {
            "url": "https://security.paloaltonetworks.com/CVE-2024-8686"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-8687",
        "sourceIdentifier": "psirt@paloaltonetworks.com",
        "published": "2024-09-11T17:15:14.157",
        "lastModified": "2024-09-11T17:15:14.157",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "An information exposure vulnerability exists in Palo Alto Networks PAN-OS software that enables a GlobalProtect end user to learn both the configured GlobalProtect uninstall password and the configured disable or disconnect passcode. After the password or passcode is known, end users can uninstall, disable, or disconnect GlobalProtect even if the GlobalProtect app configuration would not normally permit them to do so.",
        "cweIds": [
          {
            "id": "CWE-497",
            "description": "Exposure of Sensitive System Information to an Unauthorized Control Sphere"
          }
        ],
        "references": [
          {
            "url": "https://security.paloaltonetworks.com/CVE-2024-8687"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-8688",
        "sourceIdentifier": "psirt@paloaltonetworks.com",
        "published": "2024-09-11T17:15:14.273",
        "lastModified": "2024-09-11T17:15:14.273",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "An improper neutralization of matching symbols vulnerability in the Palo Alto Networks PAN-OS command line interface (CLI) enables authenticated administrators (including read-only administrators) with access to the CLI to to read arbitrary files on the firewall.",
        "cweIds": [
          {
            "id": "CWE-155",
            "description": "Improper Neutralization of Wildcards or Matching Symbols"
          }
        ],
        "references": [
          {
            "url": "https://security.paloaltonetworks.com/CVE-2024-8688"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-8689",
        "sourceIdentifier": "psirt@paloaltonetworks.com",
        "published": "2024-09-11T17:15:14.380",
        "lastModified": "2024-09-11T17:15:14.380",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "A problem with the ActiveMQ integration for both Cortex XSOAR and Cortex XSIAM can result in the cleartext exposure of the configured ActiveMQ credentials in log bundles.",
        "cweIds": [
          {
            "id": "CWE-312",
            "description": "Cleartext Storage of Sensitive Information"
          }
        ],
        "references": [
          {
            "url": "https://security.paloaltonetworks.com/CVE-2024-8689"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-8690",
        "sourceIdentifier": "psirt@paloaltonetworks.com",
        "published": "2024-09-11T17:15:14.487",
        "lastModified": "2024-09-11T17:15:14.487",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "A problem with a detection mechanism in the Palo Alto Networks Cortex XDR agent on Windows devices enables a user with Windows administrator privileges to disable the agent. This issue may be leveraged by malware to disable the Cortex XDR agent and then to perform malicious activity.",
        "cweIds": [
          {
            "id": "CWE-440",
            "description": "Expected Behavior Violation"
          }
        ],
        "references": [
          {
            "url": "https://security.paloaltonetworks.com/CVE-2024-8690"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-8691",
        "sourceIdentifier": "psirt@paloaltonetworks.com",
        "published": "2024-09-11T17:15:14.587",
        "lastModified": "2024-09-11T17:15:14.587",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "A vulnerability in the GlobalProtect portal in Palo Alto Networks PAN-OS software enables a malicious authenticated GlobalProtect user to impersonate another GlobalProtect user. Active GlobalProtect users impersonated by an attacker who is exploiting this vulnerability are disconnected from GlobalProtect. Upon exploitation, PAN-OS logs indicate that the impersonated user authenticated to GlobalProtect, which hides the identity of the attacker.",
        "cweIds": [
          {
            "id": "CWE-863",
            "description": "Incorrect Authorization"
          }
        ],
        "references": [
          {
            "url": "https://security.paloaltonetworks.com/CVE-2024-8691"
          }
        ]
      }
    }
  ]
}