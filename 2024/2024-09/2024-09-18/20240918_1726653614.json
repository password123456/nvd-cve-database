{
  "totalResults": 68,
  "datePublished": "2024-09-18T19:00:14.197794Z",
  "vulnerabilities": [
    {
      "cve": {
        "id": "CVE-2024-46734",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:02.980",
        "lastModified": "2024-09-18T08:15:02.980",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbtrfs: fix race between direct IO write and fsync when using same fd\nIf we have 2 threads that are using the same file descriptor and one of\nthem is doing direct IO writes while the other is doing fsync, we have a\nrace where we can end up either:\n1) Attempt a fsync without holding the inode's lock, triggering an\n   assertion failures when assertions are enabled;\n2) Do an invalid memory access from the fsync task because the file private\n   points to memory allocated on stack by the direct IO task and it may be\n   used by the fsync task after the stack was destroyed.\nThe race happens like this:\n1) A user space program opens a file descriptor with O_DIRECT;\n2) The program spawns 2 threads using libpthread for example;\n3) One of the threads uses the file descriptor to do direct IO writes,\n   while the other calls fsync using the same file descriptor.\n4) Call task A the thread doing direct IO writes and task B the thread\n   doing fsyncs;\n5) Task A does a direct IO write, and at btrfs_direct_write() sets the\n   file's private to an on stack allocated private with the member\n   'fsync_skip_inode_lock' set to true;\n6) Task B enters btrfs_sync_file() and sees that there's a private\n   structure associated to the file which has 'fsync_skip_inode_lock' set\n   to true, so it skips locking the inode's VFS lock;\n7) Task A completes the direct IO write, and resets the file's private to\n   NULL since it had no prior private and our private was stack allocated.\n   Then it unlocks the inode's VFS lock;\n8) Task B enters btrfs_get_ordered_extents_for_logging(), then the\n   assertion that checks the inode's VFS lock is held fails, since task B\n   never locked it and task A has already unlocked it.\nThe stack trace produced is the following:\n   assertion failed: inode_is_locked(&inode->vfs_inode), in fs/btrfs/ordered-data.c:983\n   ------------[ cut here ]------------\n   kernel BUG at fs/btrfs/ordered-data.c:983!\n   Oops: invalid opcode: 0000 [#1] PREEMPT SMP PTI\n   CPU: 9 PID: 5072 Comm: worker Tainted: G     U     OE      6.10.5-1-default #1 openSUSE Tumbleweed 69f48d427608e1c09e60ea24c6c55e2ca1b049e8\n   Hardware name: Acer Predator PH315-52/Covini_CFS, BIOS V1.12 07/28/2020\n   RIP: 0010:btrfs_get_ordered_extents_for_logging.cold+0x1f/0x42 [btrfs]\n   Code: 50 d6 86 c0 e8 (...)\n   RSP: 0018:ffff9e4a03dcfc78 EFLAGS: 00010246\n   RAX: 0000000000000054 RBX: ffff9078a9868e98 RCX: 0000000000000000\n   RDX: 0000000000000000 RSI: ffff907dce4a7800 RDI: ffff907dce4a7800\n   RBP: ffff907805518800 R08: 0000000000000000 R09: ffff9e4a03dcfb38\n   R10: ffff9e4a03dcfb30 R11: 0000000000000003 R12: ffff907684ae7800\n   R13: 0000000000000001 R14: ffff90774646b600 R15: 0000000000000000\n   FS:  00007f04b96006c0(0000) GS:ffff907dce480000(0000) knlGS:0000000000000000\n   CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n   CR2: 00007f32acbfc000 CR3: 00000001fd4fa005 CR4: 00000000003726f0\n   Call Trace:\n    <TASK>\n    ? __die_body.cold+0x14/0x24\n    ? die+0x2e/0x50\n    ? do_trap+0xca/0x110\n    ? do_error_trap+0x6a/0x90\n    ? btrfs_get_ordered_extents_for_logging.cold+0x1f/0x42 [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]\n    ? exc_invalid_op+0x50/0x70\n    ? btrfs_get_ordered_extents_for_logging.cold+0x1f/0x42 [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]\n    ? asm_exc_invalid_op+0x1a/0x20\n    ? btrfs_get_ordered_extents_for_logging.cold+0x1f/0x42 [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]\n    ? btrfs_get_ordered_extents_for_logging.cold+0x1f/0x42 [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]\n    btrfs_sync_file+0x21a/0x4d0 [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]\n    ? __seccomp_filter+0x31d/0x4f0\n    __x64_sys_fdatasync+0x4f/0x90\n    do_syscall_64+0x82/0x160\n    ? do_futex+0xcb/0x190\n    ? __x64_sys_futex+0x10e/0x1d0\n    ? switch_fpu_return+0x4f/0xd0\n    ? syscall_exit_to_user_mode+0x72/0x220\n    ? do_syscall_64+0x8e/0x160\n    ? syscall_exit_to_user_mod\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/01681aa609b5f110502f56c4e3b2938efcf4a5bc"
          },
          {
            "url": "https://git.kernel.org/stable/c/7b5595f33c3c273613b590892a578d78186bb400"
          },
          {
            "url": "https://git.kernel.org/stable/c/cd3087582e4fa36e89be4e6f859e75a4400292b4"
          },
          {
            "url": "https://git.kernel.org/stable/c/cd9253c23aedd61eb5ff11f37a36247cd46faf86"
          },
          {
            "url": "https://git.kernel.org/stable/c/d116a0b0e02f395cedfb8c725bd67480aa7c428c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46735",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:03.057",
        "lastModified": "2024-09-18T08:15:03.057",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nublk_drv: fix NULL pointer dereference in ublk_ctrl_start_recovery()\nWhen two UBLK_CMD_START_USER_RECOVERY commands are submitted, the\nfirst one sets 'ubq->ubq_daemon' to NULL, and the second one triggers\nWARN in ublk_queue_reinit() and subsequently a NULL pointer dereference\nissue.\nFix it by adding the check in ublk_ctrl_start_recovery() and return\nimmediately in case of zero 'ub->nr_queues_ready'.\n  BUG: kernel NULL pointer dereference, address: 0000000000000028\n  RIP: 0010:ublk_ctrl_start_recovery.constprop.0+0x82/0x180\n  Call Trace:\n   <TASK>\n   ? __die+0x20/0x70\n   ? page_fault_oops+0x75/0x170\n   ? exc_page_fault+0x64/0x140\n   ? asm_exc_page_fault+0x22/0x30\n   ? ublk_ctrl_start_recovery.constprop.0+0x82/0x180\n   ublk_ctrl_uring_cmd+0x4f7/0x6c0\n   ? pick_next_task_idle+0x26/0x40\n   io_uring_cmd+0x9a/0x1b0\n   io_issue_sqe+0x193/0x3f0\n   io_wq_submit_work+0x9b/0x390\n   io_worker_handle_work+0x165/0x360\n   io_wq_worker+0xcb/0x2f0\n   ? finish_task_switch.isra.0+0x203/0x290\n   ? finish_task_switch.isra.0+0x203/0x290\n   ? __pfx_io_wq_worker+0x10/0x10\n   ret_from_fork+0x2d/0x50\n   ? __pfx_io_wq_worker+0x10/0x10\n   ret_from_fork_asm+0x1a/0x30\n   </TASK>",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/136a29d8112df4ea0a57f9602ddf3579e04089dc"
          },
          {
            "url": "https://git.kernel.org/stable/c/7c890ef60bf417d3fe5c6f7a9f6cef0e1d77f74f"
          },
          {
            "url": "https://git.kernel.org/stable/c/ca249435893dda766f3845c15ca77ca5672022d8"
          },
          {
            "url": "https://git.kernel.org/stable/c/e58f5142f88320a5b1449f96a146f2f24615c5c7"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46736",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:03.113",
        "lastModified": "2024-09-18T08:15:03.113",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nsmb: client: fix double put of @cfile in smb2_rename_path()\nIf smb2_set_path_attr() is called with a valid @cfile and returned\n-EINVAL, we need to call cifs_get_writable_path() again as the\nreference of @cfile was already dropped by previous smb2_compound_op()\ncall.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1a46c7f6546b73cbf36f5a618a1a6bbb45391eb3"
          },
          {
            "url": "https://git.kernel.org/stable/c/3523a3df03c6f04f7ea9c2e7050102657e331a4f"
          },
          {
            "url": "https://git.kernel.org/stable/c/b27ea9c96efd2c252a981fb00d0f001b86c90f3e"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46737",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:03.167",
        "lastModified": "2024-09-18T08:15:03.167",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnvmet-tcp: fix kernel crash if commands allocation fails\nIf the commands allocation fails in nvmet_tcp_alloc_cmds()\nthe kernel crashes in nvmet_tcp_release_queue_work() because of\na NULL pointer dereference.\n  nvmet: failed to install queue 0 cntlid 1 ret 6\n  Unable to handle kernel NULL pointer dereference at\n         virtual address 0000000000000008\nFix the bug by setting queue->nr_cmds to zero in case\nnvmet_tcp_alloc_cmd() fails.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/03e1fd0327fa5e2174567f5fe9290fe21d21b8f4"
          },
          {
            "url": "https://git.kernel.org/stable/c/489f2913a63f528cfe3f21722583fb981967ecda"
          },
          {
            "url": "https://git.kernel.org/stable/c/50632b877ce55356f5d276b9add289b1e7ddc683"
          },
          {
            "url": "https://git.kernel.org/stable/c/5572a55a6f830ee3f3a994b6b962a5c327d28cb3"
          },
          {
            "url": "https://git.kernel.org/stable/c/6c04d1e3ab22cc5394ef656429638a5947f87244"
          },
          {
            "url": "https://git.kernel.org/stable/c/7957c731fc2b23312f8935812dee5a0b14b04e2d"
          },
          {
            "url": "https://git.kernel.org/stable/c/91dad30c5607e62864f888e735d0965567827bdf"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46738",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:03.233",
        "lastModified": "2024-09-18T08:15:03.233",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nVMCI: Fix use-after-free when removing resource in vmci_resource_remove()\nWhen removing a resource from vmci_resource_table in\nvmci_resource_remove(), the search is performed using the resource\nhandle by comparing context and resource fields.\nIt is possible though to create two resources with different types\nbut same handle (same context and resource fields).\nWhen trying to remove one of the resources, vmci_resource_remove()\nmay not remove the intended one, but the object will still be freed\nas in the case of the datagram type in vmci_datagram_destroy_handle().\nvmci_resource_table will still hold a pointer to this freed resource\nleading to a use-after-free vulnerability.\nBUG: KASAN: use-after-free in vmci_handle_is_equal include/linux/vmw_vmci_defs.h:142 [inline]\nBUG: KASAN: use-after-free in vmci_resource_remove+0x3a1/0x410 drivers/misc/vmw_vmci/vmci_resource.c:147\nRead of size 4 at addr ffff88801c16d800 by task syz-executor197/1592\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x82/0xa9 lib/dump_stack.c:106\n print_address_description.constprop.0+0x21/0x366 mm/kasan/report.c:239\n __kasan_report.cold+0x7f/0x132 mm/kasan/report.c:425\n kasan_report+0x38/0x51 mm/kasan/report.c:442\n vmci_handle_is_equal include/linux/vmw_vmci_defs.h:142 [inline]\n vmci_resource_remove+0x3a1/0x410 drivers/misc/vmw_vmci/vmci_resource.c:147\n vmci_qp_broker_detach+0x89a/0x11b9 drivers/misc/vmw_vmci/vmci_queue_pair.c:2182\n ctx_free_ctx+0x473/0xbe1 drivers/misc/vmw_vmci/vmci_context.c:444\n kref_put include/linux/kref.h:65 [inline]\n vmci_ctx_put drivers/misc/vmw_vmci/vmci_context.c:497 [inline]\n vmci_ctx_destroy+0x170/0x1d6 drivers/misc/vmw_vmci/vmci_context.c:195\n vmci_host_close+0x125/0x1ac drivers/misc/vmw_vmci/vmci_host.c:143\n __fput+0x261/0xa34 fs/file_table.c:282\n task_work_run+0xf0/0x194 kernel/task_work.c:164\n tracehook_notify_resume include/linux/tracehook.h:189 [inline]\n exit_to_user_mode_loop+0x184/0x189 kernel/entry/common.c:187\n exit_to_user_mode_prepare+0x11b/0x123 kernel/entry/common.c:220\n __syscall_exit_to_user_mode_work kernel/entry/common.c:302 [inline]\n syscall_exit_to_user_mode+0x18/0x42 kernel/entry/common.c:313\n do_syscall_64+0x41/0x85 arch/x86/entry/common.c:86\n entry_SYSCALL_64_after_hwframe+0x6e/0x0\nThis change ensures the type is also checked when removing\nthe resource from vmci_resource_table in vmci_resource_remove().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/00fe5292f081f8d773e572df8e03bf6e1855fe49"
          },
          {
            "url": "https://git.kernel.org/stable/c/39e7e593418ccdbd151f2925fa6be1a616d16c96"
          },
          {
            "url": "https://git.kernel.org/stable/c/48b9a8dabcc3cf5f961b2ebcd8933bf9204babb7"
          },
          {
            "url": "https://git.kernel.org/stable/c/6c563a29857aa8053b67ee141191f69757f27f6e"
          },
          {
            "url": "https://git.kernel.org/stable/c/b243d52b5f6f59f9d39e69b191fb3d58b94a43b1"
          },
          {
            "url": "https://git.kernel.org/stable/c/b9efdf333174468651be40390cbc79c9f55d9cce"
          },
          {
            "url": "https://git.kernel.org/stable/c/ef5f4d0c5ee22d4f873116fec844ff6edaf3fa7d"
          },
          {
            "url": "https://git.kernel.org/stable/c/f6365931bf7c07b2b397dbb06a4f6573cc9fae73"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46739",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:03.293",
        "lastModified": "2024-09-18T08:15:03.293",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nuio_hv_generic: Fix kernel NULL pointer dereference in hv_uio_rescind\nFor primary VM Bus channels, primary_channel pointer is always NULL. This\npointer is valid only for the secondary channels. Also, rescind callback\nis meant for primary channels only.\nFix NULL pointer dereference by retrieving the device_obj from the parent\nfor the primary channel.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1d8e020e51ab07e40f9dd00b52f1da7d96fec04c"
          },
          {
            "url": "https://git.kernel.org/stable/c/2be373469be1774bbe03b0fa7e2854e65005b1cc"
          },
          {
            "url": "https://git.kernel.org/stable/c/3005091cd537ef8cdb7530dcb2ecfba8d2ef475c"
          },
          {
            "url": "https://git.kernel.org/stable/c/3d414b64ecf6fd717d7510ffb893c6f23acbf50e"
          },
          {
            "url": "https://git.kernel.org/stable/c/928e399e84f4e80307dce44e89415115c473275b"
          },
          {
            "url": "https://git.kernel.org/stable/c/de6946be9c8bc7d2279123433495af7c21011b99"
          },
          {
            "url": "https://git.kernel.org/stable/c/f38f46da80a2ab7d1b2f8fcb444c916034a2dac4"
          },
          {
            "url": "https://git.kernel.org/stable/c/fb1adbd7e50f3d2de56d0a2bb0700e2e819a329e"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46740",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:03.377",
        "lastModified": "2024-09-18T08:15:03.377",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbinder: fix UAF caused by offsets overwrite\nBinder objects are processed and copied individually into the target\nbuffer during transactions. Any raw data in-between these objects is\ncopied as well. However, this raw data copy lacks an out-of-bounds\ncheck. If the raw data exceeds the data section size then the copy\noverwrites the offsets section. This eventually triggers an error that\nattempts to unwind the processed objects. However, at this point the\noffsets used to index these objects are now corrupted.\nUnwinding with corrupted offsets can result in decrements of arbitrary\nnodes and lead to their premature release. Other users of such nodes are\nleft with a dangling pointer triggering a use-after-free. This issue is\nmade evident by the following KASAN report (trimmed):\n  ==================================================================\n  BUG: KASAN: slab-use-after-free in _raw_spin_lock+0xe4/0x19c\n  Write of size 4 at addr ffff47fc91598f04 by task binder-util/743\n  CPU: 9 UID: 0 PID: 743 Comm: binder-util Not tainted 6.11.0-rc4 #1\n  Hardware name: linux,dummy-virt (DT)\n  Call trace:\n   _raw_spin_lock+0xe4/0x19c\n   binder_free_buf+0x128/0x434\n   binder_thread_write+0x8a4/0x3260\n   binder_ioctl+0x18f0/0x258c\n  [...]\n  Allocated by task 743:\n   __kmalloc_cache_noprof+0x110/0x270\n   binder_new_node+0x50/0x700\n   binder_transaction+0x413c/0x6da8\n   binder_thread_write+0x978/0x3260\n   binder_ioctl+0x18f0/0x258c\n  [...]\n  Freed by task 745:\n   kfree+0xbc/0x208\n   binder_thread_read+0x1c5c/0x37d4\n   binder_ioctl+0x16d8/0x258c\n  [...]\n  ==================================================================\nTo avoid this issue, let's check that the raw data copy is within the\nboundaries of the data section.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/109e845c1184c9f786d41516348ba3efd9112792"
          },
          {
            "url": "https://git.kernel.org/stable/c/1f33d9f1d9ac3f0129f8508925000900c2fe5bb0"
          },
          {
            "url": "https://git.kernel.org/stable/c/3a8154bb4ab4a01390a3abf1e6afac296e037da4"
          },
          {
            "url": "https://git.kernel.org/stable/c/4df153652cc46545722879415937582028c18af5"
          },
          {
            "url": "https://git.kernel.org/stable/c/4f79e0b80dc69bd5eaaed70f0df1b558728b4e59"
          },
          {
            "url": "https://git.kernel.org/stable/c/5a32bfd23022ffa7e152f273fa3fa29befb7d929"
          },
          {
            "url": "https://git.kernel.org/stable/c/eef79854a04feac5b861f94d7b19cbbe79874117"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46741",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:03.430",
        "lastModified": "2024-09-18T08:15:03.430",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmisc: fastrpc: Fix double free of 'buf' in error path\nsmatch warning:\ndrivers/misc/fastrpc.c:1926 fastrpc_req_mmap() error: double free of 'buf'\nIn fastrpc_req_mmap() error path, the fastrpc buffer is freed in\nfastrpc_req_munmap_impl() if unmap is successful.\nBut in the end, there is an unconditional call to fastrpc_buf_free().\nSo the above case triggers the double free of fastrpc buf.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/bfc1704d909dc9911a558b1a5833d3d61a43a1f2"
          },
          {
            "url": "https://git.kernel.org/stable/c/e8c276d4dc0e19ee48385f74426aebc855b49aaf"
          },
          {
            "url": "https://git.kernel.org/stable/c/f77dc8a75859e559f3238a6d906206259227985e"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46742",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:03.480",
        "lastModified": "2024-09-18T08:15:03.480",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nsmb/server: fix potential null-ptr-deref of lease_ctx_info in smb2_open()\nnull-ptr-deref will occur when (req_op_level == SMB2_OPLOCK_LEVEL_LEASE)\nand parse_lease_state() return NULL.\nFix this by check if 'lease_ctx_info' is NULL.\nAdditionally, remove the redundant parentheses in\nparse_durable_handle_context().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/07f384c5be1f8633b13f0a22616e227570450bc6"
          },
          {
            "url": "https://git.kernel.org/stable/c/3b692794b81f2ecad69a4adbba687f3836824ada"
          },
          {
            "url": "https://git.kernel.org/stable/c/4e8771a3666c8f216eefd6bd2fd50121c6c437db"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46743",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:03.540",
        "lastModified": "2024-09-18T08:15:03.540",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nof/irq: Prevent device address out-of-bounds read in interrupt map walk\nWhen of_irq_parse_raw() is invoked with a device address smaller than\nthe interrupt parent node (from #address-cells property), KASAN detects\nthe following out-of-bounds read when populating the initial match table\n(dyndbg=\"func of_irq_parse_* +p\"):\n  OF: of_irq_parse_one: dev=/soc@0/picasso/watchdog, index=0\n  OF:  parent=/soc@0/pci@878000000000/gpio0@17,0, intsize=2\n  OF:  intspec=4\n  OF: of_irq_parse_raw: ipar=/soc@0/pci@878000000000/gpio0@17,0, size=2\n  OF:  -> addrsize=3\n  ==================================================================\n  BUG: KASAN: slab-out-of-bounds in of_irq_parse_raw+0x2b8/0x8d0\n  Read of size 4 at addr ffffff81beca5608 by task bash/764\n  CPU: 1 PID: 764 Comm: bash Tainted: G           O       6.1.67-484c613561-nokia_sm_arm64 #1\n  Hardware name: Unknown Unknown Product/Unknown Product, BIOS 2023.01-12.24.03-dirty 01/01/2023\n  Call trace:\n   dump_backtrace+0xdc/0x130\n   show_stack+0x1c/0x30\n   dump_stack_lvl+0x6c/0x84\n   print_report+0x150/0x448\n   kasan_report+0x98/0x140\n   __asan_load4+0x78/0xa0\n   of_irq_parse_raw+0x2b8/0x8d0\n   of_irq_parse_one+0x24c/0x270\n   parse_interrupts+0xc0/0x120\n   of_fwnode_add_links+0x100/0x2d0\n   fw_devlink_parse_fwtree+0x64/0xc0\n   device_add+0xb38/0xc30\n   of_device_add+0x64/0x90\n   of_platform_device_create_pdata+0xd0/0x170\n   of_platform_bus_create+0x244/0x600\n   of_platform_notify+0x1b0/0x254\n   blocking_notifier_call_chain+0x9c/0xd0\n   __of_changeset_entry_notify+0x1b8/0x230\n   __of_changeset_apply_notify+0x54/0xe4\n   of_overlay_fdt_apply+0xc04/0xd94\n   ...\n  The buggy address belongs to the object at ffffff81beca5600\n   which belongs to the cache kmalloc-128 of size 128\n  The buggy address is located 8 bytes inside of\n   128-byte region [ffffff81beca5600, ffffff81beca5680)\n  The buggy address belongs to the physical page:\n  page:00000000230d3d03 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1beca4\n  head:00000000230d3d03 order:1 compound_mapcount:0 compound_pincount:0\n  flags: 0x8000000000010200(slab|head|zone=2)\n  raw: 8000000000010200 0000000000000000 dead000000000122 ffffff810000c300\n  raw: 0000000000000000 0000000000200020 00000001ffffffff 0000000000000000\n  page dumped because: kasan: bad access detected\n  Memory state around the buggy address:\n   ffffff81beca5500: 04 fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n   ffffff81beca5580: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n  >ffffff81beca5600: 00 fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n                        ^\n   ffffff81beca5680: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n   ffffff81beca5700: 00 00 00 00 00 00 fc fc fc fc fc fc fc fc fc fc\n  ==================================================================\n  OF:  -> got it !\nPrevent the out-of-bounds read by copying the device address into a\nbuffer of sufficient size.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/7ead730af11ee7da107f16fc77995613c58d292d"
          },
          {
            "url": "https://git.kernel.org/stable/c/8ff351ea12e918db1373b915c4c268815929cbe5"
          },
          {
            "url": "https://git.kernel.org/stable/c/9d1e9f0876b03d74d44513a0ed3ed15ef8f2fed5"
          },
          {
            "url": "https://git.kernel.org/stable/c/b739dffa5d570b411d4bdf4bb9b8dfd6b7d72305"
          },
          {
            "url": "https://git.kernel.org/stable/c/baaf26723beab3a04da578d3008be3544f83758f"
          },
          {
            "url": "https://git.kernel.org/stable/c/bf68acd840b6a5bfd3777e0d5aaa204db6b461a9"
          },
          {
            "url": "https://git.kernel.org/stable/c/d2a79494d8a5262949736fb2c3ac44d20a51b0d8"
          },
          {
            "url": "https://git.kernel.org/stable/c/defcaa426ba0bc89ffdafb799d2e50b52f74ffc4"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46744",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:03.603",
        "lastModified": "2024-09-18T08:15:03.603",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nSquashfs: sanity check symbolic link size\nSyzkiller reports a \"KMSAN: uninit-value in pick_link\" bug.\nThis is caused by an uninitialised page, which is ultimately caused\nby a corrupted symbolic link size read from disk.\nThe reason why the corrupted symlink size causes an uninitialised\npage is due to the following sequence of events:\n1. squashfs_read_inode() is called to read the symbolic\n   link from disk.  This assigns the corrupted value\n   3875536935 to inode->i_size.\n2. Later squashfs_symlink_read_folio() is called, which assigns\n   this corrupted value to the length variable, which being a\n   signed int, overflows producing a negative number.\n3. The following loop that fills in the page contents checks that\n   the copied bytes is less than length, which being negative means\n   the loop is skipped, producing an uninitialised page.\nThis patch adds a sanity check which checks that the symbolic\nlink size is not larger than expected.\n--\nV2: fix spelling mistake.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/087f25b2d36adae19951114ffcbb7106ed405ebb"
          },
          {
            "url": "https://git.kernel.org/stable/c/1b9451ba6f21478a75288ea3e3fca4be35e2a438"
          },
          {
            "url": "https://git.kernel.org/stable/c/5c8906de98d0d7ad42ff3edf2cb6cd7e0ea658c4"
          },
          {
            "url": "https://git.kernel.org/stable/c/810ee43d9cd245d138a2733d87a24858a23f577d"
          },
          {
            "url": "https://git.kernel.org/stable/c/c3af7e460a526007e4bed1ce3623274a1a6afe5e"
          },
          {
            "url": "https://git.kernel.org/stable/c/ef4e249971eb77ec33d74c5c3de1e2576faf6c90"
          },
          {
            "url": "https://git.kernel.org/stable/c/f82cb7f24032ed023fc67d26ea9bf322d8431a90"
          },
          {
            "url": "https://git.kernel.org/stable/c/fac5e82ab1334fc8ed6ff7183702df634bd1d93d"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46745",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:03.667",
        "lastModified": "2024-09-18T08:15:03.667",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nInput: uinput - reject requests with unreasonable number of slots\nWhen exercising uinput interface syzkaller may try setting up device\nwith a really large number of slots, which causes memory allocation\nfailure in input_mt_init_slots(). While this allocation failure is\nhandled properly and request is rejected, it results in syzkaller\nreports. Additionally, such request may put undue burden on the\nsystem which will try to free a lot of memory for a bogus request.\nFix it by limiting allowed number of slots to 100. This can easily\nbe extended if we see devices that can track more than 100 contacts.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/206f533a0a7c683982af473079c4111f4a0f9f5e"
          },
          {
            "url": "https://git.kernel.org/stable/c/51fa08edd80003db700bdaa099385c5900d27f4b"
          },
          {
            "url": "https://git.kernel.org/stable/c/597ff930296c4c8fc6b6a536884d4f1a7187ec70"
          },
          {
            "url": "https://git.kernel.org/stable/c/61df76619e270a46fd427fbdeb670ad491c42de2"
          },
          {
            "url": "https://git.kernel.org/stable/c/9719687398dea8a6a12a10321a54dd75eec7ab2d"
          },
          {
            "url": "https://git.kernel.org/stable/c/9c6d189f0c1c59ba9a32326ec82a0b367a3cd47b"
          },
          {
            "url": "https://git.kernel.org/stable/c/a4858b00a1ec57043697fb935565fe267f161833"
          },
          {
            "url": "https://git.kernel.org/stable/c/d76fc0f0b18d49b7e721c9e4975ef4bffde2f3e7"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46746",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:03.730",
        "lastModified": "2024-09-18T08:15:03.730",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nHID: amd_sfh: free driver_data after destroying hid device\nHID driver callbacks aren't called anymore once hid_destroy_device() has\nbeen called. Hence, hid driver_data should be freed only after the\nhid_destroy_device() function returned as driver_data is used in several\ncallbacks.\nI observed a crash with kernel 6.10.0 on my T14s Gen 3, after enabling\nKASAN to debug memory allocation, I got this output:\n  [   13.050438] ==================================================================\n  [   13.054060] BUG: KASAN: slab-use-after-free in amd_sfh_get_report+0x3ec/0x530 [amd_sfh]\n  [   13.054809] psmouse serio1: trackpoint: Synaptics TrackPoint firmware: 0x02, buttons: 3/3\n  [   13.056432] Read of size 8 at addr ffff88813152f408 by task (udev-worker)/479\n  [   13.060970] CPU: 5 PID: 479 Comm: (udev-worker) Not tainted 6.10.0-arch1-2 #1 893bb55d7f0073f25c46adbb49eb3785fefd74b0\n  [   13.063978] Hardware name: LENOVO 21CQCTO1WW/21CQCTO1WW, BIOS R22ET70W (1.40 ) 03/21/2024\n  [   13.067860] Call Trace:\n  [   13.069383] input: TPPS/2 Synaptics TrackPoint as /devices/platform/i8042/serio1/input/input8\n  [   13.071486]  <TASK>\n  [   13.071492]  dump_stack_lvl+0x5d/0x80\n  [   13.074870] snd_hda_intel 0000:33:00.6: enabling device (0000 -> 0002)\n  [   13.078296]  ? amd_sfh_get_report+0x3ec/0x530 [amd_sfh 05f43221435b5205f734cd9da29399130f398a38]\n  [   13.082199]  print_report+0x174/0x505\n  [   13.085776]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10\n  [   13.089367]  ? srso_alias_return_thunk+0x5/0xfbef5\n  [   13.093255]  ? amd_sfh_get_report+0x3ec/0x530 [amd_sfh 05f43221435b5205f734cd9da29399130f398a38]\n  [   13.097464]  kasan_report+0xc8/0x150\n  [   13.101461]  ? amd_sfh_get_report+0x3ec/0x530 [amd_sfh 05f43221435b5205f734cd9da29399130f398a38]\n  [   13.105802]  amd_sfh_get_report+0x3ec/0x530 [amd_sfh 05f43221435b5205f734cd9da29399130f398a38]\n  [   13.110303]  amdtp_hid_request+0xb8/0x110 [amd_sfh 05f43221435b5205f734cd9da29399130f398a38]\n  [   13.114879]  ? srso_alias_return_thunk+0x5/0xfbef5\n  [   13.119450]  sensor_hub_get_feature+0x1d3/0x540 [hid_sensor_hub 3f13be3016ff415bea03008d45d99da837ee3082]\n  [   13.124097]  hid_sensor_parse_common_attributes+0x4d0/0xad0 [hid_sensor_iio_common c3a5cbe93969c28b122609768bbe23efe52eb8f5]\n  [   13.127404]  ? srso_alias_return_thunk+0x5/0xfbef5\n  [   13.131925]  ? __pfx_hid_sensor_parse_common_attributes+0x10/0x10 [hid_sensor_iio_common c3a5cbe93969c28b122609768bbe23efe52eb8f5]\n  [   13.136455]  ? _raw_spin_lock_irqsave+0x96/0xf0\n  [   13.140197]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10\n  [   13.143602]  ? devm_iio_device_alloc+0x34/0x50 [industrialio 3d261d5e5765625d2b052be40e526d62b1d2123b]\n  [   13.147234]  ? srso_alias_return_thunk+0x5/0xfbef5\n  [   13.150446]  ? __devm_add_action+0x167/0x1d0\n  [   13.155061]  hid_gyro_3d_probe+0x120/0x7f0 [hid_sensor_gyro_3d 63da36a143b775846ab2dbb86c343b401b5e3172]\n  [   13.158581]  ? srso_alias_return_thunk+0x5/0xfbef5\n  [   13.161814]  platform_probe+0xa2/0x150\n  [   13.165029]  really_probe+0x1e3/0x8a0\n  [   13.168243]  __driver_probe_device+0x18c/0x370\n  [   13.171500]  driver_probe_device+0x4a/0x120\n  [   13.175000]  __driver_attach+0x190/0x4a0\n  [   13.178521]  ? __pfx___driver_attach+0x10/0x10\n  [   13.181771]  bus_for_each_dev+0x106/0x180\n  [   13.185033]  ? __pfx__raw_spin_lock+0x10/0x10\n  [   13.188229]  ? __pfx_bus_for_each_dev+0x10/0x10\n  [   13.191446]  ? srso_alias_return_thunk+0x5/0xfbef5\n  [   13.194382]  bus_add_driver+0x29e/0x4d0\n  [   13.197328]  driver_register+0x1a5/0x360\n  [   13.200283]  ? __pfx_hid_gyro_3d_platform_driver_init+0x10/0x10 [hid_sensor_gyro_3d 63da36a143b775846ab2dbb86c343b401b5e3172]\n  [   13.203362]  do_one_initcall+0xa7/0x380\n  [   13.206432]  ? __pfx_do_one_initcall+0x10/0x10\n  [   13.210175]  ? srso_alias_return_thunk+0x5/0xfbef5\n  [   13.213211]  ? kasan_unpoison+0x44/0x70\n  [   13.216688]  do_init_module+0x238/0x750\n  [   13.2196\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/60dc4ee0428d70bcbb41436b6729d29f1cbdfb89"
          },
          {
            "url": "https://git.kernel.org/stable/c/775125c7fe38533aaa4b20769f5b5e62cc1170a0"
          },
          {
            "url": "https://git.kernel.org/stable/c/86b4f5cf91ca03c08e3822ac89476a677a780bcc"
          },
          {
            "url": "https://git.kernel.org/stable/c/97155021ae17b86985121b33cf8098bcde00d497"
          },
          {
            "url": "https://git.kernel.org/stable/c/adb3e3c1ddb5a23b8b7122ef1913f528d728937c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46747",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:03.790",
        "lastModified": "2024-09-18T08:15:03.790",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nHID: cougar: fix slab-out-of-bounds Read in cougar_report_fixup\nreport_fixup for the Cougar 500k Gaming Keyboard was not verifying\nthat the report descriptor size was correct before accessing it",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/30e9ce7cd5591be639b53595c95812f1a2afdfdc"
          },
          {
            "url": "https://git.kernel.org/stable/c/34185de73d74fdc90e8651cfc472bfea6073a13f"
          },
          {
            "url": "https://git.kernel.org/stable/c/48b2108efa205f4579052c27fba2b22cc6ad8aa0"
          },
          {
            "url": "https://git.kernel.org/stable/c/890dde6001b651be79819ef7a3f8c71fc8f9cabf"
          },
          {
            "url": "https://git.kernel.org/stable/c/a6e9c391d45b5865b61e569146304cff72821a5d"
          },
          {
            "url": "https://git.kernel.org/stable/c/e239e44dcd419b13cf840e2a3a833204e4329714"
          },
          {
            "url": "https://git.kernel.org/stable/c/e4a602a45aecd6a98b4b37482f5c9f8f67a32ddd"
          },
          {
            "url": "https://git.kernel.org/stable/c/fac3cb3c6428afe2207593a183b5bc4742529dfd"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46748",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:03.847",
        "lastModified": "2024-09-18T08:15:03.847",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ncachefiles: Set the max subreq size for cache writes to MAX_RW_COUNT\nSet the maximum size of a subrequest that writes to cachefiles to be\nMAX_RW_COUNT so that we don't overrun the maximum write we can make to the\nbacking filesystem.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/51d37982bbac3ea0ca21b2797a9cb0044272b3aa"
          },
          {
            "url": "https://git.kernel.org/stable/c/cec226f9b1fd6cf55bc157873aec61b523083e96"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46749",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:03.893",
        "lastModified": "2024-09-18T08:15:03.893",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nBluetooth: btnxpuart: Fix Null pointer dereference in btnxpuart_flush()\nThis adds a check before freeing the rx->skb in flush and close\nfunctions to handle the kernel crash seen while removing driver after FW\ndownload fails or before FW download completes.\ndmesg log:\n[   54.634586] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000080\n[   54.643398] Mem abort info:\n[   54.646204]   ESR = 0x0000000096000004\n[   54.649964]   EC = 0x25: DABT (current EL), IL = 32 bits\n[   54.655286]   SET = 0, FnV = 0\n[   54.658348]   EA = 0, S1PTW = 0\n[   54.661498]   FSC = 0x04: level 0 translation fault\n[   54.666391] Data abort info:\n[   54.669273]   ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000\n[   54.674768]   CM = 0, WnR = 0, TnD = 0, TagAccess = 0\n[   54.674771]   GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0\n[   54.674775] user pgtable: 4k pages, 48-bit VAs, pgdp=0000000048860000\n[   54.674780] [0000000000000080] pgd=0000000000000000, p4d=0000000000000000\n[   54.703880] Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP\n[   54.710152] Modules linked in: btnxpuart(-) overlay fsl_jr_uio caam_jr caamkeyblob_desc caamhash_desc caamalg_desc crypto_engine authenc libdes crct10dif_ce polyval_ce polyval_generic snd_soc_imx_spdif snd_soc_imx_card snd_soc_ak5558 snd_soc_ak4458 caam secvio error snd_soc_fsl_micfil snd_soc_fsl_spdif snd_soc_fsl_sai snd_soc_fsl_utils imx_pcm_dma gpio_ir_recv rc_core sch_fq_codel fuse\n[   54.744357] CPU: 3 PID: 72 Comm: kworker/u9:0 Not tainted 6.6.3-otbr-g128004619037 #2\n[   54.744364] Hardware name: FSL i.MX8MM EVK board (DT)\n[   54.744368] Workqueue: hci0 hci_power_on\n[   54.757244] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[   54.757249] pc : kfree_skb_reason+0x18/0xb0\n[   54.772299] lr : btnxpuart_flush+0x40/0x58 [btnxpuart]\n[   54.782921] sp : ffff8000805ebca0\n[   54.782923] x29: ffff8000805ebca0 x28: ffffa5c6cf1869c0 x27: ffffa5c6cf186000\n[   54.782931] x26: ffff377b84852400 x25: ffff377b848523c0 x24: ffff377b845e7230\n[   54.782938] x23: ffffa5c6ce8dbe08 x22: ffffa5c6ceb65410 x21: 00000000ffffff92\n[   54.782945] x20: ffffa5c6ce8dbe98 x19: ffffffffffffffac x18: ffffffffffffffff\n[   54.807651] x17: 0000000000000000 x16: ffffa5c6ce2824ec x15: ffff8001005eb857\n[   54.821917] x14: 0000000000000000 x13: ffffa5c6cf1a02e0 x12: 0000000000000642\n[   54.821924] x11: 0000000000000040 x10: ffffa5c6cf19d690 x9 : ffffa5c6cf19d688\n[   54.821931] x8 : ffff377b86000028 x7 : 0000000000000000 x6 : 0000000000000000\n[   54.821938] x5 : ffff377b86000000 x4 : 0000000000000000 x3 : 0000000000000000\n[   54.843331] x2 : 0000000000000000 x1 : 0000000000000002 x0 : ffffffffffffffac\n[   54.857599] Call trace:\n[   54.857601]  kfree_skb_reason+0x18/0xb0\n[   54.863878]  btnxpuart_flush+0x40/0x58 [btnxpuart]\n[   54.863888]  hci_dev_open_sync+0x3a8/0xa04\n[   54.872773]  hci_power_on+0x54/0x2e4\n[   54.881832]  process_one_work+0x138/0x260\n[   54.881842]  worker_thread+0x32c/0x438\n[   54.881847]  kthread+0x118/0x11c\n[   54.881853]  ret_from_fork+0x10/0x20\n[   54.896406] Code: a9be7bfd 910003fd f9000bf3 aa0003f3 (b940d400)\n[   54.896410] ---[ end trace 0000000000000000 ]---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/013dae4735d2010544d1f2121bdeb8e6c9ea171e"
          },
          {
            "url": "https://git.kernel.org/stable/c/056e0cd381d59a9124b7c43dd715e15f56a11635"
          },
          {
            "url": "https://git.kernel.org/stable/c/c68bbf5e334b35b36ac5b9f0419f1f93f796bad1"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46750",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:03.947",
        "lastModified": "2024-09-18T08:15:03.947",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nPCI: Add missing bridge lock to pci_bus_lock()\nOne of the true positives that the cfg_access_lock lockdep effort\nidentified is this sequence:\n  WARNING: CPU: 14 PID: 1 at drivers/pci/pci.c:4886 pci_bridge_secondary_bus_reset+0x5d/0x70\n  RIP: 0010:pci_bridge_secondary_bus_reset+0x5d/0x70\n  Call Trace:\n   <TASK>\n   ? __warn+0x8c/0x190\n   ? pci_bridge_secondary_bus_reset+0x5d/0x70\n   ? report_bug+0x1f8/0x200\n   ? handle_bug+0x3c/0x70\n   ? exc_invalid_op+0x18/0x70\n   ? asm_exc_invalid_op+0x1a/0x20\n   ? pci_bridge_secondary_bus_reset+0x5d/0x70\n   pci_reset_bus+0x1d8/0x270\n   vmd_probe+0x778/0xa10\n   pci_device_probe+0x95/0x120\nWhere pci_reset_bus() users are triggering unlocked secondary bus resets.\nIronically pci_bus_reset(), several calls down from pci_reset_bus(), uses\npci_bus_lock() before issuing the reset which locks everything *but* the\nbridge itself.\nFor the same motivation as adding:\n  bridge = pci_upstream_bridge(dev);\n  if (bridge)\n    pci_dev_lock(bridge);\nto pci_reset_function() for the \"bus\" and \"cxl_bus\" reset cases, add\npci_dev_lock() for @bus->self to pci_bus_lock().\n[bhelgaas: squash in recursive locking deadlock fix from Keith Busch:\nhttps://lore.kernel.org/r/20240711193650.701834-1-kbusch@meta.com]",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/04e85a3285b0e5c5af6fd2c0fd6e95ffecc01945"
          },
          {
            "url": "https://git.kernel.org/stable/c/0790b89c7e911003b8c50ae50e3ac7645de1fae9"
          },
          {
            "url": "https://git.kernel.org/stable/c/7253b4fed46471cc247c6cacefac890a8472c083"
          },
          {
            "url": "https://git.kernel.org/stable/c/78c6e39fef5c428960aff742149bba302dd46f5a"
          },
          {
            "url": "https://git.kernel.org/stable/c/81c68e218ab883dfa368460a59b674084c0240da"
          },
          {
            "url": "https://git.kernel.org/stable/c/a4e772898f8bf2e7e1cf661a12c60a5612c4afab"
          },
          {
            "url": "https://git.kernel.org/stable/c/df77a678c33871a6e4ac5b54a71662f1d702335b"
          },
          {
            "url": "https://git.kernel.org/stable/c/e2355d513b89a2cb511b4ded0deb426cdb01acd0"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46751",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:04.010",
        "lastModified": "2024-09-18T08:15:04.010",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbtrfs: don't BUG_ON() when 0 reference count at btrfs_lookup_extent_info()\nInstead of doing a BUG_ON() handle the error by returning -EUCLEAN,\naborting the transaction and logging an error message.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/28cb13f29faf6290597b24b728dc3100c019356f"
          },
          {
            "url": "https://git.kernel.org/stable/c/ef9a8b73c8b60b27d9db4787e624a3438ffe8428"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46752",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:04.057",
        "lastModified": "2024-09-18T08:15:04.057",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbtrfs: replace BUG_ON() with error handling at update_ref_for_cow()\nInstead of a BUG_ON() just return an error, log an error message and\nabort the transaction in case we find an extent buffer belonging to the\nrelocation tree that doesn't have the full backref flag set. This is\nunexpected and should never happen (save for bugs or a potential bad\nmemory).",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0fbac73a97286a7ec72229cb9b42d760a2c717ac"
          },
          {
            "url": "https://git.kernel.org/stable/c/41a0f85e268d72fe04f731b8ceea4748c2d65491"
          },
          {
            "url": "https://git.kernel.org/stable/c/b50857b96429a09fd3beed9f7f21b7bb7c433688"
          },
          {
            "url": "https://git.kernel.org/stable/c/b56329a782314fde5b61058e2a25097af7ccb675"
          },
          {
            "url": "https://git.kernel.org/stable/c/f895db00c65e5d77c437cce946da9ec29dcdf563"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46753",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:04.107",
        "lastModified": "2024-09-18T08:15:04.107",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbtrfs: handle errors from btrfs_dec_ref() properly\nIn walk_up_proc() we BUG_ON(ret) from btrfs_dec_ref().  This is\nincorrect, we have proper error handling here, return the error.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/5eb178f373b4f16f3b42d55ff88fc94dd95b93b1"
          },
          {
            "url": "https://git.kernel.org/stable/c/a7f16a7a709845855cb5a0e080a52bda5873f9de"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46754",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:04.153",
        "lastModified": "2024-09-18T08:15:04.153",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbpf: Remove tst_run from lwt_seg6local_prog_ops.\nThe syzbot reported that the lwt_seg6 related BPF ops can be invoked\nvia bpf_test_run() without without entering input_action_end_bpf()\nfirst.\nMartin KaFai Lau said that self test for BPF_PROG_TYPE_LWT_SEG6LOCAL\nprobably didn't work since it was introduced in commit 04d4b274e2a\n(\"ipv6: sr: Add seg6local action End.BPF\"). The reason is that the\nper-CPU variable seg6_bpf_srh_states::srh is never assigned in the self\ntest case but each BPF function expects it.\nRemove test_run for BPF_PROG_TYPE_LWT_SEG6LOCAL.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/9cd15511de7c619bbd0f54bb3f28e6e720ded5d6"
          },
          {
            "url": "https://git.kernel.org/stable/c/c13fda93aca118b8e5cd202e339046728ee7dddb"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46755",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:04.203",
        "lastModified": "2024-09-18T08:15:04.203",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nwifi: mwifiex: Do not return unused priv in mwifiex_get_priv_by_id()\nmwifiex_get_priv_by_id() returns the priv pointer corresponding to\nthe bss_num and bss_type, but without checking if the priv is actually\ncurrently in use.\nUnused priv pointers do not have a wiphy attached to them which can\nlead to NULL pointer dereferences further down the callstack.  Fix\nthis by returning only used priv pointers which have priv->bss_mode\nset to something else than NL80211_IFTYPE_UNSPECIFIED.\nSaid NULL pointer dereference happened when an Accesspoint was started\nwith wpa_supplicant -i mlan0 with this config:\nnetwork={\n        ssid=\"somessid\"\n        mode=2\n        frequency=2412\n        key_mgmt=WPA-PSK WPA-PSK-SHA256\n        proto=RSN\n        group=CCMP\n        pairwise=CCMP\n        psk=\"12345678\"\n}\nWhen waiting for the AP to be established, interrupting wpa_supplicant\nwith <ctrl-c> and starting it again this happens:\n| Unable to handle kernel NULL pointer dereference at virtual address 0000000000000140\n| Mem abort info:\n|   ESR = 0x0000000096000004\n|   EC = 0x25: DABT (current EL), IL = 32 bits\n|   SET = 0, FnV = 0\n|   EA = 0, S1PTW = 0\n|   FSC = 0x04: level 0 translation fault\n| Data abort info:\n|   ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000\n|   CM = 0, WnR = 0, TnD = 0, TagAccess = 0\n|   GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0\n| user pgtable: 4k pages, 48-bit VAs, pgdp=0000000046d96000\n| [0000000000000140] pgd=0000000000000000, p4d=0000000000000000\n| Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP\n| Modules linked in: caam_jr caamhash_desc spidev caamalg_desc crypto_engine authenc libdes mwifiex_sdio\n+mwifiex crct10dif_ce cdc_acm onboard_usb_hub fsl_imx8_ddr_perf imx8m_ddrc rtc_ds1307 lm75 rtc_snvs\n+imx_sdma caam imx8mm_thermal spi_imx error imx_cpufreq_dt fuse ip_tables x_tables ipv6\n| CPU: 0 PID: 8 Comm: kworker/0:1 Not tainted 6.9.0-00007-g937242013fce-dirty #18\n| Hardware name: somemachine (DT)\n| Workqueue: events sdio_irq_work\n| pstate: 00000005 (nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n| pc : mwifiex_get_cfp+0xd8/0x15c [mwifiex]\n| lr : mwifiex_get_cfp+0x34/0x15c [mwifiex]\n| sp : ffff8000818b3a70\n| x29: ffff8000818b3a70 x28: ffff000006bfd8a5 x27: 0000000000000004\n| x26: 000000000000002c x25: 0000000000001511 x24: 0000000002e86bc9\n| x23: ffff000006bfd996 x22: 0000000000000004 x21: ffff000007bec000\n| x20: 000000000000002c x19: 0000000000000000 x18: 0000000000000000\n| x17: 000000040044ffff x16: 00500072b5503510 x15: ccc283740681e517\n| x14: 0201000101006d15 x13: 0000000002e8ff43 x12: 002c01000000ffb1\n| x11: 0100000000000000 x10: 02e8ff43002c0100 x9 : 0000ffb100100157\n| x8 : ffff000003d20000 x7 : 00000000000002f1 x6 : 00000000ffffe124\n| x5 : 0000000000000001 x4 : 0000000000000003 x3 : 0000000000000000\n| x2 : 0000000000000000 x1 : 0001000000011001 x0 : 0000000000000000\n| Call trace:\n|  mwifiex_get_cfp+0xd8/0x15c [mwifiex]\n|  mwifiex_parse_single_response_buf+0x1d0/0x504 [mwifiex]\n|  mwifiex_handle_event_ext_scan_report+0x19c/0x2f8 [mwifiex]\n|  mwifiex_process_sta_event+0x298/0xf0c [mwifiex]\n|  mwifiex_process_event+0x110/0x238 [mwifiex]\n|  mwifiex_main_process+0x428/0xa44 [mwifiex]\n|  mwifiex_sdio_interrupt+0x64/0x12c [mwifiex_sdio]\n|  process_sdio_pending_irqs+0x64/0x1b8\n|  sdio_irq_work+0x4c/0x7c\n|  process_one_work+0x148/0x2a0\n|  worker_thread+0x2fc/0x40c\n|  kthread+0x110/0x114\n|  ret_from_fork+0x10/0x20\n| Code: a94153f3 a8c37bfd d50323bf d65f03c0 (f940a000)\n| ---[ end trace 0000000000000000 ]---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1a05d8d02cfa3540ea5dbd6b39446bd3f515521f"
          },
          {
            "url": "https://git.kernel.org/stable/c/9813770f25855b866b8ead8155b8806b2db70f6d"
          },
          {
            "url": "https://git.kernel.org/stable/c/a12cf97cbefa139ef8d95081f2ea047cbbd74b7a"
          },
          {
            "url": "https://git.kernel.org/stable/c/c145eea2f75ff7949392aebecf7ef0a81c1f6c14"
          },
          {
            "url": "https://git.kernel.org/stable/c/c16916dd6c16fa7e13ca3923eb6b9f50d848ad03"
          },
          {
            "url": "https://git.kernel.org/stable/c/c2618dcb26c7211342b54520b5b148c0d3471c8a"
          },
          {
            "url": "https://git.kernel.org/stable/c/cb67b2e51b75f1a17bee7599c8161b96e1808a70"
          },
          {
            "url": "https://git.kernel.org/stable/c/d834433ff313838a259bb6607055ece87b895b66"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46756",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:04.260",
        "lastModified": "2024-09-18T08:15:04.260",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nhwmon: (w83627ehf) Fix underflows seen when writing limit attributes\nDIV_ROUND_CLOSEST() after kstrtol() results in an underflow if a large\nnegative number such as -9223372036854775808 is provided by the user.\nFix it by reordering clamp_val() and DIV_ROUND_CLOSEST() operations.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/26825b62bd1bd3e53b4f44e0745cb516d5186343"
          },
          {
            "url": "https://git.kernel.org/stable/c/56cfdeb2c77291f0b5e4592731adfb6ca8fc7c24"
          },
          {
            "url": "https://git.kernel.org/stable/c/5c1de37969b7bc0abcb20b86e91e70caebbd4f89"
          },
          {
            "url": "https://git.kernel.org/stable/c/77ab0fd231c4ca873ec6908e761970360acc6df2"
          },
          {
            "url": "https://git.kernel.org/stable/c/8fecb75bff1b7d87a071c32a37aa0700f2be379d"
          },
          {
            "url": "https://git.kernel.org/stable/c/93cf73a7bfdce683bde3a7bb65f270d3bd24497b"
          },
          {
            "url": "https://git.kernel.org/stable/c/cc4be794c8d8c253770103e097ab9dbdb5f99ae1"
          },
          {
            "url": "https://git.kernel.org/stable/c/d92f0baf99a7e327dcceab37cce57c38aab1f691"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46757",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:04.313",
        "lastModified": "2024-09-18T08:15:04.313",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nhwmon: (nct6775-core) Fix underflows seen when writing limit attributes\nDIV_ROUND_CLOSEST() after kstrtol() results in an underflow if a large\nnegative number such as -9223372036854775808 is provided by the user.\nFix it by reordering clamp_val() and DIV_ROUND_CLOSEST() operations.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/02bb3b4c7d5695ff4be01e0f55676bba49df435e"
          },
          {
            "url": "https://git.kernel.org/stable/c/0403e10bf0824bf0ec2bb135d4cf1c0cc3bf4bf0"
          },
          {
            "url": "https://git.kernel.org/stable/c/0c23e18cef20b989a9fd7cb0a745e1259b969159"
          },
          {
            "url": "https://git.kernel.org/stable/c/298a55f11edd811f2189b74eb8f53dee34d4f14c"
          },
          {
            "url": "https://git.kernel.org/stable/c/2f695544084a559f181cafdfd3f864c5ff9dd1db"
          },
          {
            "url": "https://git.kernel.org/stable/c/8a1e958e26640ce015abdbb75c8896301b9bf398"
          },
          {
            "url": "https://git.kernel.org/stable/c/996221b030995cc5f5baa4a642201d64b62a17cd"
          },
          {
            "url": "https://git.kernel.org/stable/c/d6035c55fa9afefc23f85f57eff1d4a1d82c5b10"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46758",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:04.367",
        "lastModified": "2024-09-18T08:15:04.367",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nhwmon: (lm95234) Fix underflows seen when writing limit attributes\nDIV_ROUND_CLOSEST() after kstrtol() results in an underflow if a large\nnegative number such as -9223372036854775808 is provided by the user.\nFix it by reordering clamp_val() and DIV_ROUND_CLOSEST() operations.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0fc27747633aa419f9af40e7bdfa00d2ec94ea81"
          },
          {
            "url": "https://git.kernel.org/stable/c/16f42953231be1e7be77bc24005270d9e0d9d2ee"
          },
          {
            "url": "https://git.kernel.org/stable/c/438453dfbbdcf4be26891492644aa3ecbb42c336"
          },
          {
            "url": "https://git.kernel.org/stable/c/46e4fd338d5bdbaf60e41cda625b24949d2af201"
          },
          {
            "url": "https://git.kernel.org/stable/c/59c1fb9874a01c9abc49a0a32f192a7e7b4e2650"
          },
          {
            "url": "https://git.kernel.org/stable/c/93f0f5721d0cca45dac50af1ae6f9a9826c699fd"
          },
          {
            "url": "https://git.kernel.org/stable/c/af64e3e1537896337405f880c1e9ac1f8c0c6198"
          },
          {
            "url": "https://git.kernel.org/stable/c/da765bebd90e1b92bdbc3c6a27a3f3cc81529ab6"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46759",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:04.413",
        "lastModified": "2024-09-18T08:15:04.413",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nhwmon: (adc128d818) Fix underflows seen when writing limit attributes\nDIV_ROUND_CLOSEST() after kstrtol() results in an underflow if a large\nnegative number such as -9223372036854775808 is provided by the user.\nFix it by reordering clamp_val() and DIV_ROUND_CLOSEST() operations.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/019ef2d396363ecddc46e826153a842f8603799b"
          },
          {
            "url": "https://git.kernel.org/stable/c/05419d0056dcf7088687e561bb583cc06deba777"
          },
          {
            "url": "https://git.kernel.org/stable/c/2a3add62f183459a057336381ef3a896da01ce38"
          },
          {
            "url": "https://git.kernel.org/stable/c/6891b11a0c6227ca7ed15786928a07b1c0e4d4af"
          },
          {
            "url": "https://git.kernel.org/stable/c/7645d783df23878342d5d8d22030c3861d2d5426"
          },
          {
            "url": "https://git.kernel.org/stable/c/8cad724c8537fe3e0da8004646abc00290adae40"
          },
          {
            "url": "https://git.kernel.org/stable/c/b0bdb43852bf7f55ba02f0cbf00b4ea7ca897bff"
          },
          {
            "url": "https://git.kernel.org/stable/c/f7f5101af5b47a331cdbfa42ba64c507b47dd1fe"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46760",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:04.470",
        "lastModified": "2024-09-18T08:15:04.470",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nwifi: rtw88: usb: schedule rx work after everything is set up\nRight now it's possible to hit NULL pointer dereference in\nrtw_rx_fill_rx_status on hw object and/or its fields because\ninitialization routine can start getting USB replies before\nrtw_dev is fully setup.\nThe stack trace looks like this:\nrtw_rx_fill_rx_status\nrtw8821c_query_rx_desc\nrtw_usb_rx_handler\n...\nqueue_work\nrtw_usb_read_port_complete\n...\nusb_submit_urb\nrtw_usb_rx_resubmit\nrtw_usb_init_rx\nrtw_usb_probe\nSo while we do the async stuff rtw_usb_probe continues and calls\nrtw_register_hw, which does all kinds of initialization (e.g.\nvia ieee80211_register_hw) that rtw_rx_fill_rx_status relies on.\nFix this by moving the first usb_submit_urb after everything\nis set up.\nFor me, this bug manifested as:\n[    8.893177] rtw_8821cu 1-1:1.2: band wrong, packet dropped\n[    8.910904] rtw_8821cu 1-1:1.2: hw->conf.chandef.chan NULL in rtw_rx_fill_rx_status\nbecause I'm using Larry's backport of rtw88 driver with the NULL\nchecks in rtw_rx_fill_rx_status.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/25eaef533bf3ccc6fee5067aac16f41f280e343e"
          },
          {
            "url": "https://git.kernel.org/stable/c/adc539784c98a7cc602cbf557debfc2e7b9be8b3"
          },
          {
            "url": "https://git.kernel.org/stable/c/c83d464b82a8ad62ec9077637f75d73fe955635a"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46761",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:04.517",
        "lastModified": "2024-09-18T08:15:04.517",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\npci/hotplug/pnv_php: Fix hotplug driver crash on Powernv\nThe hotplug driver for powerpc (pci/hotplug/pnv_php.c) causes a kernel\ncrash when we try to hot-unplug/disable the PCIe switch/bridge from\nthe PHB.\nThe crash occurs because although the MSI data structure has been\nreleased during disable/hot-unplug path and it has been assigned\nwith NULL, still during unregistration the code was again trying to\nexplicitly disable the MSI which causes the NULL pointer dereference and\nkernel crash.\nThe patch fixes the check during unregistration path to prevent invoking\npci_disable_msi/msix() since its data structure is already freed.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/335e35b748527f0c06ded9eebb65387f60647fda"
          },
          {
            "url": "https://git.kernel.org/stable/c/438d522227374042b5c8798f8ce83bbe479dca4d"
          },
          {
            "url": "https://git.kernel.org/stable/c/4eb4085c1346d19d4a05c55246eb93e74e671048"
          },
          {
            "url": "https://git.kernel.org/stable/c/b82d4d5c736f4fd2ed224c35f554f50d1953d21e"
          },
          {
            "url": "https://git.kernel.org/stable/c/bc1faed19db95abf0933b104910a3fb01b138f59"
          },
          {
            "url": "https://git.kernel.org/stable/c/bfc44075b19740d372f989f21dd03168bfda0689"
          },
          {
            "url": "https://git.kernel.org/stable/c/c0d8094dc740cfacf3775bbc6a1c4720459e8de4"
          },
          {
            "url": "https://git.kernel.org/stable/c/c4c681999d385e28f84808bbf3a85ea8e982da55"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46762",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:04.570",
        "lastModified": "2024-09-18T08:15:04.570",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nxen: privcmd: Fix possible access to a freed kirqfd instance\nNothing prevents simultaneous ioctl calls to privcmd_irqfd_assign() and\nprivcmd_irqfd_deassign(). If that happens, it is possible that a kirqfd\ncreated and added to the irqfds_list by privcmd_irqfd_assign() may get\nremoved by another thread executing privcmd_irqfd_deassign(), while the\nformer is still using it after dropping the locks.\nThis can lead to a situation where an already freed kirqfd instance may\nbe accessed and cause kernel oops.\nUse SRCU locking to prevent the same, as is done for the KVM\nimplementation for irqfds.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/112fd2f02b308564724b8e81006c254d20945c4b"
          },
          {
            "url": "https://git.kernel.org/stable/c/611ff1b1ae989a7bcce3e2a8e132ee30e968c557"
          },
          {
            "url": "https://git.kernel.org/stable/c/e997b357b13a7d95de31681fc54fcc34235fa527"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46763",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:04.613",
        "lastModified": "2024-09-18T08:15:04.613",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nfou: Fix null-ptr-deref in GRO.\nWe observed a null-ptr-deref in fou_gro_receive() while shutting down\na host.  [0]\nThe NULL pointer is sk->sk_user_data, and the offset 8 is of protocol\nin struct fou.\nWhen fou_release() is called due to netns dismantle or explicit tunnel\nteardown, udp_tunnel_sock_release() sets NULL to sk->sk_user_data.\nThen, the tunnel socket is destroyed after a single RCU grace period.\nSo, in-flight udp4_gro_receive() could find the socket and execute the\nFOU GRO handler, where sk->sk_user_data could be NULL.\nLet's use rcu_dereference_sk_user_data() in fou_from_sock() and add NULL\nchecks in FOU GRO handlers.\n[0]:\nBUG: kernel NULL pointer dereference, address: 0000000000000008\n PF: supervisor read access in kernel mode\n PF: error_code(0x0000) - not-present page\nPGD 80000001032f4067 P4D 80000001032f4067 PUD 103240067 PMD 0\nSMP PTI\nCPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.10.216-204.855.amzn2.x86_64 #1\nHardware name: Amazon EC2 c5.large/, BIOS 1.0 10/16/2017\nRIP: 0010:fou_gro_receive (net/ipv4/fou.c:233) [fou]\nCode: 41 5f c3 cc cc cc cc e8 e7 2e 69 f4 0f 1f 80 00 00 00 00 0f 1f 44 00 00 49 89 f8 41 54 48 89 f7 48 89 d6 49 8b 80 88 02 00 00 <0f> b6 48 08 0f b7 42 4a 66 25 fd fd 80 cc 02 66 89 42 4a 0f b6 42\nRSP: 0018:ffffa330c0003d08 EFLAGS: 00010297\nRAX: 0000000000000000 RBX: ffff93d9e3a6b900 RCX: 0000000000000010\nRDX: ffff93d9e3a6b900 RSI: ffff93d9e3a6b900 RDI: ffff93dac2e24d08\nRBP: ffff93d9e3a6b900 R08: ffff93dacbce6400 R09: 0000000000000002\nR10: 0000000000000000 R11: ffffffffb5f369b0 R12: ffff93dacbce6400\nR13: ffff93dac2e24d08 R14: 0000000000000000 R15: ffffffffb4edd1c0\nFS:  0000000000000000(0000) GS:ffff93daee800000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000000008 CR3: 0000000102140001 CR4: 00000000007706f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n <IRQ>\n ? show_trace_log_lvl (arch/x86/kernel/dumpstack.c:259)\n ? __die_body.cold (arch/x86/kernel/dumpstack.c:478 arch/x86/kernel/dumpstack.c:420)\n ? no_context (arch/x86/mm/fault.c:752)\n ? exc_page_fault (arch/x86/include/asm/irqflags.h:49 arch/x86/include/asm/irqflags.h:89 arch/x86/mm/fault.c:1435 arch/x86/mm/fault.c:1483)\n ? asm_exc_page_fault (arch/x86/include/asm/idtentry.h:571)\n ? fou_gro_receive (net/ipv4/fou.c:233) [fou]\n udp_gro_receive (include/linux/netdevice.h:2552 net/ipv4/udp_offload.c:559)\n udp4_gro_receive (net/ipv4/udp_offload.c:604)\n inet_gro_receive (net/ipv4/af_inet.c:1549 (discriminator 7))\n dev_gro_receive (net/core/dev.c:6035 (discriminator 4))\n napi_gro_receive (net/core/dev.c:6170)\n ena_clean_rx_irq (drivers/amazon/net/ena/ena_netdev.c:1558) [ena]\n ena_io_poll (drivers/amazon/net/ena/ena_netdev.c:1742) [ena]\n napi_poll (net/core/dev.c:6847)\n net_rx_action (net/core/dev.c:6917)\n __do_softirq (arch/x86/include/asm/jump_label.h:25 include/linux/jump_label.h:200 include/trace/events/irq.h:142 kernel/softirq.c:299)\n asm_call_irq_on_stack (arch/x86/entry/entry_64.S:809)\n</IRQ>\n do_softirq_own_stack (arch/x86/include/asm/irq_stack.h:27 arch/x86/include/asm/irq_stack.h:77 arch/x86/kernel/irq_64.c:77)\n irq_exit_rcu (kernel/softirq.c:393 kernel/softirq.c:423 kernel/softirq.c:435)\n common_interrupt (arch/x86/kernel/irq.c:239)\n asm_common_interrupt (arch/x86/include/asm/idtentry.h:626)\nRIP: 0010:acpi_idle_do_entry (arch/x86/include/asm/irqflags.h:49 arch/x86/include/asm/irqflags.h:89 drivers/acpi/processor_idle.c:114 drivers/acpi/processor_idle.c:575)\nCode: 8b 15 d1 3c c4 02 ed c3 cc cc cc cc 65 48 8b 04 25 40 ef 01 00 48 8b 00 a8 08 75 eb 0f 1f 44 00 00 0f 00 2d d5 09 55 00 fb f4 <fa> c3 cc cc cc cc e9 be fc ff ff 66 66 2e 0f 1f 84 00 00 00 00 00\nRSP: 0018:ffffffffb5603e58 EFLAGS: 00000246\nRAX: 0000000000004000 RBX: ffff93dac0929c00 RCX: ffff93daee833900\nRDX: ffff93daee800000 RSI: ffff93d\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1df42be305fe478ded1ee0c1d775f4ece713483b"
          },
          {
            "url": "https://git.kernel.org/stable/c/231c235d2f7a66f018f172e26ffd47c363f244ef"
          },
          {
            "url": "https://git.kernel.org/stable/c/4494bccb52ffda22ce5a1163a776d970e6229e08"
          },
          {
            "url": "https://git.kernel.org/stable/c/7e4196935069947d8b70b09c1660b67b067e75cb"
          },
          {
            "url": "https://git.kernel.org/stable/c/c46cd6aaca81040deaea3500ba75126963294bd9"
          },
          {
            "url": "https://git.kernel.org/stable/c/d7567f098f54cb53ee3cee1c82e3d0ed9698b6b3"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46764",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:04.670",
        "lastModified": "2024-09-18T08:15:04.670",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbpf: add check for invalid name in btf_name_valid_section()\nIf the length of the name string is 1 and the value of name[0] is NULL\nbyte, an OOB vulnerability occurs in btf_name_valid_section() and the\nreturn value is true, so the invalid name passes the check.\nTo solve this, you need to check if the first position is NULL byte and\nif the first character is printable.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/bb6705c3f93bed2af03d43691743d4c43e3c8e6f"
          },
          {
            "url": "https://git.kernel.org/stable/c/c8ffe2d4d37a05ce18c71b87421443c16f8475e5"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46765",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:04.710",
        "lastModified": "2024-09-18T08:15:04.710",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nice: protect XDP configuration with a mutex\nThe main threat to data consistency in ice_xdp() is a possible asynchronous\nPF reset. It can be triggered by a user or by TX timeout handler.\nXDP setup and PF reset code access the same resources in the following\nsections:\n* ice_vsi_close() in ice_prepare_for_reset() - already rtnl-locked\n* ice_vsi_rebuild() for the PF VSI - not protected\n* ice_vsi_open() - already rtnl-locked\nWith an unfortunate timing, such accesses can result in a crash such as the\none below:\n[ +1.999878] ice 0000:b1:00.0: Registered XDP mem model MEM_TYPE_XSK_BUFF_POOL on Rx ring 14\n[ +2.002992] ice 0000:b1:00.0: Registered XDP mem model MEM_TYPE_XSK_BUFF_POOL on Rx ring 18\n[Mar15 18:17] ice 0000:b1:00.0 ens801f0np0: NETDEV WATCHDOG: CPU: 38: transmit queue 14 timed out 80692736 ms\n[ +0.000093] ice 0000:b1:00.0 ens801f0np0: tx_timeout: VSI_num: 6, Q 14, NTC: 0x0, HW_HEAD: 0x0, NTU: 0x0, INT: 0x4000001\n[ +0.000012] ice 0000:b1:00.0 ens801f0np0: tx_timeout recovery level 1, txqueue 14\n[ +0.394718] ice 0000:b1:00.0: PTP reset successful\n[ +0.006184] BUG: kernel NULL pointer dereference, address: 0000000000000098\n[ +0.000045] #PF: supervisor read access in kernel mode\n[ +0.000023] #PF: error_code(0x0000) - not-present page\n[ +0.000023] PGD 0 P4D 0\n[ +0.000018] Oops: 0000 [#1] PREEMPT SMP NOPTI\n[ +0.000023] CPU: 38 PID: 7540 Comm: kworker/38:1 Not tainted 6.8.0-rc7 #1\n[ +0.000031] Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0014.082620210524 08/26/2021\n[ +0.000036] Workqueue: ice ice_service_task [ice]\n[ +0.000183] RIP: 0010:ice_clean_tx_ring+0xa/0xd0 [ice]\n[...]\n[ +0.000013] Call Trace:\n[ +0.000016] <TASK>\n[ +0.000014] ? __die+0x1f/0x70\n[ +0.000029] ? page_fault_oops+0x171/0x4f0\n[ +0.000029] ? schedule+0x3b/0xd0\n[ +0.000027] ? exc_page_fault+0x7b/0x180\n[ +0.000022] ? asm_exc_page_fault+0x22/0x30\n[ +0.000031] ? ice_clean_tx_ring+0xa/0xd0 [ice]\n[ +0.000194] ice_free_tx_ring+0xe/0x60 [ice]\n[ +0.000186] ice_destroy_xdp_rings+0x157/0x310 [ice]\n[ +0.000151] ice_vsi_decfg+0x53/0xe0 [ice]\n[ +0.000180] ice_vsi_rebuild+0x239/0x540 [ice]\n[ +0.000186] ice_vsi_rebuild_by_type+0x76/0x180 [ice]\n[ +0.000145] ice_rebuild+0x18c/0x840 [ice]\n[ +0.000145] ? delay_tsc+0x4a/0xc0\n[ +0.000022] ? delay_tsc+0x92/0xc0\n[ +0.000020] ice_do_reset+0x140/0x180 [ice]\n[ +0.000886] ice_service_task+0x404/0x1030 [ice]\n[ +0.000824] process_one_work+0x171/0x340\n[ +0.000685] worker_thread+0x277/0x3a0\n[ +0.000675] ? preempt_count_add+0x6a/0xa0\n[ +0.000677] ? _raw_spin_lock_irqsave+0x23/0x50\n[ +0.000679] ? __pfx_worker_thread+0x10/0x10\n[ +0.000653] kthread+0xf0/0x120\n[ +0.000635] ? __pfx_kthread+0x10/0x10\n[ +0.000616] ret_from_fork+0x2d/0x50\n[ +0.000612] ? __pfx_kthread+0x10/0x10\n[ +0.000604] ret_from_fork_asm+0x1b/0x30\n[ +0.000604] </TASK>\nThe previous way of handling this through returning -EBUSY is not viable,\nparticularly when destroying AF_XDP socket, because the kernel proceeds\nwith removal anyway.\nThere is plenty of code between those calls and there is no need to create\na large critical section that covers all of them, same as there is no need\nto protect ice_vsi_rebuild() with rtnl_lock().\nAdd xdp_state_lock mutex to protect ice_vsi_rebuild() and ice_xdp().\nLeaving unprotected sections in between would result in two states that\nhave to be considered:\n1. when the VSI is closed, but not yet rebuild\n2. when VSI is already rebuild, but not yet open\nThe latter case is actually already handled through !netif_running() case,\nwe just need to adjust flag checking a little. The former one is not as\ntrivial, because between ice_vsi_close() and ice_vsi_rebuild(), a lot of\nhardware interaction happens, this can make adding/deleting rings exit\nwith an error. Luckily, VSI rebuild is pending and can apply new\nconfiguration for us in a managed fashion.\nTherefore, add an additional VSI state flag ICE_VSI_REBUILD_PENDING to\nindicate that ice_x\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2504b8405768a57a71e660dbfd5abd59f679a03f"
          },
          {
            "url": "https://git.kernel.org/stable/c/2f057db2fb29bc209c103050647562e60554d3d3"
          },
          {
            "url": "https://git.kernel.org/stable/c/391f7dae3d836891fc6cfbde38add2d0e10c6b7f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46766",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:04.760",
        "lastModified": "2024-09-18T08:15:04.760",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nice: move netif_queue_set_napi to rtnl-protected sections\nCurrently, netif_queue_set_napi() is called from ice_vsi_rebuild() that is\nnot rtnl-locked when called from the reset. This creates the need to take\nthe rtnl_lock just for a single function and complicates the\nsynchronization with .ndo_bpf. At the same time, there no actual need to\nfill napi-to-queue information at this exact point.\nFill napi-to-queue information when opening the VSI and clear it when the\nVSI is being closed. Those routines are already rtnl-locked.\nAlso, rewrite napi-to-queue assignment in a way that prevents inclusion of\nXDP queues, as this leads to out-of-bounds writes, such as one below.\n[  +0.000004] BUG: KASAN: slab-out-of-bounds in netif_queue_set_napi+0x1c2/0x1e0\n[  +0.000012] Write of size 8 at addr ffff889881727c80 by task bash/7047\n[  +0.000006] CPU: 24 PID: 7047 Comm: bash Not tainted 6.10.0-rc2+ #2\n[  +0.000004] Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0014.082620210524 08/26/2021\n[  +0.000003] Call Trace:\n[  +0.000003]  <TASK>\n[  +0.000002]  dump_stack_lvl+0x60/0x80\n[  +0.000007]  print_report+0xce/0x630\n[  +0.000007]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10\n[  +0.000007]  ? __virt_addr_valid+0x1c9/0x2c0\n[  +0.000005]  ? netif_queue_set_napi+0x1c2/0x1e0\n[  +0.000003]  kasan_report+0xe9/0x120\n[  +0.000004]  ? netif_queue_set_napi+0x1c2/0x1e0\n[  +0.000004]  netif_queue_set_napi+0x1c2/0x1e0\n[  +0.000005]  ice_vsi_close+0x161/0x670 [ice]\n[  +0.000114]  ice_dis_vsi+0x22f/0x270 [ice]\n[  +0.000095]  ice_pf_dis_all_vsi.constprop.0+0xae/0x1c0 [ice]\n[  +0.000086]  ice_prepare_for_reset+0x299/0x750 [ice]\n[  +0.000087]  pci_dev_save_and_disable+0x82/0xd0\n[  +0.000006]  pci_reset_function+0x12d/0x230\n[  +0.000004]  reset_store+0xa0/0x100\n[  +0.000006]  ? __pfx_reset_store+0x10/0x10\n[  +0.000002]  ? __pfx_mutex_lock+0x10/0x10\n[  +0.000004]  ? __check_object_size+0x4c1/0x640\n[  +0.000007]  kernfs_fop_write_iter+0x30b/0x4a0\n[  +0.000006]  vfs_write+0x5d6/0xdf0\n[  +0.000005]  ? fd_install+0x180/0x350\n[  +0.000005]  ? __pfx_vfs_write+0x10/0xA10\n[  +0.000004]  ? do_fcntl+0x52c/0xcd0\n[  +0.000004]  ? kasan_save_track+0x13/0x60\n[  +0.000003]  ? kasan_save_free_info+0x37/0x60\n[  +0.000006]  ksys_write+0xfa/0x1d0\n[  +0.000003]  ? __pfx_ksys_write+0x10/0x10\n[  +0.000002]  ? __x64_sys_fcntl+0x121/0x180\n[  +0.000004]  ? _raw_spin_lock+0x87/0xe0\n[  +0.000005]  do_syscall_64+0x80/0x170\n[  +0.000007]  ? _raw_spin_lock+0x87/0xe0\n[  +0.000004]  ? __pfx__raw_spin_lock+0x10/0x10\n[  +0.000003]  ? file_close_fd_locked+0x167/0x230\n[  +0.000005]  ? syscall_exit_to_user_mode+0x7d/0x220\n[  +0.000005]  ? do_syscall_64+0x8c/0x170\n[  +0.000004]  ? do_syscall_64+0x8c/0x170\n[  +0.000003]  ? do_syscall_64+0x8c/0x170\n[  +0.000003]  ? fput+0x1a/0x2c0\n[  +0.000004]  ? filp_close+0x19/0x30\n[  +0.000004]  ? do_dup2+0x25a/0x4c0\n[  +0.000004]  ? __x64_sys_dup2+0x6e/0x2e0\n[  +0.000002]  ? syscall_exit_to_user_mode+0x7d/0x220\n[  +0.000004]  ? do_syscall_64+0x8c/0x170\n[  +0.000003]  ? __count_memcg_events+0x113/0x380\n[  +0.000005]  ? handle_mm_fault+0x136/0x820\n[  +0.000005]  ? do_user_addr_fault+0x444/0xa80\n[  +0.000004]  ? clear_bhb_loop+0x25/0x80\n[  +0.000004]  ? clear_bhb_loop+0x25/0x80\n[  +0.000002]  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n[  +0.000005] RIP: 0033:0x7f2033593154",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2285c2faef19ee08a6bd6754f4c3ec07dceb2889"
          },
          {
            "url": "https://git.kernel.org/stable/c/2a5dc090b92cfa5270e20056074241c6db5c9cdd"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46767",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:04.810",
        "lastModified": "2024-09-18T08:15:04.810",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: phy: Fix missing of_node_put() for leds\nThe call of of_get_child_by_name() will cause refcount incremented\nfor leds, if it succeeds, it should call of_node_put() to decrease\nit, fix it.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2560db6ede1aaf162a73b2df43e0b6c5ed8819f7"
          },
          {
            "url": "https://git.kernel.org/stable/c/26928c8f00f6bb0e194f3957fe51c69d36838eb2"
          },
          {
            "url": "https://git.kernel.org/stable/c/d9c8dbbc236cdc6231ee91cdede2fc97b430cfff"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46768",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:04.853",
        "lastModified": "2024-09-18T08:15:04.853",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nhwmon: (hp-wmi-sensors) Check if WMI event data exists\nThe BIOS can choose to return no event data in response to a\nWMI event, so the ACPI object passed to the WMI notify handler\ncan be NULL.\nCheck for such a situation and ignore the event in such a case.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/217539e994e53206bbf3fb330261cc78c480d311"
          },
          {
            "url": "https://git.kernel.org/stable/c/4b19c83ba108aa66226da5b79810e4d19e005f12"
          },
          {
            "url": "https://git.kernel.org/stable/c/a54da9df75cd1b4b5028f6c60f9a211532680585"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46769",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:04.903",
        "lastModified": "2024-09-18T08:15:04.903",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nspi: intel: Add check devm_kasprintf() returned value\nintel_spi_populate_chip() use devm_kasprintf() to set pdata->name.\nThis can return a NULL pointer on failure but this returned value\nis not checked.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2920294686ec23211637998f3ec386dfd3d784a6"
          },
          {
            "url": "https://git.kernel.org/stable/c/6e68abdc5d674f9f4185bf1e1956368d05df4838"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46770",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:04.957",
        "lastModified": "2024-09-18T08:15:04.957",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nice: Add netif_device_attach/detach into PF reset flow\nEthtool callbacks can be executed while reset is in progress and try to\naccess deleted resources, e.g. getting coalesce settings can result in a\nNULL pointer dereference seen below.\nReproduction steps:\nOnce the driver is fully initialized, trigger reset:\n\t# echo 1 > /sys/class/net/<interface>/device/reset\nwhen reset is in progress try to get coalesce settings using ethtool:\n\t# ethtool -c <interface>\nBUG: kernel NULL pointer dereference, address: 0000000000000020\nPGD 0 P4D 0\nOops: Oops: 0000 [#1] PREEMPT SMP PTI\nCPU: 11 PID: 19713 Comm: ethtool Tainted: G S                 6.10.0-rc7+ #7\nRIP: 0010:ice_get_q_coalesce+0x2e/0xa0 [ice]\nRSP: 0018:ffffbab1e9bcf6a8 EFLAGS: 00010206\nRAX: 000000000000000c RBX: ffff94512305b028 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: ffff9451c3f2e588 RDI: ffff9451c3f2e588\nRBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000\nR10: ffff9451c3f2e580 R11: 000000000000001f R12: ffff945121fa9000\nR13: ffffbab1e9bcf760 R14: 0000000000000013 R15: ffffffff9e65dd40\nFS:  00007faee5fbe740(0000) GS:ffff94546fd80000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000000020 CR3: 0000000106c2e005 CR4: 00000000001706f0\nCall Trace:\n<TASK>\nice_get_coalesce+0x17/0x30 [ice]\ncoalesce_prepare_data+0x61/0x80\nethnl_default_doit+0xde/0x340\ngenl_family_rcv_msg_doit+0xf2/0x150\ngenl_rcv_msg+0x1b3/0x2c0\nnetlink_rcv_skb+0x5b/0x110\ngenl_rcv+0x28/0x40\nnetlink_unicast+0x19c/0x290\nnetlink_sendmsg+0x222/0x490\n__sys_sendto+0x1df/0x1f0\n__x64_sys_sendto+0x24/0x30\ndo_syscall_64+0x82/0x160\nentry_SYSCALL_64_after_hwframe+0x76/0x7e\nRIP: 0033:0x7faee60d8e27\nCalling netif_device_detach() before reset makes the net core not call\nthe driver when ethtool command is issued, the attempt to execute an\nethtool command during reset will result in the following message:\n    netlink error: No such device\ninstead of NULL pointer dereference. Once reset is done and\nice_rebuild() is executing, the netif_device_attach() is called to allow\nfor ethtool operations to occur again in a safe manner.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/36486c9e8e01b84faaee47203eac0b7e9cc7fa4a"
          },
          {
            "url": "https://git.kernel.org/stable/c/9e3ffb839249eca113062587659224f856fe14e5"
          },
          {
            "url": "https://git.kernel.org/stable/c/d11a67634227f9f9da51938af085fb41a733848f"
          },
          {
            "url": "https://git.kernel.org/stable/c/efe8effe138044a4747d1112ebb8c454d1663723"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46771",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:05.010",
        "lastModified": "2024-09-18T08:15:05.010",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ncan: bcm: Remove proc entry when dev is unregistered.\nsyzkaller reported a warning in bcm_connect() below. [0]\nThe repro calls connect() to vxcan1, removes vxcan1, and calls\nconnect() with ifindex == 0.\nCalling connect() for a BCM socket allocates a proc entry.\nThen, bcm_sk(sk)->bound is set to 1 to prevent further connect().\nHowever, removing the bound device resets bcm_sk(sk)->bound to 0\nin bcm_notify().\nThe 2nd connect() tries to allocate a proc entry with the same\nname and sets NULL to bcm_sk(sk)->bcm_proc_read, leaking the\noriginal proc entry.\nSince the proc entry is available only for connect()ed sockets,\nlet's clean up the entry when the bound netdev is unregistered.\n[0]:\nproc_dir_entry 'can-bcm/2456' already registered\nWARNING: CPU: 1 PID: 394 at fs/proc/generic.c:376 proc_register+0x645/0x8f0 fs/proc/generic.c:375\nModules linked in:\nCPU: 1 PID: 394 Comm: syz-executor403 Not tainted 6.10.0-rc7-g852e42cc2dd4\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014\nRIP: 0010:proc_register+0x645/0x8f0 fs/proc/generic.c:375\nCode: 00 00 00 00 00 48 85 ed 0f 85 97 02 00 00 4d 85 f6 0f 85 9f 02 00 00 48 c7 c7 9b cb cf 87 48 89 de 4c 89 fa e8 1c 6f eb fe 90 <0f> 0b 90 90 48 c7 c7 98 37 99 89 e8 cb 7e 22 05 bb 00 00 00 10 48\nRSP: 0018:ffa0000000cd7c30 EFLAGS: 00010246\nRAX: 9e129be1950f0200 RBX: ff1100011b51582c RCX: ff1100011857cd80\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000002\nRBP: 0000000000000000 R08: ffd400000000000f R09: ff1100013e78cac0\nR10: ffac800000cd7980 R11: ff1100013e12b1f0 R12: 0000000000000000\nR13: 0000000000000000 R14: 0000000000000000 R15: ff1100011a99a2ec\nFS:  00007fbd7086f740(0000) GS:ff1100013fd00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00000000200071c0 CR3: 0000000118556004 CR4: 0000000000771ef0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe07f0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n <TASK>\n proc_create_net_single+0x144/0x210 fs/proc/proc_net.c:220\n bcm_connect+0x472/0x840 net/can/bcm.c:1673\n __sys_connect_file net/socket.c:2049 [inline]\n __sys_connect+0x5d2/0x690 net/socket.c:2066\n __do_sys_connect net/socket.c:2076 [inline]\n __se_sys_connect net/socket.c:2073 [inline]\n __x64_sys_connect+0x8f/0x100 net/socket.c:2073\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xd9/0x1c0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x4b/0x53\nRIP: 0033:0x7fbd708b0e5d\nCode: ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 73 9f 1b 00 f7 d8 64 89 01 48\nRSP: 002b:00007fff8cd33f08 EFLAGS: 00000246 ORIG_RAX: 000000000000002a\nRAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007fbd708b0e5d\nRDX: 0000000000000010 RSI: 0000000020000040 RDI: 0000000000000003\nRBP: 0000000000000000 R08: 0000000000000040 R09: 0000000000000040\nR10: 0000000000000040 R11: 0000000000000246 R12: 00007fff8cd34098\nR13: 0000000000401280 R14: 0000000000406de8 R15: 00007fbd70ab9000\n </TASK>\nremove_proc_entry: removing non-empty directory 'net/can-bcm', leaking at least '2456'",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/10bfacbd5e8d821011d857bee73310457c9c989a"
          },
          {
            "url": "https://git.kernel.org/stable/c/33ed4ba73caae39f34ab874ba79138badc2c65dd"
          },
          {
            "url": "https://git.kernel.org/stable/c/3b39dc2901aa7a679a5ca981a3de9f8d5658afe8"
          },
          {
            "url": "https://git.kernel.org/stable/c/4377b79323df62eb5d310354f19b4d130ff58d50"
          },
          {
            "url": "https://git.kernel.org/stable/c/5c680022c4e28ba18ea500f3e29f0428271afa92"
          },
          {
            "url": "https://git.kernel.org/stable/c/76fe372ccb81b0c89b6cd2fec26e2f38c958be85"
          },
          {
            "url": "https://git.kernel.org/stable/c/abb0a615569ec008e8a93d9f3ab2d5b418ea94d4"
          },
          {
            "url": "https://git.kernel.org/stable/c/aec92dbebdbec7567d9f56d7c9296a572b8fd849"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46772",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:05.073",
        "lastModified": "2024-09-18T08:15:05.073",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/amd/display: Check denominator crb_pipes before used\n[WHAT & HOW]\nA denominator cannot be 0, and is checked before used.\nThis fixes 2 DIVIDE_BY_ZERO issues reported by Coverity.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/ea79068d4073bf303f8203f2625af7d9185a1bc6"
          },
          {
            "url": "https://git.kernel.org/stable/c/ede06d23392529b039cf7ac11b5875b047900f1c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46773",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:05.123",
        "lastModified": "2024-09-18T08:15:05.123",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/amd/display: Check denominator pbn_div before used\n[WHAT & HOW]\nA denominator cannot be 0, and is checked before used.\nThis fixes 1 DIVIDE_BY_ZERO issue reported by Coverity.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/116a678f3a9abc24f5c9d2525b7393d18d9eb58e"
          },
          {
            "url": "https://git.kernel.org/stable/c/11f997143c67680d6e40a13363618380cd57a414"
          },
          {
            "url": "https://git.kernel.org/stable/c/20e7164c52d9bfbb9d9862b833fa989624a61345"
          },
          {
            "url": "https://git.kernel.org/stable/c/dfafee0a7b51c7c9612edd2d991401294964d02f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46774",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:05.180",
        "lastModified": "2024-09-18T08:15:05.180",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\npowerpc/rtas: Prevent Spectre v1 gadget construction in sys_rtas()\nSmatch warns:\n  arch/powerpc/kernel/rtas.c:1932 __do_sys_rtas() warn: potential\n  spectre issue 'args.args' [r] (local cap)\nThe 'nargs' and 'nret' locals come directly from a user-supplied\nbuffer and are used as indexes into a small stack-based array and as\ninputs to copy_to_user() after they are subject to bounds checks.\nUse array_index_nospec() after the bounds checks to clamp these values\nfor speculative execution.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0974d03eb479384466d828d65637814bee6b26d7"
          },
          {
            "url": "https://git.kernel.org/stable/c/68d8156480940b79227d58865ec5d2947b9384a8"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46775",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:05.240",
        "lastModified": "2024-09-18T08:15:05.240",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/amd/display: Validate function returns\n[WHAT & HOW]\nFunction return values must be checked before data can be used\nin subsequent functions.\nThis fixes 4 CHECKED_RETURN issues reported by Coverity.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/5639a3048c7079803256374204ad55ec52cd0b49"
          },
          {
            "url": "https://git.kernel.org/stable/c/673f816b9e1e92d1f70e1bf5f21b531e0ff9ad6c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46776",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:05.287",
        "lastModified": "2024-09-18T08:15:05.287",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/amd/display: Run DC_LOG_DC after checking link->link_enc\n[WHAT]\nThe DC_LOG_DC should be run after link->link_enc is checked, not before.\nThis fixes 1 REVERSE_INULL issue reported by Coverity.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3a82f62b0d9d7687eac47603bb6cd14a50fa718b"
          },
          {
            "url": "https://git.kernel.org/stable/c/874e3bb302f97b94ac548959ec4f925b8e7b45e2"
          },
          {
            "url": "https://git.kernel.org/stable/c/adc74d25cdbba978afbb57caec23bbcd0329f7b8"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46777",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:05.330",
        "lastModified": "2024-09-18T08:15:05.330",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nudf: Avoid excessive partition lengths\nAvoid mounting filesystems where the partition would overflow the\n32-bits used for block number. Also refuse to mount filesystems where\nthe partition length is so large we cannot safely index bits in a\nblock bitmap.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0173999123082280cf904bd640015951f194a294"
          },
          {
            "url": "https://git.kernel.org/stable/c/1497a4484cdb2cf6c37960d788fb6ba67567bdb7"
          },
          {
            "url": "https://git.kernel.org/stable/c/2ddf831451357c6da4b64645eb797c93c1c054d1"
          },
          {
            "url": "https://git.kernel.org/stable/c/551966371e17912564bc387fbeb2ac13077c3db1"
          },
          {
            "url": "https://git.kernel.org/stable/c/925fd8ee80d5348a5e965548e5484d164d19221d"
          },
          {
            "url": "https://git.kernel.org/stable/c/a56330761950cb83de1dfb348479f20c56c95f90"
          },
          {
            "url": "https://git.kernel.org/stable/c/c0c23130d38e8bc28e9ef581443de9b1fc749966"
          },
          {
            "url": "https://git.kernel.org/stable/c/ebbe26fd54a9621994bc16b14f2ba8f84c089693"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46778",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:05.380",
        "lastModified": "2024-09-18T08:15:05.380",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/amd/display: Check UnboundedRequestEnabled's value\nCalculateSwathAndDETConfiguration_params_st's UnboundedRequestEnabled\nis a pointer (i.e. dml_bool_t *UnboundedRequestEnabled), and thus\nif (p->UnboundedRequestEnabled) checks its address, not bool value.\nThis fixes 1 REVERSE_INULL issue reported by Coverity.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4e2b49a85e7974d21364798c5d4aa8070aa864d9"
          },
          {
            "url": "https://git.kernel.org/stable/c/a7b38c7852093385d0605aa3c8a2efd6edd1edfd"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46779",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:05.430",
        "lastModified": "2024-09-18T08:15:05.430",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/imagination: Free pvr_vm_gpuva after unlink\nThis caused a measurable memory leak. Although the individual\nallocations are small, the leaks occurs in a high-usage codepath\n(remapping or unmapping device memory) so they add up quickly.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1cc695be8920df234f83270d789078cb2d3bc564"
          },
          {
            "url": "https://git.kernel.org/stable/c/3f6b2f60b4631cd0c368da6a1587ab55a696164d"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46780",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:05.473",
        "lastModified": "2024-09-18T08:15:05.473",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnilfs2: protect references to superblock parameters exposed in sysfs\nThe superblock buffers of nilfs2 can not only be overwritten at runtime\nfor modifications/repairs, but they are also regularly swapped, replaced\nduring resizing, and even abandoned when degrading to one side due to\nbacking device issues.  So, accessing them requires mutual exclusion using\nthe reader/writer semaphore \"nilfs->ns_sem\".\nSome sysfs attribute show methods read this superblock buffer without the\nnecessary mutual exclusion, which can cause problems with pointer\ndereferencing and memory access, so fix it.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/157c0d94b4c40887329418c70ef4edd1a8d6b4ed"
          },
          {
            "url": "https://git.kernel.org/stable/c/19cfeba0e4b8eda51484fcf8cf7d150418e1d880"
          },
          {
            "url": "https://git.kernel.org/stable/c/683408258917541bdb294cd717c210a04381931e"
          },
          {
            "url": "https://git.kernel.org/stable/c/8c6e43b3d5f109cf9c61bc188fcc8175404e924f"
          },
          {
            "url": "https://git.kernel.org/stable/c/962562d4c70c5cdeb4e955d63ff2017c4eca1aad"
          },
          {
            "url": "https://git.kernel.org/stable/c/b14e7260bb691d7f563f61da07d61e3c8b59a614"
          },
          {
            "url": "https://git.kernel.org/stable/c/b90beafac05931cbfcb6b1bd4f67c1923f47040e"
          },
          {
            "url": "https://git.kernel.org/stable/c/ba97ba173f9625d5f34a986088979eae8b80d38e"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46781",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:05.527",
        "lastModified": "2024-09-18T08:15:05.527",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnilfs2: fix missing cleanup on rollforward recovery error\nIn an error injection test of a routine for mount-time recovery, KASAN\nfound a use-after-free bug.\nIt turned out that if data recovery was performed using partial logs\ncreated by dsync writes, but an error occurred before starting the log\nwriter to create a recovered checkpoint, the inodes whose data had been\nrecovered were left in the ns_dirty_files list of the nilfs object and\nwere not freed.\nFix this issue by cleaning up inodes that have read the recovery data if\nthe recovery routine fails midway before the log writer starts.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/07e4dc2fe000ab008bcfe90be4324ef56b5b4355"
          },
          {
            "url": "https://git.kernel.org/stable/c/1cf1f7e8cd47244fa947d357ef1f642d91e219a3"
          },
          {
            "url": "https://git.kernel.org/stable/c/35a9a7a7d94662146396199b0cfd95f9517cdd14"
          },
          {
            "url": "https://git.kernel.org/stable/c/5787fcaab9eb5930f5378d6a1dd03d916d146622"
          },
          {
            "url": "https://git.kernel.org/stable/c/8e2d1e9d93c4ec51354229361ac3373058529ec4"
          },
          {
            "url": "https://git.kernel.org/stable/c/9d8c3a585d564d776ee60d4aabec59b404be7403"
          },
          {
            "url": "https://git.kernel.org/stable/c/ca92c4bff2833cb30d493b935168d6cccd5c805d"
          },
          {
            "url": "https://git.kernel.org/stable/c/da02f9eb333333b2e4f25d2a14967cff785ac82e"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46782",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:05.577",
        "lastModified": "2024-09-18T08:15:05.577",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nila: call nf_unregister_net_hooks() sooner\nsyzbot found an use-after-free Read in ila_nf_input [1]\nIssue here is that ila_xlat_exit_net() frees the rhashtable,\nthen call nf_unregister_net_hooks().\nIt should be done in the reverse way, with a synchronize_rcu().\nThis is a good match for a pre_exit() method.\n[1]\n BUG: KASAN: use-after-free in rht_key_hashfn include/linux/rhashtable.h:159 [inline]\n BUG: KASAN: use-after-free in __rhashtable_lookup include/linux/rhashtable.h:604 [inline]\n BUG: KASAN: use-after-free in rhashtable_lookup include/linux/rhashtable.h:646 [inline]\n BUG: KASAN: use-after-free in rhashtable_lookup_fast+0x77a/0x9b0 include/linux/rhashtable.h:672\nRead of size 4 at addr ffff888064620008 by task ksoftirqd/0/16\nCPU: 0 UID: 0 PID: 16 Comm: ksoftirqd/0 Not tainted 6.11.0-rc4-syzkaller-00238-g2ad6d23f465a #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024\nCall Trace:\n <TASK>\n  __dump_stack lib/dump_stack.c:93 [inline]\n  dump_stack_lvl+0x241/0x360 lib/dump_stack.c:119\n  print_address_description mm/kasan/report.c:377 [inline]\n  print_report+0x169/0x550 mm/kasan/report.c:488\n  kasan_report+0x143/0x180 mm/kasan/report.c:601\n  rht_key_hashfn include/linux/rhashtable.h:159 [inline]\n  __rhashtable_lookup include/linux/rhashtable.h:604 [inline]\n  rhashtable_lookup include/linux/rhashtable.h:646 [inline]\n  rhashtable_lookup_fast+0x77a/0x9b0 include/linux/rhashtable.h:672\n  ila_lookup_wildcards net/ipv6/ila/ila_xlat.c:132 [inline]\n  ila_xlat_addr net/ipv6/ila/ila_xlat.c:652 [inline]\n  ila_nf_input+0x1fe/0x3c0 net/ipv6/ila/ila_xlat.c:190\n  nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline]\n  nf_hook_slow+0xc3/0x220 net/netfilter/core.c:626\n  nf_hook include/linux/netfilter.h:269 [inline]\n  NF_HOOK+0x29e/0x450 include/linux/netfilter.h:312\n  __netif_receive_skb_one_core net/core/dev.c:5661 [inline]\n  __netif_receive_skb+0x1ea/0x650 net/core/dev.c:5775\n  process_backlog+0x662/0x15b0 net/core/dev.c:6108\n  __napi_poll+0xcb/0x490 net/core/dev.c:6772\n  napi_poll net/core/dev.c:6841 [inline]\n  net_rx_action+0x89b/0x1240 net/core/dev.c:6963\n  handle_softirqs+0x2c4/0x970 kernel/softirq.c:554\n  run_ksoftirqd+0xca/0x130 kernel/softirq.c:928\n  smpboot_thread_fn+0x544/0xa30 kernel/smpboot.c:164\n  kthread+0x2f0/0x390 kernel/kthread.c:389\n  ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147\n  ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n </TASK>\nThe buggy address belongs to the physical page:\npage: refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x64620\nflags: 0xfff00000000000(node=0|zone=1|lastcpupid=0x7ff)\npage_type: 0xbfffffff(buddy)\nraw: 00fff00000000000 ffffea0000959608 ffffea00019d9408 0000000000000000\nraw: 0000000000000000 0000000000000003 00000000bfffffff 0000000000000000\npage dumped because: kasan: bad access detected\npage_owner tracks the page as freed\npage last allocated via order 3, migratetype Unmovable, gfp_mask 0x52dc0(GFP_KERNEL|__GFP_NOWARN|__GFP_NORETRY|__GFP_COMP|__GFP_ZERO), pid 5242, tgid 5242 (syz-executor), ts 73611328570, free_ts 618981657187\n  set_page_owner include/linux/page_owner.h:32 [inline]\n  post_alloc_hook+0x1f3/0x230 mm/page_alloc.c:1493\n  prep_new_page mm/page_alloc.c:1501 [inline]\n  get_page_from_freelist+0x2e4c/0x2f10 mm/page_alloc.c:3439\n  __alloc_pages_noprof+0x256/0x6c0 mm/page_alloc.c:4695\n  __alloc_pages_node_noprof include/linux/gfp.h:269 [inline]\n  alloc_pages_node_noprof include/linux/gfp.h:296 [inline]\n  ___kmalloc_large_node+0x8b/0x1d0 mm/slub.c:4103\n  __kmalloc_large_node_noprof+0x1a/0x80 mm/slub.c:4130\n  __do_kmalloc_node mm/slub.c:4146 [inline]\n  __kmalloc_node_noprof+0x2d2/0x440 mm/slub.c:4164\n  __kvmalloc_node_noprof+0x72/0x190 mm/util.c:650\n  bucket_table_alloc lib/rhashtable.c:186 [inline]\n  rhashtable_init_noprof+0x534/0xa60 lib/rhashtable.c:1071\n  ila_xlat_init_net+0xa0/0x110 net/ipv6/ila/ila_xlat.c:613\n  ops_ini\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/031ae72825cef43e4650140b800ad58bf7a6a466"
          },
          {
            "url": "https://git.kernel.org/stable/c/18a5a16940464b301ea91bf5da3a324aedb347b2"
          },
          {
            "url": "https://git.kernel.org/stable/c/43d34110882b97ba1ec66cc8234b18983efb9abf"
          },
          {
            "url": "https://git.kernel.org/stable/c/47abd8adddbc0aecb8f231269ef659148d5dabe4"
          },
          {
            "url": "https://git.kernel.org/stable/c/925c18a7cff93d8a4320d652351294ff7d0ac93c"
          },
          {
            "url": "https://git.kernel.org/stable/c/93ee345ba349922834e6a9d1dadabaedcc12dce6"
          },
          {
            "url": "https://git.kernel.org/stable/c/bda4d84ac0d5421b346faee720011f58bdb99673"
          },
          {
            "url": "https://git.kernel.org/stable/c/dcaf4e2216824839d26727a15b638c6a677bd9fc"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46783",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:05.630",
        "lastModified": "2024-09-18T08:15:05.630",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ntcp_bpf: fix return value of tcp_bpf_sendmsg()\nWhen we cork messages in psock->cork, the last message triggers the\nflushing will result in sending a sk_msg larger than the current\nmessage size. In this case, in tcp_bpf_send_verdict(), 'copied' becomes\nnegative at least in the following case:\n468         case __SK_DROP:\n469         default:\n470                 sk_msg_free_partial(sk, msg, tosend);\n471                 sk_msg_apply_bytes(psock, tosend);\n472                 *copied -= (tosend + delta); // <==== HERE\n473                 return -EACCES;\nTherefore, it could lead to the following BUG with a proper value of\n'copied' (thanks to syzbot). We should not use negative 'copied' as a\nreturn value here.\n  ------------[ cut here ]------------\n  kernel BUG at net/socket.c:733!\n  Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP\n  Modules linked in:\n  CPU: 0 UID: 0 PID: 3265 Comm: syz-executor510 Not tainted 6.11.0-rc3-syzkaller-00060-gd07b43284ab3 #0\n  Hardware name: linux,dummy-virt (DT)\n  pstate: 61400009 (nZCv daif +PAN -UAO -TCO +DIT -SSBS BTYPE=--)\n  pc : sock_sendmsg_nosec net/socket.c:733 [inline]\n  pc : sock_sendmsg_nosec net/socket.c:728 [inline]\n  pc : __sock_sendmsg+0x5c/0x60 net/socket.c:745\n  lr : sock_sendmsg_nosec net/socket.c:730 [inline]\n  lr : __sock_sendmsg+0x54/0x60 net/socket.c:745\n  sp : ffff800088ea3b30\n  x29: ffff800088ea3b30 x28: fbf00000062bc900 x27: 0000000000000000\n  x26: ffff800088ea3bc0 x25: ffff800088ea3bc0 x24: 0000000000000000\n  x23: f9f00000048dc000 x22: 0000000000000000 x21: ffff800088ea3d90\n  x20: f9f00000048dc000 x19: ffff800088ea3d90 x18: 0000000000000001\n  x17: 0000000000000000 x16: 0000000000000000 x15: 000000002002ffaf\n  x14: 0000000000000000 x13: 0000000000000000 x12: 0000000000000000\n  x11: 0000000000000000 x10: ffff8000815849c0 x9 : ffff8000815b49c0\n  x8 : 0000000000000000 x7 : 000000000000003f x6 : 0000000000000000\n  x5 : 00000000000007e0 x4 : fff07ffffd239000 x3 : fbf00000062bc900\n  x2 : 0000000000000000 x1 : 0000000000000000 x0 : 00000000fffffdef\n  Call trace:\n   sock_sendmsg_nosec net/socket.c:733 [inline]\n   __sock_sendmsg+0x5c/0x60 net/socket.c:745\n   ____sys_sendmsg+0x274/0x2ac net/socket.c:2597\n   ___sys_sendmsg+0xac/0x100 net/socket.c:2651\n   __sys_sendmsg+0x84/0xe0 net/socket.c:2680\n   __do_sys_sendmsg net/socket.c:2689 [inline]\n   __se_sys_sendmsg net/socket.c:2687 [inline]\n   __arm64_sys_sendmsg+0x24/0x30 net/socket.c:2687\n   __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]\n   invoke_syscall+0x48/0x110 arch/arm64/kernel/syscall.c:49\n   el0_svc_common.constprop.0+0x40/0xe0 arch/arm64/kernel/syscall.c:132\n   do_el0_svc+0x1c/0x28 arch/arm64/kernel/syscall.c:151\n   el0_svc+0x34/0xec arch/arm64/kernel/entry-common.c:712\n   el0t_64_sync_handler+0x100/0x12c arch/arm64/kernel/entry-common.c:730\n   el0t_64_sync+0x19c/0x1a0 arch/arm64/kernel/entry.S:598\n  Code: f9404463 d63f0060 3108441f 54fffe81 (d4210000)\n  ---[ end trace 0000000000000000 ]---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/126d72b726c4cf1119f3a7fe413a78d341c3fea9"
          },
          {
            "url": "https://git.kernel.org/stable/c/3efe53eb221a38e207c1e3f81c51e4ca057d50c2"
          },
          {
            "url": "https://git.kernel.org/stable/c/6f9fdf5806cced888c43512bccbdf7fefd50f510"
          },
          {
            "url": "https://git.kernel.org/stable/c/78bb38d9c5a311c5f8bdef7c9557d7d81ca30e4a"
          },
          {
            "url": "https://git.kernel.org/stable/c/810a4e7d92dea4074cb04c25758320909d752193"
          },
          {
            "url": "https://git.kernel.org/stable/c/c8219a27fa43a2cbf99f5176f6dddfe73e7a24ae"
          },
          {
            "url": "https://git.kernel.org/stable/c/fe1910f9337bd46a9343967b547ccab26b4b2c6e"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46784",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:05.683",
        "lastModified": "2024-09-18T08:15:05.683",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: mana: Fix error handling in mana_create_txq/rxq's NAPI cleanup\nCurrently napi_disable() gets called during rxq and txq cleanup,\neven before napi is enabled and hrtimer is initialized. It causes\nkernel panic.\n? page_fault_oops+0x136/0x2b0\n  ? page_counter_cancel+0x2e/0x80\n  ? do_user_addr_fault+0x2f2/0x640\n  ? refill_obj_stock+0xc4/0x110\n  ? exc_page_fault+0x71/0x160\n  ? asm_exc_page_fault+0x27/0x30\n  ? __mmdrop+0x10/0x180\n  ? __mmdrop+0xec/0x180\n  ? hrtimer_active+0xd/0x50\n  hrtimer_try_to_cancel+0x2c/0xf0\n  hrtimer_cancel+0x15/0x30\n  napi_disable+0x65/0x90\n  mana_destroy_rxq+0x4c/0x2f0\n  mana_create_rxq.isra.0+0x56c/0x6d0\n  ? mana_uncfg_vport+0x50/0x50\n  mana_alloc_queues+0x21b/0x320\n  ? skb_dequeue+0x5f/0x80",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/4982a47154f0b50de81ee0a0b169a3fc74120a65"
          },
          {
            "url": "https://git.kernel.org/stable/c/9178eb8ebcd887ab75e54ac40d538e54bb9c7788"
          },
          {
            "url": "https://git.kernel.org/stable/c/9e0bff4900b5d412a9bafe4baeaa6facd34f671c"
          },
          {
            "url": "https://git.kernel.org/stable/c/b6ecc662037694488bfff7c9fd21c405df8411f2"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46785",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:05.730",
        "lastModified": "2024-09-18T08:15:05.730",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\neventfs: Use list_del_rcu() for SRCU protected list variable\nChi Zhiling reported:\n  We found a null pointer accessing in tracefs[1], the reason is that the\n  variable 'ei_child' is set to LIST_POISON1, that means the list was\n  removed in eventfs_remove_rec. so when access the ei_child->is_freed, the\n  panic triggered.\n  by the way, the following script can reproduce this panic\n  loop1 (){\n      while true\n      do\n          echo \"p:kp submit_bio\" > /sys/kernel/debug/tracing/kprobe_events\n          echo \"\" > /sys/kernel/debug/tracing/kprobe_events\n      done\n  }\n  loop2 (){\n      while true\n      do\n          tree /sys/kernel/debug/tracing/events/kprobes/\n      done\n  }\n  loop1 &\n  loop2\n  [1]:\n  [ 1147.959632][T17331] Unable to handle kernel paging request at virtual address dead000000000150\n  [ 1147.968239][T17331] Mem abort info:\n  [ 1147.971739][T17331]   ESR = 0x0000000096000004\n  [ 1147.976172][T17331]   EC = 0x25: DABT (current EL), IL = 32 bits\n  [ 1147.982171][T17331]   SET = 0, FnV = 0\n  [ 1147.985906][T17331]   EA = 0, S1PTW = 0\n  [ 1147.989734][T17331]   FSC = 0x04: level 0 translation fault\n  [ 1147.995292][T17331] Data abort info:\n  [ 1147.998858][T17331]   ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000\n  [ 1148.005023][T17331]   CM = 0, WnR = 0, TnD = 0, TagAccess = 0\n  [ 1148.010759][T17331]   GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0\n  [ 1148.016752][T17331] [dead000000000150] address between user and kernel address ranges\n  [ 1148.024571][T17331] Internal error: Oops: 0000000096000004 [#1] SMP\n  [ 1148.030825][T17331] Modules linked in: team_mode_loadbalance team nlmon act_gact cls_flower sch_ingress bonding tls macvlan dummy ib_core bridge stp llc veth amdgpu amdxcp mfd_core gpu_sched drm_exec drm_buddy radeon crct10dif_ce video drm_suballoc_helper ghash_ce drm_ttm_helper sha2_ce ttm sha256_arm64 i2c_algo_bit sha1_ce sbsa_gwdt cp210x drm_display_helper cec sr_mod cdrom drm_kms_helper binfmt_misc sg loop fuse drm dm_mod nfnetlink ip_tables autofs4 [last unloaded: tls]\n  [ 1148.072808][T17331] CPU: 3 PID: 17331 Comm: ls Tainted: G        W         ------- ----  6.6.43 #2\n  [ 1148.081751][T17331] Source Version: 21b3b386e948bedd29369af66f3e98ab01b1c650\n  [ 1148.088783][T17331] Hardware name: Greatwall GW-001M1A-FTF/GW-001M1A-FTF, BIOS KunLun BIOS V4.0 07/16/2020\n  [ 1148.098419][T17331] pstate: 20000005 (nzCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n  [ 1148.106060][T17331] pc : eventfs_iterate+0x2c0/0x398\n  [ 1148.111017][T17331] lr : eventfs_iterate+0x2fc/0x398\n  [ 1148.115969][T17331] sp : ffff80008d56bbd0\n  [ 1148.119964][T17331] x29: ffff80008d56bbf0 x28: ffff001ff5be2600 x27: 0000000000000000\n  [ 1148.127781][T17331] x26: ffff001ff52ca4e0 x25: 0000000000009977 x24: dead000000000100\n  [ 1148.135598][T17331] x23: 0000000000000000 x22: 000000000000000b x21: ffff800082645f10\n  [ 1148.143415][T17331] x20: ffff001fddf87c70 x19: ffff80008d56bc90 x18: 0000000000000000\n  [ 1148.151231][T17331] x17: 0000000000000000 x16: 0000000000000000 x15: ffff001ff52ca4e0\n  [ 1148.159048][T17331] x14: 0000000000000000 x13: 0000000000000000 x12: 0000000000000000\n  [ 1148.166864][T17331] x11: 0000000000000000 x10: 0000000000000000 x9 : ffff8000804391d0\n  [ 1148.174680][T17331] x8 : 0000000180000000 x7 : 0000000000000018 x6 : 0000aaab04b92862\n  [ 1148.182498][T17331] x5 : 0000aaab04b92862 x4 : 0000000080000000 x3 : 0000000000000068\n  [ 1148.190314][T17331] x2 : 000000000000000f x1 : 0000000000007ea8 x0 : 0000000000000001\n  [ 1148.198131][T17331] Call trace:\n  [ 1148.201259][T17331]  eventfs_iterate+0x2c0/0x398\n  [ 1148.205864][T17331]  iterate_dir+0x98/0x188\n  [ 1148.210036][T17331]  __arm64_sys_getdents64+0x78/0x160\n  [ 1148.215161][T17331]  invoke_syscall+0x78/0x108\n  [ 1148.219593][T17331]  el0_svc_common.constprop.0+0x48/0xf0\n  [ 1148.224977][T17331]  do_el0_svc+0x24/0x38\n  [ 1148.228974][T17331]  el0_svc+0x40/0x168\n  [ 1148.232798][T17\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/05e08297c3c298d8ec28e5a5adb55840312dd87e"
          },
          {
            "url": "https://git.kernel.org/stable/c/d2603279c7d645bf0d11fa253b23f1ab48fc8d3c"
          },
          {
            "url": "https://git.kernel.org/stable/c/f579d17a86448779f9642ad8baca6e3036a8e2d6"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46786",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:05.783",
        "lastModified": "2024-09-18T08:15:05.783",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nfscache: delete fscache_cookie_lru_timer when fscache exits to avoid UAF\nThe fscache_cookie_lru_timer is initialized when the fscache module\nis inserted, but is not deleted when the fscache module is removed.\nIf timer_reduce() is called before removing the fscache module,\nthe fscache_cookie_lru_timer will be added to the timer list of\nthe current cpu. Afterwards, a use-after-free will be triggered\nin the softIRQ after removing the fscache module, as follows:\n==================================================================\nBUG: unable to handle page fault for address: fffffbfff803c9e9\n PF: supervisor read access in kernel mode\n PF: error_code(0x0000) - not-present page\nPGD 21ffea067 P4D 21ffea067 PUD 21ffe6067 PMD 110a7c067 PTE 0\nOops: Oops: 0000 [#1] PREEMPT SMP KASAN PTI\nCPU: 1 UID: 0 PID: 0 Comm: swapper/1 Tainted: G W 6.11.0-rc3 #855\nTainted: [W]=WARN\nRIP: 0010:__run_timer_base.part.0+0x254/0x8a0\nCall Trace:\n <IRQ>\n tmigr_handle_remote_up+0x627/0x810\n __walk_groups.isra.0+0x47/0x140\n tmigr_handle_remote+0x1fa/0x2f0\n handle_softirqs+0x180/0x590\n irq_exit_rcu+0x84/0xb0\n sysvec_apic_timer_interrupt+0x6e/0x90\n </IRQ>\n <TASK>\n asm_sysvec_apic_timer_interrupt+0x1a/0x20\nRIP: 0010:default_idle+0xf/0x20\n default_idle_call+0x38/0x60\n do_idle+0x2b5/0x300\n cpu_startup_entry+0x54/0x60\n start_secondary+0x20d/0x280\n common_startup_64+0x13e/0x148\n </TASK>\nModules linked in: [last unloaded: netfs]\n==================================================================\nTherefore delete fscache_cookie_lru_timer when removing the fscahe module.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0a11262549ac2ac6fb98c7cd40a67136817e5a52"
          },
          {
            "url": "https://git.kernel.org/stable/c/72a6e22c604c95ddb3b10b5d3bb85b6ff4dbc34f"
          },
          {
            "url": "https://git.kernel.org/stable/c/e0d724932ad12e3528f4ce97fc0f6078d0cce4bc"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46787",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:05.833",
        "lastModified": "2024-09-18T08:15:05.833",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nuserfaultfd: fix checks for huge PMDs\nPatch series \"userfaultfd: fix races around pmd_trans_huge() check\", v2.\nThe pmd_trans_huge() code in mfill_atomic() is wrong in three different\nways depending on kernel version:\n1. The pmd_trans_huge() check is racy and can lead to a BUG_ON() (if you hit\n   the right two race windows) - I've tested this in a kernel build with\n   some extra mdelay() calls. See the commit message for a description\n   of the race scenario.\n   On older kernels (before 6.5), I think the same bug can even\n   theoretically lead to accessing transhuge page contents as a page table\n   if you hit the right 5 narrow race windows (I haven't tested this case).\n2. As pointed out by Qi Zheng, pmd_trans_huge() is not sufficient for\n   detecting PMDs that don't point to page tables.\n   On older kernels (before 6.5), you'd just have to win a single fairly\n   wide race to hit this.\n   I've tested this on 6.1 stable by racing migration (with a mdelay()\n   patched into try_to_migrate()) against UFFDIO_ZEROPAGE - on my x86\n   VM, that causes a kernel oops in ptlock_ptr().\n3. On newer kernels (>=6.5), for shmem mappings, khugepaged is allowed\n   to yank page tables out from under us (though I haven't tested that),\n   so I think the BUG_ON() checks in mfill_atomic() are just wrong.\nI decided to write two separate fixes for these (one fix for bugs 1+2, one\nfix for bug 3), so that the first fix can be backported to kernels\naffected by bugs 1+2.\nThis patch (of 2):\nThis fixes two issues.\nI discovered that the following race can occur:\n  mfill_atomic                other thread\n  ============                ============\n                              <zap PMD>\n  pmdp_get_lockless() [reads none pmd]\n  <bail if trans_huge>\n  <if none:>\n                              <pagefault creates transhuge zeropage>\n    __pte_alloc [no-op]\n                              <zap PMD>\n  <bail if pmd_trans_huge(*dst_pmd)>\n  BUG_ON(pmd_none(*dst_pmd))\nI have experimentally verified this in a kernel with extra mdelay() calls;\nthe BUG_ON(pmd_none(*dst_pmd)) triggers.\nOn kernels newer than commit 0d940a9b270b (\"mm/pgtable: allow\npte_offset_map[_lock]() to fail\"), this can't lead to anything worse than\na BUG_ON(), since the page table access helpers are actually designed to\ndeal with page tables concurrently disappearing; but on older kernels\n(<=6.4), I think we could probably theoretically race past the two\nBUG_ON() checks and end up treating a hugepage as a page table.\nThe second issue is that, as Qi Zheng pointed out, there are other types\nof huge PMDs that pmd_trans_huge() can't catch: devmap PMDs and swap PMDs\n(in particular, migration PMDs).\nOn <=6.4, this is worse than the first issue: If mfill_atomic() runs on a\nPMD that contains a migration entry (which just requires winning a single,\nfairly wide race), it will pass the PMD to pte_offset_map_lock(), which\nassumes that the PMD points to a page table.\nBreakage follows: First, the kernel tries to take the PTE lock (which will\ncrash or maybe worse if there is no \"struct page\" for the address bits in\nthe migration entry PMD - I think at least on X86 there usually is no\ncorresponding \"struct page\" thanks to the PTE inversion mitigation, amd64\nlooks different).\nIf that didn't crash, the kernel would next try to write a PTE into what\nit wrongly thinks is a page table.\nAs part of fixing these issues, get rid of the check for pmd_trans_huge()\nbefore __pte_alloc() - that's redundant, we're going to have to check for\nthat after the __pte_alloc() anyway.\nBackport note: pmdp_get_lockless() is pmd_read_atomic() in older kernels.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3c6b4bcf37845c9359aed926324bed66bdd2448d"
          },
          {
            "url": "https://git.kernel.org/stable/c/71c186efc1b2cf1aeabfeff3b9bd5ac4c5ac14d8"
          },
          {
            "url": "https://git.kernel.org/stable/c/98cc18b1b71e23fe81a5194ed432b20c2d81a01a"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46788",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:05.893",
        "lastModified": "2024-09-18T08:15:05.893",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ntracing/osnoise: Use a cpumask to know what threads are kthreads\nThe start_kthread() and stop_thread() code was not always called with the\ninterface_lock held. This means that the kthread variable could be\nunexpectedly changed causing the kthread_stop() to be called on it when it\nshould not have been, leading to:\n while true; do\n   rtla timerlat top -u -q & PID=$!;\n   sleep 5;\n   kill -INT $PID;\n   sleep 0.001;\n   kill -TERM $PID;\n   wait $PID;\n  done\nCausing the following OOPS:\n Oops: general protection fault, probably for non-canonical address 0xdffffc0000000002: 0000 [#1] PREEMPT SMP KASAN PTI\n KASAN: null-ptr-deref in range [0x0000000000000010-0x0000000000000017]\n CPU: 5 UID: 0 PID: 885 Comm: timerlatu/5 Not tainted 6.11.0-rc4-test-00002-gbc754cc76d1b-dirty #125 a533010b71dab205ad2f507188ce8c82203b0254\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2 04/01/2014\n RIP: 0010:hrtimer_active+0x58/0x300\n Code: 48 c1 ee 03 41 54 48 01 d1 48 01 d6 55 53 48 83 ec 20 80 39 00 0f 85 30 02 00 00 49 8b 6f 30 4c 8d 75 10 4c 89 f0 48 c1 e8 03 <0f> b6 3c 10 4c 89 f0 83 e0 07 83 c0 03 40 38 f8 7c 09 40 84 ff 0f\n RSP: 0018:ffff88811d97f940 EFLAGS: 00010202\n RAX: 0000000000000002 RBX: ffff88823c6b5b28 RCX: ffffed10478d6b6b\n RDX: dffffc0000000000 RSI: ffffed10478d6b6c RDI: ffff88823c6b5b28\n RBP: 0000000000000000 R08: ffff88823c6b5b58 R09: ffff88823c6b5b60\n R10: ffff88811d97f957 R11: 0000000000000010 R12: 00000000000a801d\n R13: ffff88810d8b35d8 R14: 0000000000000010 R15: ffff88823c6b5b28\n FS:  0000000000000000(0000) GS:ffff88823c680000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000561858ad7258 CR3: 000000007729e001 CR4: 0000000000170ef0\n Call Trace:\n  <TASK>\n  ? die_addr+0x40/0xa0\n  ? exc_general_protection+0x154/0x230\n  ? asm_exc_general_protection+0x26/0x30\n  ? hrtimer_active+0x58/0x300\n  ? __pfx_mutex_lock+0x10/0x10\n  ? __pfx_locks_remove_file+0x10/0x10\n  hrtimer_cancel+0x15/0x40\n  timerlat_fd_release+0x8e/0x1f0\n  ? security_file_release+0x43/0x80\n  __fput+0x372/0xb10\n  task_work_run+0x11e/0x1f0\n  ? _raw_spin_lock+0x85/0xe0\n  ? __pfx_task_work_run+0x10/0x10\n  ? poison_slab_object+0x109/0x170\n  ? do_exit+0x7a0/0x24b0\n  do_exit+0x7bd/0x24b0\n  ? __pfx_migrate_enable+0x10/0x10\n  ? __pfx_do_exit+0x10/0x10\n  ? __pfx_read_tsc+0x10/0x10\n  ? ktime_get+0x64/0x140\n  ? _raw_spin_lock_irq+0x86/0xe0\n  do_group_exit+0xb0/0x220\n  get_signal+0x17ba/0x1b50\n  ? vfs_read+0x179/0xa40\n  ? timerlat_fd_read+0x30b/0x9d0\n  ? __pfx_get_signal+0x10/0x10\n  ? __pfx_timerlat_fd_read+0x10/0x10\n  arch_do_signal_or_restart+0x8c/0x570\n  ? __pfx_arch_do_signal_or_restart+0x10/0x10\n  ? vfs_read+0x179/0xa40\n  ? ksys_read+0xfe/0x1d0\n  ? __pfx_ksys_read+0x10/0x10\n  syscall_exit_to_user_mode+0xbc/0x130\n  do_syscall_64+0x74/0x110\n  ? __pfx___rseq_handle_notify_resume+0x10/0x10\n  ? __pfx_ksys_read+0x10/0x10\n  ? fpregs_restore_userregs+0xdb/0x1e0\n  ? fpregs_restore_userregs+0xdb/0x1e0\n  ? syscall_exit_to_user_mode+0x116/0x130\n  ? do_syscall_64+0x74/0x110\n  ? do_syscall_64+0x74/0x110\n  ? do_syscall_64+0x74/0x110\n  entry_SYSCALL_64_after_hwframe+0x71/0x79\n RIP: 0033:0x7ff0070eca9c\n Code: Unable to access opcode bytes at 0x7ff0070eca72.\n RSP: 002b:00007ff006dff8c0 EFLAGS: 00000246 ORIG_RAX: 0000000000000000\n RAX: 0000000000000000 RBX: 0000000000000005 RCX: 00007ff0070eca9c\n RDX: 0000000000000400 RSI: 00007ff006dff9a0 RDI: 0000000000000003\n RBP: 00007ff006dffde0 R08: 0000000000000000 R09: 00007ff000000ba0\n R10: 00007ff007004b08 R11: 0000000000000246 R12: 0000000000000003\n R13: 00007ff006dff9a0 R14: 0000000000000007 R15: 0000000000000008\n  </TASK>\n Modules linked in: snd_hda_intel snd_intel_dspcfg snd_intel_sdw_acpi snd_hda_codec snd_hwdep snd_hda_core\n ---[ end trace 0000000000000000 ]---\nThis is because it would mistakenly call kthread_stop() on a user space\nthread making it \"exit\" before it actually exits.\nSince kthread\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/177e1cc2f41235c145041eed03ef5bab18f32328"
          },
          {
            "url": "https://git.kernel.org/stable/c/27282d2505b402f39371fd60d19d95c01a4b6776"
          },
          {
            "url": "https://git.kernel.org/stable/c/7a5f01828edf152c144d27cf63de446fdf2dc222"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46789",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:05.957",
        "lastModified": "2024-09-18T08:15:05.957",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmm/slub: add check for s->flags in the alloc_tagging_slab_free_hook\nWhen enable CONFIG_MEMCG & CONFIG_KFENCE & CONFIG_KMEMLEAK, the following\nwarning always occurs,This is because the following call stack occurred:\nmem_pool_alloc\n    kmem_cache_alloc_noprof\n        slab_alloc_node\n            kfence_alloc\nOnce the kfence allocation is successful,slab->obj_exts will not be empty,\nbecause it has already been assigned a value in kfence_init_pool.\nSince in the prepare_slab_obj_exts_hook function,we perform a check for\ns->flags & (SLAB_NO_OBJ_EXT | SLAB_NOLEAKTRACE),the alloc_tag_add function\nwill not be called as a result.Therefore,ref->ct remains NULL.\nHowever,when we call mem_pool_free,since obj_ext is not empty, it\neventually leads to the alloc_tag_sub scenario being invoked.  This is\nwhere the warning occurs.\nSo we should add corresponding checks in the alloc_tagging_slab_free_hook.\nFor __GFP_NO_OBJ_EXT case,I didn't see the specific case where it's using\nkfence,so I won't add the corresponding check in\nalloc_tagging_slab_free_hook for now.\n[    3.734349] ------------[ cut here ]------------\n[    3.734807] alloc_tag was not set\n[    3.735129] WARNING: CPU: 4 PID: 40 at ./include/linux/alloc_tag.h:130 kmem_cache_free+0x444/0x574\n[    3.735866] Modules linked in: autofs4\n[    3.736211] CPU: 4 UID: 0 PID: 40 Comm: ksoftirqd/4 Tainted: G        W          6.11.0-rc3-dirty #1\n[    3.736969] Tainted: [W]=WARN\n[    3.737258] Hardware name: QEMU KVM Virtual Machine, BIOS unknown 2/2/2022\n[    3.737875] pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[    3.738501] pc : kmem_cache_free+0x444/0x574\n[    3.738951] lr : kmem_cache_free+0x444/0x574\n[    3.739361] sp : ffff80008357bb60\n[    3.739693] x29: ffff80008357bb70 x28: 0000000000000000 x27: 0000000000000000\n[    3.740338] x26: ffff80008207f000 x25: ffff000b2eb2fd60 x24: ffff0000c0005700\n[    3.740982] x23: ffff8000804229e4 x22: ffff800082080000 x21: ffff800081756000\n[    3.741630] x20: fffffd7ff8253360 x19: 00000000000000a8 x18: ffffffffffffffff\n[    3.742274] x17: ffff800ab327f000 x16: ffff800083398000 x15: ffff800081756df0\n[    3.742919] x14: 0000000000000000 x13: 205d344320202020 x12: 5b5d373038343337\n[    3.743560] x11: ffff80008357b650 x10: 000000000000005d x9 : 00000000ffffffd0\n[    3.744231] x8 : 7f7f7f7f7f7f7f7f x7 : ffff80008237bad0 x6 : c0000000ffff7fff\n[    3.744907] x5 : ffff80008237ba78 x4 : ffff8000820bbad0 x3 : 0000000000000001\n[    3.745580] x2 : 68d66547c09f7800 x1 : 68d66547c09f7800 x0 : 0000000000000000\n[    3.746255] Call trace:\n[    3.746530]  kmem_cache_free+0x444/0x574\n[    3.746931]  mem_pool_free+0x44/0xf4\n[    3.747306]  free_object_rcu+0xc8/0xdc\n[    3.747693]  rcu_do_batch+0x234/0x8a4\n[    3.748075]  rcu_core+0x230/0x3e4\n[    3.748424]  rcu_core_si+0x14/0x1c\n[    3.748780]  handle_softirqs+0x134/0x378\n[    3.749189]  run_ksoftirqd+0x70/0x9c\n[    3.749560]  smpboot_thread_fn+0x148/0x22c\n[    3.749978]  kthread+0x10c/0x118\n[    3.750323]  ret_from_fork+0x10/0x20\n[    3.750696] ---[ end trace 0000000000000000 ]---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2d476c86ba4745fcbc912ce4627df4fa80caa9ad"
          },
          {
            "url": "https://git.kernel.org/stable/c/ab7ca09520e9c41c219a4427fe0dae24024bfe7f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46790",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:06.010",
        "lastModified": "2024-09-18T08:15:06.010",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ncodetag: debug: mark codetags for poisoned page as empty\nWhen PG_hwpoison pages are freed they are treated differently in\nfree_pages_prepare() and instead of being released they are isolated.\nPage allocation tag counters are decremented at this point since the page\nis considered not in use.  Later on when such pages are released by\nunpoison_memory(), the allocation tag counters will be decremented again\nand the following warning gets reported:\n[  113.930443][ T3282] ------------[ cut here ]------------\n[  113.931105][ T3282] alloc_tag was not set\n[  113.931576][ T3282] WARNING: CPU: 2 PID: 3282 at ./include/linux/alloc_tag.h:130 pgalloc_tag_sub.part.66+0x154/0x164\n[  113.932866][ T3282] Modules linked in: hwpoison_inject fuse ip6t_rpfilter ip6t_REJECT nf_reject_ipv6 ipt_REJECT nf_reject_ipv4 xt_conntrack ebtable_nat ebtable_broute ip6table_nat ip6table_man4\n[  113.941638][ T3282] CPU: 2 UID: 0 PID: 3282 Comm: madvise11 Kdump: loaded Tainted: G        W          6.11.0-rc4-dirty #18\n[  113.943003][ T3282] Tainted: [W]=WARN\n[  113.943453][ T3282] Hardware name: QEMU KVM Virtual Machine, BIOS unknown 2/2/2022\n[  113.944378][ T3282] pstate: 40400005 (nZcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[  113.945319][ T3282] pc : pgalloc_tag_sub.part.66+0x154/0x164\n[  113.946016][ T3282] lr : pgalloc_tag_sub.part.66+0x154/0x164\n[  113.946706][ T3282] sp : ffff800087093a10\n[  113.947197][ T3282] x29: ffff800087093a10 x28: ffff0000d7a9d400 x27: ffff80008249f0a0\n[  113.948165][ T3282] x26: 0000000000000000 x25: ffff80008249f2b0 x24: 0000000000000000\n[  113.949134][ T3282] x23: 0000000000000001 x22: 0000000000000001 x21: 0000000000000000\n[  113.950597][ T3282] x20: ffff0000c08fcad8 x19: ffff80008251e000 x18: ffffffffffffffff\n[  113.952207][ T3282] x17: 0000000000000000 x16: 0000000000000000 x15: ffff800081746210\n[  113.953161][ T3282] x14: 0000000000000000 x13: 205d323832335420 x12: 5b5d353031313339\n[  113.954120][ T3282] x11: ffff800087093500 x10: 000000000000005d x9 : 00000000ffffffd0\n[  113.955078][ T3282] x8 : 7f7f7f7f7f7f7f7f x7 : ffff80008236ba90 x6 : c0000000ffff7fff\n[  113.956036][ T3282] x5 : ffff000b34bf4dc8 x4 : ffff8000820aba90 x3 : 0000000000000001\n[  113.956994][ T3282] x2 : ffff800ab320f000 x1 : 841d1e35ac932e00 x0 : 0000000000000000\n[  113.957962][ T3282] Call trace:\n[  113.958350][ T3282]  pgalloc_tag_sub.part.66+0x154/0x164\n[  113.959000][ T3282]  pgalloc_tag_sub+0x14/0x1c\n[  113.959539][ T3282]  free_unref_page+0xf4/0x4b8\n[  113.960096][ T3282]  __folio_put+0xd4/0x120\n[  113.960614][ T3282]  folio_put+0x24/0x50\n[  113.961103][ T3282]  unpoison_memory+0x4f0/0x5b0\n[  113.961678][ T3282]  hwpoison_unpoison+0x30/0x48 [hwpoison_inject]\n[  113.962436][ T3282]  simple_attr_write_xsigned.isra.34+0xec/0x1cc\n[  113.963183][ T3282]  simple_attr_write+0x38/0x48\n[  113.963750][ T3282]  debugfs_attr_write+0x54/0x80\n[  113.964330][ T3282]  full_proxy_write+0x68/0x98\n[  113.964880][ T3282]  vfs_write+0xdc/0x4d0\n[  113.965372][ T3282]  ksys_write+0x78/0x100\n[  113.965875][ T3282]  __arm64_sys_write+0x24/0x30\n[  113.966440][ T3282]  invoke_syscall+0x7c/0x104\n[  113.966984][ T3282]  el0_svc_common.constprop.1+0x88/0x104\n[  113.967652][ T3282]  do_el0_svc+0x2c/0x38\n[  113.968893][ T3282]  el0_svc+0x3c/0x1b8\n[  113.969379][ T3282]  el0t_64_sync_handler+0x98/0xbc\n[  113.969980][ T3282]  el0t_64_sync+0x19c/0x1a0\n[  113.970511][ T3282] ---[ end trace 0000000000000000 ]---\nTo fix this, clear the page tag reference after the page got isolated\nand accounted for.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/16ad36c8e66a26626e7d0224100b433483a2acef"
          },
          {
            "url": "https://git.kernel.org/stable/c/5e9784e997620af7c1399029282f5d6964b41942"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46791",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:06.067",
        "lastModified": "2024-09-18T08:15:06.067",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ncan: mcp251x: fix deadlock if an interrupt occurs during mcp251x_open\nThe mcp251x_hw_wake() function is called with the mpc_lock mutex held and\ndisables the interrupt handler so that no interrupts can be processed while\nwaking the device. If an interrupt has already occurred then waiting for\nthe interrupt handler to complete will deadlock because it will be trying\nto acquire the same mutex.\nCPU0                           CPU1\n----                           ----\nmcp251x_open()\n mutex_lock(&priv->mcp_lock)\n  request_threaded_irq()\n                               <interrupt>\n                               mcp251x_can_ist()\n                                mutex_lock(&priv->mcp_lock)\n  mcp251x_hw_wake()\n   disable_irq() <-- deadlock\nUse disable_irq_nosync() instead because the interrupt handler does\neverything while holding the mutex so it doesn't matter if it's still\nrunning.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3a49b6b1caf5cefc05264d29079d52c99cb188e0"
          },
          {
            "url": "https://git.kernel.org/stable/c/513c8fc189b52f7922e36bdca58997482b198f0e"
          },
          {
            "url": "https://git.kernel.org/stable/c/7dd9c26bd6cf679bcfdef01a8659791aa6487a29"
          },
          {
            "url": "https://git.kernel.org/stable/c/8fecde9c3f9a4b97b68bb97c9f47e5b662586ba7"
          },
          {
            "url": "https://git.kernel.org/stable/c/e554113a1cd2a9cfc6c7af7bdea2141c5757e188"
          },
          {
            "url": "https://git.kernel.org/stable/c/f7ab9e14b23a3eac6714bdc4dba244d8aa1ef646"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46792",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:06.123",
        "lastModified": "2024-09-18T08:15:06.123",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nriscv: misaligned: Restrict user access to kernel memory\nraw_copy_{to,from}_user() do not call access_ok(), so this code allowed\nuserspace to access any virtual memory address.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/a3b6ff6c896aee5ef9b581e40d0045ff04fcbc8c"
          },
          {
            "url": "https://git.kernel.org/stable/c/b686ecdeacf6658e1348c1a32a08e2e72f7c0f00"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46793",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:06.177",
        "lastModified": "2024-09-18T08:15:06.177",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nASoC: Intel: Boards: Fix NULL pointer deref in BYT/CHT boards harder\nSince commit 13f58267cda3 (\"ASoC: soc.h: don't create dummy Component\nvia COMP_DUMMY()\") dummy codecs declared like this:\nSND_SOC_DAILINK_DEF(dummy,\n        DAILINK_COMP_ARRAY(COMP_DUMMY()));\nexpand to:\nstatic struct snd_soc_dai_link_component dummy[] = {\n};\nWhich means that dummy is a zero sized array and thus dais[i].codecs should\nnot be dereferenced *at all* since it points to the address of the next\nvariable stored in the data section as the \"dummy\" variable has an address\nbut no size, so even dereferencing dais[0] is already an out of bounds\narray reference.\nWhich means that the if (dais[i].codecs->name) check added in\ncommit 7d99a70b6595 (\"ASoC: Intel: Boards: Fix NULL pointer deref\nin BYT/CHT boards\") relies on that the part of the next variable which\nthe name member maps to just happens to be NULL.\nWhich apparently so far it usually is, except when it isn't\nand then it results in crashes like this one:\n[   28.795659] BUG: unable to handle page fault for address: 0000000000030011\n...\n[   28.795780] Call Trace:\n[   28.795787]  <TASK>\n...\n[   28.795862]  ? strcmp+0x18/0x40\n[   28.795872]  0xffffffffc150c605\n[   28.795887]  platform_probe+0x40/0xa0\n...\n[   28.795979]  ? __pfx_init_module+0x10/0x10 [snd_soc_sst_bytcr_wm5102]\nReally fix things this time around by checking dais.num_codecs != 0.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0cc65482f5b03ac2b1c240bc34665e43ea2d71bb"
          },
          {
            "url": "https://git.kernel.org/stable/c/85cda5b040bda9c577b34eb72d5b2e5b7e31985c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46794",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:06.230",
        "lastModified": "2024-09-18T08:15:06.230",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nx86/tdx: Fix data leak in mmio_read()\nThe mmio_read() function makes a TDVMCALL to retrieve MMIO data for an\naddress from the VMM.\nSean noticed that mmio_read() unintentionally exposes the value of an\ninitialized variable (val) on the stack to the VMM.\nThis variable is only needed as an output value. It did not need to be\npassed to the VMM in the first place.\nDo not send the original value of *val to the VMM.\n[ dhansen: clarify what 'val' is used for. ]",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/26c6af49d26ffc377e392e30d4086db19eed0ef7"
          },
          {
            "url": "https://git.kernel.org/stable/c/b55ce742afcb8e8189d82f2f1e635ba1b5a461fa"
          },
          {
            "url": "https://git.kernel.org/stable/c/b6fb565a2d15277896583d471b21bc14a0c99661"
          },
          {
            "url": "https://git.kernel.org/stable/c/ef00818c50cf55a3a56bd9a9fae867c92dfb84e7"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46795",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:06.280",
        "lastModified": "2024-09-18T08:15:06.280",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nksmbd: unset the binding mark of a reused connection\nSteve French reported null pointer dereference error from sha256 lib.\ncifs.ko can send session setup requests on reused connection.\nIf reused connection is used for binding session, conn->binding can\nstill remain true and generate_preauth_hash() will not set\nsess->Preauth_HashValue and it will be NULL.\nIt is used as a material to create an encryption key in\nksmbd_gen_smb311_encryptionkey. ->Preauth_HashValue cause null pointer\ndereference error from crypto_shash_update().\nBUG: kernel NULL pointer dereference, address: 0000000000000000\n#PF: supervisor read access in kernel mode\n#PF: error_code(0x0000) - not-present page\nPGD 0 P4D 0\nOops: 0000 [#1] PREEMPT SMP PTI\nCPU: 8 PID: 429254 Comm: kworker/8:39\nHardware name: LENOVO 20MAS08500/20MAS08500, BIOS N2CET69W (1.52 )\nWorkqueue: ksmbd-io handle_ksmbd_work [ksmbd]\nRIP: 0010:lib_sha256_base_do_update.isra.0+0x11e/0x1d0 [sha256_ssse3]\n<TASK>\n? show_regs+0x6d/0x80\n? __die+0x24/0x80\n? page_fault_oops+0x99/0x1b0\n? do_user_addr_fault+0x2ee/0x6b0\n? exc_page_fault+0x83/0x1b0\n? asm_exc_page_fault+0x27/0x30\n? __pfx_sha256_transform_rorx+0x10/0x10 [sha256_ssse3]\n? lib_sha256_base_do_update.isra.0+0x11e/0x1d0 [sha256_ssse3]\n? __pfx_sha256_transform_rorx+0x10/0x10 [sha256_ssse3]\n? __pfx_sha256_transform_rorx+0x10/0x10 [sha256_ssse3]\n_sha256_update+0x77/0xa0 [sha256_ssse3]\nsha256_avx2_update+0x15/0x30 [sha256_ssse3]\ncrypto_shash_update+0x1e/0x40\nhmac_update+0x12/0x20\ncrypto_shash_update+0x1e/0x40\ngenerate_key+0x234/0x380 [ksmbd]\ngenerate_smb3encryptionkey+0x40/0x1c0 [ksmbd]\nksmbd_gen_smb311_encryptionkey+0x72/0xa0 [ksmbd]\nntlm_authenticate.isra.0+0x423/0x5d0 [ksmbd]\nsmb2_sess_setup+0x952/0xaa0 [ksmbd]\n__process_request+0xa3/0x1d0 [ksmbd]\n__handle_ksmbd_work+0x1c4/0x2f0 [ksmbd]\nhandle_ksmbd_work+0x2d/0xa0 [ksmbd]\nprocess_one_work+0x16c/0x350\nworker_thread+0x306/0x440\n? __pfx_worker_thread+0x10/0x10\nkthread+0xef/0x120\n? __pfx_kthread+0x10/0x10\nret_from_fork+0x44/0x70\n? __pfx_kthread+0x10/0x10\nret_from_fork_asm+0x1b/0x30\n</TASK>",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/41bc256da7e47b679df87c7fc7a5b393052b9cce"
          },
          {
            "url": "https://git.kernel.org/stable/c/4c8496f44f5bb5c06cdef5eb130ab259643392a1"
          },
          {
            "url": "https://git.kernel.org/stable/c/78c5a6f1f630172b19af4912e755e1da93ef0ab5"
          },
          {
            "url": "https://git.kernel.org/stable/c/93d54a4b59c4b3d803d20aa645ab5ca71f3b3b02"
          },
          {
            "url": "https://git.kernel.org/stable/c/9914f1bd61d5e838bb1ab15a71076d37a6db65d1"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46796",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:06.340",
        "lastModified": "2024-09-18T08:15:06.340",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nsmb: client: fix double put of @cfile in smb2_set_path_size()\nIf smb2_compound_op() is called with a valid @cfile and returned\n-EINVAL, we need to call cifs_get_writable_path() before retrying it\nas the reference of @cfile was already dropped by previous call.\nThis fixes the following KASAN splat when running fstests generic/013\nagainst Windows Server 2022:\n  CIFS: Attempting to mount //w22-fs0/scratch\n  run fstests generic/013 at 2024-09-02 19:48:59\n  ==================================================================\n  BUG: KASAN: slab-use-after-free in detach_if_pending+0xab/0x200\n  Write of size 8 at addr ffff88811f1a3730 by task kworker/3:2/176\n  CPU: 3 UID: 0 PID: 176 Comm: kworker/3:2 Not tainted 6.11.0-rc6 #2\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-2.fc40\n  04/01/2014\n  Workqueue: cifsoplockd cifs_oplock_break [cifs]\n  Call Trace:\n   <TASK>\n   dump_stack_lvl+0x5d/0x80\n   ? detach_if_pending+0xab/0x200\n   print_report+0x156/0x4d9\n   ? detach_if_pending+0xab/0x200\n   ? __virt_addr_valid+0x145/0x300\n   ? __phys_addr+0x46/0x90\n   ? detach_if_pending+0xab/0x200\n   kasan_report+0xda/0x110\n   ? detach_if_pending+0xab/0x200\n   detach_if_pending+0xab/0x200\n   timer_delete+0x96/0xe0\n   ? __pfx_timer_delete+0x10/0x10\n   ? rcu_is_watching+0x20/0x50\n   try_to_grab_pending+0x46/0x3b0\n   __cancel_work+0x89/0x1b0\n   ? __pfx___cancel_work+0x10/0x10\n   ? kasan_save_track+0x14/0x30\n   cifs_close_deferred_file+0x110/0x2c0 [cifs]\n   ? __pfx_cifs_close_deferred_file+0x10/0x10 [cifs]\n   ? __pfx_down_read+0x10/0x10\n   cifs_oplock_break+0x4c1/0xa50 [cifs]\n   ? __pfx_cifs_oplock_break+0x10/0x10 [cifs]\n   ? lock_is_held_type+0x85/0xf0\n   ? mark_held_locks+0x1a/0x90\n   process_one_work+0x4c6/0x9f0\n   ? find_held_lock+0x8a/0xa0\n   ? __pfx_process_one_work+0x10/0x10\n   ? lock_acquired+0x220/0x550\n   ? __list_add_valid_or_report+0x37/0x100\n   worker_thread+0x2e4/0x570\n   ? __kthread_parkme+0xd1/0xf0\n   ? __pfx_worker_thread+0x10/0x10\n   kthread+0x17f/0x1c0\n   ? kthread+0xda/0x1c0\n   ? __pfx_kthread+0x10/0x10\n   ret_from_fork+0x31/0x60\n   ? __pfx_kthread+0x10/0x10\n   ret_from_fork_asm+0x1a/0x30\n   </TASK>\n  Allocated by task 1118:\n   kasan_save_stack+0x30/0x50\n   kasan_save_track+0x14/0x30\n   __kasan_kmalloc+0xaa/0xb0\n   cifs_new_fileinfo+0xc8/0x9d0 [cifs]\n   cifs_atomic_open+0x467/0x770 [cifs]\n   lookup_open.isra.0+0x665/0x8b0\n   path_openat+0x4c3/0x1380\n   do_filp_open+0x167/0x270\n   do_sys_openat2+0x129/0x160\n   __x64_sys_creat+0xad/0xe0\n   do_syscall_64+0xbb/0x1d0\n   entry_SYSCALL_64_after_hwframe+0x77/0x7f\n  Freed by task 83:\n   kasan_save_stack+0x30/0x50\n   kasan_save_track+0x14/0x30\n   kasan_save_free_info+0x3b/0x70\n   poison_slab_object+0xe9/0x160\n   __kasan_slab_free+0x32/0x50\n   kfree+0xf2/0x300\n   process_one_work+0x4c6/0x9f0\n   worker_thread+0x2e4/0x570\n   kthread+0x17f/0x1c0\n   ret_from_fork+0x31/0x60\n   ret_from_fork_asm+0x1a/0x30\n  Last potentially related work creation:\n   kasan_save_stack+0x30/0x50\n   __kasan_record_aux_stack+0xad/0xc0\n   insert_work+0x29/0xe0\n   __queue_work+0x5ea/0x760\n   queue_work_on+0x6d/0x90\n   _cifsFileInfo_put+0x3f6/0x770 [cifs]\n   smb2_compound_op+0x911/0x3940 [cifs]\n   smb2_set_path_size+0x228/0x270 [cifs]\n   cifs_set_file_size+0x197/0x460 [cifs]\n   cifs_setattr+0xd9c/0x14b0 [cifs]\n   notify_change+0x4e3/0x740\n   do_truncate+0xfa/0x180\n   vfs_truncate+0x195/0x200\n   __x64_sys_truncate+0x109/0x150\n   do_syscall_64+0xbb/0x1d0\n   entry_SYSCALL_64_after_hwframe+0x77/0x7f",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/5a72d1edb0843e4c927a4096f81e631031c25c28"
          },
          {
            "url": "https://git.kernel.org/stable/c/762099898309218b4a7954f3d49e985dc4dfd638"
          },
          {
            "url": "https://git.kernel.org/stable/c/f9c169b51b6ce20394594ef674d6b10efba31220"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46797",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:06.403",
        "lastModified": "2024-09-18T08:15:06.403",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\npowerpc/qspinlock: Fix deadlock in MCS queue\nIf an interrupt occurs in queued_spin_lock_slowpath() after we increment\nqnodesp->count and before node->lock is initialized, another CPU might\nsee stale lock values in get_tail_qnode(). If the stale lock value happens\nto match the lock on that CPU, then we write to the \"next\" pointer of\nthe wrong qnode. This causes a deadlock as the former CPU, once it becomes\nthe head of the MCS queue, will spin indefinitely until it's \"next\" pointer\nis set by its successor in the queue.\nRunning stress-ng on a 16 core (16EC/16VP) shared LPAR, results in\noccasional lockups similar to the following:\n   $ stress-ng --all 128 --vm-bytes 80% --aggressive \\\n               --maximize --oomable --verify  --syslog \\\n               --metrics  --times  --timeout 5m\n   watchdog: CPU 15 Hard LOCKUP\n   ......\n   NIP [c0000000000b78f4] queued_spin_lock_slowpath+0x1184/0x1490\n   LR [c000000001037c5c] _raw_spin_lock+0x6c/0x90\n   Call Trace:\n    0xc000002cfffa3bf0 (unreliable)\n    _raw_spin_lock+0x6c/0x90\n    raw_spin_rq_lock_nested.part.135+0x4c/0xd0\n    sched_ttwu_pending+0x60/0x1f0\n    __flush_smp_call_function_queue+0x1dc/0x670\n    smp_ipi_demux_relaxed+0xa4/0x100\n    xive_muxed_ipi_action+0x20/0x40\n    __handle_irq_event_percpu+0x80/0x240\n    handle_irq_event_percpu+0x2c/0x80\n    handle_percpu_irq+0x84/0xd0\n    generic_handle_irq+0x54/0x80\n    __do_irq+0xac/0x210\n    __do_IRQ+0x74/0xd0\n    0x0\n    do_IRQ+0x8c/0x170\n    hardware_interrupt_common_virt+0x29c/0x2a0\n   --- interrupt: 500 at queued_spin_lock_slowpath+0x4b8/0x1490\n   ......\n   NIP [c0000000000b6c28] queued_spin_lock_slowpath+0x4b8/0x1490\n   LR [c000000001037c5c] _raw_spin_lock+0x6c/0x90\n   --- interrupt: 500\n    0xc0000029c1a41d00 (unreliable)\n    _raw_spin_lock+0x6c/0x90\n    futex_wake+0x100/0x260\n    do_futex+0x21c/0x2a0\n    sys_futex+0x98/0x270\n    system_call_exception+0x14c/0x2f0\n    system_call_vectored_common+0x15c/0x2ec\nThe following code flow illustrates how the deadlock occurs.\nFor the sake of brevity, assume that both locks (A and B) are\ncontended and we call the queued_spin_lock_slowpath() function.\n        CPU0                                   CPU1\n        ----                                   ----\n  spin_lock_irqsave(A)                          |\n  spin_unlock_irqrestore(A)                     |\n    spin_lock(B)                                |\n         |                                      |\n         ▼                                      |\n   id = qnodesp->count++;                       |\n  (Note that nodes[0].lock == A)                |\n         |                                      |\n         ▼                                      |\n      Interrupt                                 |\n  (happens before \"nodes[0].lock = B\")          |\n         |                                      |\n         ▼                                      |\n  spin_lock_irqsave(A)                          |\n         |                                      |\n         ▼                                      |\n   id = qnodesp->count++                        |\n   nodes[1].lock = A                            |\n         |                                      |\n         ▼                                      |\n  Tail of MCS queue                             |\n         |                             spin_lock_irqsave(A)\n         ▼                                      |\n  Head of MCS queue                             ▼\n         |                             CPU0 is previous tail\n         ▼                                      |\n   Spin indefinitely                            ▼\n  (until \"nodes[1].next != NULL\")      prev = get_tail_qnode(A, CPU0)\n                                                |\n                                                ▼\n                                       prev == &qnodes[CPU0].nodes[0]\n                                     (as qnodes\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/734ad0af3609464f8f93e00b6c0de1e112f44559"
          },
          {
            "url": "https://git.kernel.org/stable/c/d84ab6661e8d09092de9b034b016515ef9b66085"
          },
          {
            "url": "https://git.kernel.org/stable/c/f06af737e4be28c0e926dc25d5f0a111da4e2987"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46798",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:06.463",
        "lastModified": "2024-09-18T08:15:06.463",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nASoC: dapm: Fix UAF for snd_soc_pcm_runtime object\nWhen using kernel with the following extra config,\n  - CONFIG_KASAN=y\n  - CONFIG_KASAN_GENERIC=y\n  - CONFIG_KASAN_INLINE=y\n  - CONFIG_KASAN_VMALLOC=y\n  - CONFIG_FRAME_WARN=4096\nkernel detects that snd_pcm_suspend_all() access a freed\n'snd_soc_pcm_runtime' object when the system is suspended, which\nleads to a use-after-free bug:\n[   52.047746] BUG: KASAN: use-after-free in snd_pcm_suspend_all+0x1a8/0x270\n[   52.047765] Read of size 1 at addr ffff0000b9434d50 by task systemd-sleep/2330\n[   52.047785] Call trace:\n[   52.047787]  dump_backtrace+0x0/0x3c0\n[   52.047794]  show_stack+0x34/0x50\n[   52.047797]  dump_stack_lvl+0x68/0x8c\n[   52.047802]  print_address_description.constprop.0+0x74/0x2c0\n[   52.047809]  kasan_report+0x210/0x230\n[   52.047815]  __asan_report_load1_noabort+0x3c/0x50\n[   52.047820]  snd_pcm_suspend_all+0x1a8/0x270\n[   52.047824]  snd_soc_suspend+0x19c/0x4e0\nThe snd_pcm_sync_stop() has a NULL check on 'substream->runtime' before\nmaking any access. So we need to always set 'substream->runtime' to NULL\neverytime we kfree() it.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3033ed903b4f28b5e1ab66042084fbc2c48f8624"
          },
          {
            "url": "https://git.kernel.org/stable/c/5d13afd021eb43868fe03cef6da34ad08831ad6d"
          },
          {
            "url": "https://git.kernel.org/stable/c/6a14fad8be178df6c4589667efec1789a3307b4e"
          },
          {
            "url": "https://git.kernel.org/stable/c/8ca21e7a27c66b95a4b215edc8e45e5d66679f9f"
          },
          {
            "url": "https://git.kernel.org/stable/c/993b60c7f93fa1d8ff296b58f646a867e945ae89"
          },
          {
            "url": "https://git.kernel.org/stable/c/b4a90b543d9f62d3ac34ec1ab97fc5334b048565"
          },
          {
            "url": "https://git.kernel.org/stable/c/fe5046ca91d631ec432eee3bdb1f1c49b09c8b5e"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46799",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:06.523",
        "lastModified": "2024-09-18T08:15:06.523",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: ethernet: ti: am65-cpsw: Fix NULL dereference on XDP_TX\nIf number of TX queues are set to 1 we get a NULL pointer\ndereference during XDP_TX.\n~# ethtool -L eth0 tx 1\n~# ./xdp-trafficgen udp -A <ipv6-src> -a <ipv6-dst> eth0 -t 2\nTransmitting on eth0 (ifindex 2)\n[  241.135257] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000030\nFix this by using actual TX queues instead of max TX queues\nwhen picking the TX channel in am65_cpsw_ndo_xdp_xmit().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0a50c35277f96481a5a6ed5faf347f282040c57d"
          },
          {
            "url": "https://git.kernel.org/stable/c/2e7189d2b1de51fc2567676cd4f96c0fe0960b9f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46800",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:06.573",
        "lastModified": "2024-09-18T08:15:06.573",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nsch/netem: fix use after free in netem_dequeue\nIf netem_dequeue() enqueues packet to inner qdisc and that qdisc\nreturns __NET_XMIT_STOLEN. The packet is dropped but\nqdisc_tree_reduce_backlog() is not called to update the parent's\nq.qlen, leading to the similar use-after-free as Commit\ne04991a48dbaf382 (\"netem: fix return value if duplicate enqueue\nfails\")\nCommands to trigger KASAN UaF:\nip link add type dummy\nip link set lo up\nip link set dummy0 up\ntc qdisc add dev lo parent root handle 1: drr\ntc filter add dev lo parent 1: basic classid 1:1\ntc class add dev lo classid 1:1 drr\ntc qdisc add dev lo parent 1:1 handle 2: netem\ntc qdisc add dev lo parent 2: handle 3: drr\ntc filter add dev lo parent 3: basic classid 3:1 action mirred egress\nredirect dev dummy0\ntc class add dev lo classid 3:1 drr\nping -c1 -W0.01 localhost # Trigger bug\ntc class del dev lo classid 1:1\ntc class add dev lo classid 1:1 drr\nping -c1 -W0.01 localhost # UaF",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/14f91ab8d391f249b845916820a56f42cf747241"
          },
          {
            "url": "https://git.kernel.org/stable/c/295ad5afd9efc5f67b86c64fce28fb94e26dc4c9"
          },
          {
            "url": "https://git.kernel.org/stable/c/32008ab989ddcff1a485fa2b4906234c25dc5cd6"
          },
          {
            "url": "https://git.kernel.org/stable/c/3b3a2a9c6349e25a025d2330f479bc33a6ccb54a"
          },
          {
            "url": "https://git.kernel.org/stable/c/98c75d76187944296068d685dfd8a1e9fd8c4fdc"
          },
          {
            "url": "https://git.kernel.org/stable/c/db2c235682913a63054e741fe4e19645fdf2d68e"
          },
          {
            "url": "https://git.kernel.org/stable/c/dde33a9d0b80aae0c69594d1f462515d7ff1cb3d"
          },
          {
            "url": "https://git.kernel.org/stable/c/f0bddb4de043399f16d1969dad5ee5b984a64e7b"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-46801",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-18T08:15:06.633",
        "lastModified": "2024-09-18T08:15:06.633",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nlibfs: fix get_stashed_dentry()\nget_stashed_dentry() tries to optimistically retrieve a stashed dentry\nfrom a provided location.  It needs to ensure to hold rcu lock before it\ndereference the stashed location to prevent UAF issues.  Use\nrcu_dereference() instead of READ_ONCE() it's effectively equivalent\nwith some lockdep bells and whistles and it communicates clearly that\nthis expects rcu protection.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/03e2a1209a83a380df34a72f7d6d1bc6c74132c7"
          },
          {
            "url": "https://git.kernel.org/stable/c/4e32c25b58b945f976435bbe51f39b32d714052e"
          }
        ]
      }
    }
  ]
}