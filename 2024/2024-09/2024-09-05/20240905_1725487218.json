{
  "totalResults": 39,
  "datePublished": "2024-09-05T07:00:18.083982Z",
  "vulnerabilities": [
    {
      "cve": {
        "id": "CVE-2024-42642",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-09-04T20:15:07.007",
        "lastModified": "2024-09-04T20:15:07.007",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "Micron Crucial MX500 Series Solid State Drives M3CR046 is vulnerable to Buffer Overflow, which can be triggered by sending specially crafted ATA packets from the host to the drive controller.",
        "cweIds": null,
        "references": [
          {
            "url": "http://microncrucial.com"
          },
          {
            "url": "https://github.com/VL4DR/CVE-2024-42642/tree/main"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44974",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:07.100",
        "lastModified": "2024-09-04T20:15:07.100",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmptcp: pm: avoid possible UaF when selecting endp\nselect_local_address() and select_signal_address() both select an\nendpoint entry from the list inside an RCU protected section, but return\na reference to it, to be read later on. If the entry is dereferenced\nafter the RCU unlock, reading info could cause a Use-after-Free.\nA simple solution is to copy the required info while inside the RCU\nprotected section to avoid any risk of UaF later. The address ID might\nneed to be modified later to handle the ID0 case later, so a copy seems\nOK to deal with.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0201d65d9806d287a00e0ba96f0321835631f63f"
          },
          {
            "url": "https://git.kernel.org/stable/c/48e50dcbcbaaf713d82bf2da5c16aeced94ad07d"
          },
          {
            "url": "https://git.kernel.org/stable/c/9a9afbbc3fbfca4975eea4aa5b18556db5a0c0b8"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44975",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:07.160",
        "lastModified": "2024-09-04T20:15:07.160",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ncgroup/cpuset: fix panic caused by partcmd_update\nWe find a bug as below:\nBUG: unable to handle page fault for address: 00000003\nPGD 0 P4D 0\nOops: 0000 [#1] PREEMPT SMP NOPTI\nCPU: 3 PID: 358 Comm: bash Tainted: G        W I        6.6.0-10893-g60d6\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/4\nRIP: 0010:partition_sched_domains_locked+0x483/0x600\nCode: 01 48 85 d2 74 0d 48 83 05 29 3f f8 03 01 f3 48 0f bc c2 89 c0 48 9\nRSP: 0018:ffffc90000fdbc58 EFLAGS: 00000202\nRAX: 0000000100000003 RBX: ffff888100b3dfa0 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 000000000002fe80\nRBP: ffff888100b3dfb0 R08: 0000000000000001 R09: 0000000000000000\nR10: ffffc90000fdbcb0 R11: 0000000000000004 R12: 0000000000000002\nR13: ffff888100a92b48 R14: 0000000000000000 R15: 0000000000000000\nFS:  00007f44a5425740(0000) GS:ffff888237d80000(0000) knlGS:0000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000100030973 CR3: 000000010722c000 CR4: 00000000000006e0\nCall Trace:\n <TASK>\n ? show_regs+0x8c/0xa0\n ? __die_body+0x23/0xa0\n ? __die+0x3a/0x50\n ? page_fault_oops+0x1d2/0x5c0\n ? partition_sched_domains_locked+0x483/0x600\n ? search_module_extables+0x2a/0xb0\n ? search_exception_tables+0x67/0x90\n ? kernelmode_fixup_or_oops+0x144/0x1b0\n ? __bad_area_nosemaphore+0x211/0x360\n ? up_read+0x3b/0x50\n ? bad_area_nosemaphore+0x1a/0x30\n ? exc_page_fault+0x890/0xd90\n ? __lock_acquire.constprop.0+0x24f/0x8d0\n ? __lock_acquire.constprop.0+0x24f/0x8d0\n ? asm_exc_page_fault+0x26/0x30\n ? partition_sched_domains_locked+0x483/0x600\n ? partition_sched_domains_locked+0xf0/0x600\n rebuild_sched_domains_locked+0x806/0xdc0\n update_partition_sd_lb+0x118/0x130\n cpuset_write_resmask+0xffc/0x1420\n cgroup_file_write+0xb2/0x290\n kernfs_fop_write_iter+0x194/0x290\n new_sync_write+0xeb/0x160\n vfs_write+0x16f/0x1d0\n ksys_write+0x81/0x180\n __x64_sys_write+0x21/0x30\n x64_sys_call+0x2f25/0x4630\n do_syscall_64+0x44/0xb0\n entry_SYSCALL_64_after_hwframe+0x78/0xe2\nRIP: 0033:0x7f44a553c887\nIt can be reproduced with cammands:\ncd /sys/fs/cgroup/\nmkdir test\ncd test/\necho +cpuset > ../cgroup.subtree_control\necho root > cpuset.cpus.partition\ncat /sys/fs/cgroup/cpuset.cpus.effective\n0-3\necho 0-3 > cpuset.cpus // taking away all cpus from root\nThis issue is caused by the incorrect rebuilding of scheduling domains.\nIn this scenario, test/cpuset.cpus.partition should be an invalid root\nand should not trigger the rebuilding of scheduling domains. When calling\nupdate_parent_effective_cpumask with partcmd_update, if newmask is not\nnull, it should recheck newmask whether there are cpus is available\nfor parect/cs that has tasks.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/73d6c6cf8ef6a3c532aa159f5114077746a372d6"
          },
          {
            "url": "https://git.kernel.org/stable/c/959ab6350add903e352890af53e86663739fcb9a"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44976",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:07.223",
        "lastModified": "2024-09-04T20:15:07.223",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nata: pata_macio: Fix DMA table overflow\nKolbjørn and Jonáš reported that their 32-bit PowerMacs were crashing\nin pata-macio since commit 09fe2bfa6b83 (\"ata: pata_macio: Fix\nmax_segment_size with PAGE_SIZE == 64K\").\nFor example:\n  kernel BUG at drivers/ata/pata_macio.c:544!\n  Oops: Exception in kernel mode, sig: 5 [#1]\n  BE PAGE_SIZE=4K MMU=Hash SMP NR_CPUS=2 DEBUG_PAGEALLOC PowerMac\n  ...\n  NIP pata_macio_qc_prep+0xf4/0x190\n  LR  pata_macio_qc_prep+0xfc/0x190\n  Call Trace:\n    0xc1421660 (unreliable)\n    ata_qc_issue+0x14c/0x2d4\n    __ata_scsi_queuecmd+0x200/0x53c\n    ata_scsi_queuecmd+0x50/0xe0\n    scsi_queue_rq+0x788/0xb1c\n    __blk_mq_issue_directly+0x58/0xf4\n    blk_mq_plug_issue_direct+0x8c/0x1b4\n    blk_mq_flush_plug_list.part.0+0x584/0x5e0\n    __blk_flush_plug+0xf8/0x194\n    __submit_bio+0x1b8/0x2e0\n    submit_bio_noacct_nocheck+0x230/0x304\n    btrfs_work_helper+0x200/0x338\n    process_one_work+0x1a8/0x338\n    worker_thread+0x364/0x4c0\n    kthread+0x100/0x104\n    start_kernel_thread+0x10/0x14\nThat commit increased max_segment_size to 64KB, with the justification\nthat the SCSI core was already using that size when PAGE_SIZE == 64KB,\nand that there was existing logic to split over-sized requests.\nHowever with a sufficiently large request, the splitting logic causes\neach sg to be split into two commands in the DMA table, leading to\noverflow of the DMA table, triggering the BUG_ON().\nWith default settings the bug doesn't trigger, because the request size\nis limited by max_sectors_kb == 1280, however max_sectors_kb can be\nincreased, and apparently some distros do that by default using udev\nrules.\nFix the bug for 4KB kernels by reverting to the old max_segment_size.\nFor 64KB kernels the sg_tablesize needs to be halved, to allow for the\npossibility that each sg will be split into two.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/709e4c8f78e156ab332297bdd87527ec3da4e2d4"
          },
          {
            "url": "https://git.kernel.org/stable/c/822c8020aebcf5804a143b891e34f29873fee5e2"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44977",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:07.290",
        "lastModified": "2024-09-04T20:15:07.290",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/amdgpu: Validate TA binary size\nAdd TA binary size validation to avoid OOB write.\n(cherry picked from commit c0a04e3570d72aaf090962156ad085e37c62e442)",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/50553ea7cbd3344fbf40afb065f6a2d38171c1ad"
          },
          {
            "url": "https://git.kernel.org/stable/c/5ab8793b9a6cc059f503cbe6fe596f80765e0f19"
          },
          {
            "url": "https://git.kernel.org/stable/c/c99769bceab4ecb6a067b9af11f9db281eea3e2a"
          },
          {
            "url": "https://git.kernel.org/stable/c/e562415248f402203e7fb6d8c38c1b32fa99220f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44978",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:07.343",
        "lastModified": "2024-09-04T20:15:07.343",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/xe: Free job before xe_exec_queue_put\nFree job depends on job->vm being valid, the last xe_exec_queue_put can\ndestroy the VM. Prevent UAF by freeing job before xe_exec_queue_put.\n(cherry picked from commit 32a42c93b74c8ca6d0915ea3eba21bceff53042f)",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/98aa0330f200b9b8fb9e1298e006eda57a13351c"
          },
          {
            "url": "https://git.kernel.org/stable/c/9e7f30563677fbeff62d368d5d2a5ac7aaa9746a"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44979",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:07.400",
        "lastModified": "2024-09-04T20:15:07.400",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/xe: Fix missing workqueue destroy in xe_gt_pagefault\nOn driver reload we never free up the memory for the pagefault and\naccess counter workqueues. Add those destroy calls here.\n(cherry picked from commit 7586fc52b14e0b8edd0d1f8a434e0de2078b7b2b)",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/a6f78359ac75f24cac3c1bdd753c49c1877bcd82"
          },
          {
            "url": "https://git.kernel.org/stable/c/b09ef3b762a7fc641fb2f89afd3ebdb65b8ba1b9"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44980",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:07.460",
        "lastModified": "2024-09-04T20:15:07.460",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/xe: Fix opregion leak\nBeing part o the display, ideally the setup and cleanup would be done by\ndisplay itself. However this is a bigger refactor that needs to be done\non both i915 and xe. For now, just fix the leak:\nunreferenced object 0xffff8881a0300008 (size 192):\n  comm \"modprobe\", pid 4354, jiffies 4295647021\n  hex dump (first 32 bytes):\n    00 00 87 27 81 88 ff ff 18 80 9b 00 00 c9 ff ff  ...'............\n    18 81 9b 00 00 c9 ff ff 00 00 00 00 00 00 00 00  ................\n  backtrace (crc 99260e31):\n    [<ffffffff823ce65b>] kmemleak_alloc+0x4b/0x80\n    [<ffffffff81493be2>] kmalloc_trace_noprof+0x312/0x3d0\n    [<ffffffffa1345679>] intel_opregion_setup+0x89/0x700 [xe]\n    [<ffffffffa125bfaf>] xe_display_init_noirq+0x2f/0x90 [xe]\n    [<ffffffffa1199ec3>] xe_device_probe+0x7a3/0xbf0 [xe]\n    [<ffffffffa11f3713>] xe_pci_probe+0x333/0x5b0 [xe]\n    [<ffffffff81af6be8>] local_pci_probe+0x48/0xb0\n    [<ffffffff81af8778>] pci_device_probe+0xc8/0x280\n    [<ffffffff81d09048>] really_probe+0xf8/0x390\n    [<ffffffff81d0937a>] __driver_probe_device+0x8a/0x170\n    [<ffffffff81d09503>] driver_probe_device+0x23/0xb0\n    [<ffffffff81d097b7>] __driver_attach+0xc7/0x190\n    [<ffffffff81d0628d>] bus_for_each_dev+0x7d/0xd0\n    [<ffffffff81d0851e>] driver_attach+0x1e/0x30\n    [<ffffffff81d07ac7>] bus_add_driver+0x117/0x250\n(cherry picked from commit 6f4e43a2f771b737d991142ec4f6d4b7ff31fbb4)",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/f4b2a0ae1a31fd3d1b5ca18ee08319b479cf9b5f"
          },
          {
            "url": "https://git.kernel.org/stable/c/f7ecdd9853dd9f34e7cdfdadfb70b8f40644ebb4"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44981",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:07.533",
        "lastModified": "2024-09-04T20:15:07.533",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nworkqueue: Fix UBSAN 'subtraction overflow' error in shift_and_mask()\nUBSAN reports the following 'subtraction overflow' error when booting\nin a virtual machine on Android:\n | Internal error: UBSAN: integer subtraction overflow: 00000000f2005515 [#1] PREEMPT SMP\n | Modules linked in:\n | CPU: 0 PID: 1 Comm: swapper/0 Not tainted 6.10.0-00006-g3cbe9e5abd46-dirty #4\n | Hardware name: linux,dummy-virt (DT)\n | pstate: 600000c5 (nZCv daIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n | pc : cancel_delayed_work+0x34/0x44\n | lr : cancel_delayed_work+0x2c/0x44\n | sp : ffff80008002ba60\n | x29: ffff80008002ba60 x28: 0000000000000000 x27: 0000000000000000\n | x26: 0000000000000000 x25: 0000000000000000 x24: 0000000000000000\n | x23: 0000000000000000 x22: 0000000000000000 x21: ffff1f65014cd3c0\n | x20: ffffc0e84c9d0da0 x19: ffffc0e84cab3558 x18: ffff800080009058\n | x17: 00000000247ee1f8 x16: 00000000247ee1f8 x15: 00000000bdcb279d\n | x14: 0000000000000001 x13: 0000000000000075 x12: 00000a0000000000\n | x11: ffff1f6501499018 x10: 00984901651fffff x9 : ffff5e7cc35af000\n | x8 : 0000000000000001 x7 : 3d4d455453595342 x6 : 000000004e514553\n | x5 : ffff1f6501499265 x4 : ffff1f650ff60b10 x3 : 0000000000000620\n | x2 : ffff80008002ba78 x1 : 0000000000000000 x0 : 0000000000000000\n | Call trace:\n |  cancel_delayed_work+0x34/0x44\n |  deferred_probe_extend_timeout+0x20/0x70\n |  driver_register+0xa8/0x110\n |  __platform_driver_register+0x28/0x3c\n |  syscon_init+0x24/0x38\n |  do_one_initcall+0xe4/0x338\n |  do_initcall_level+0xac/0x178\n |  do_initcalls+0x5c/0xa0\n |  do_basic_setup+0x20/0x30\n |  kernel_init_freeable+0x8c/0xf8\n |  kernel_init+0x28/0x1b4\n |  ret_from_fork+0x10/0x20\n | Code: f9000fbf 97fffa2f 39400268 37100048 (d42aa2a0)\n | ---[ end trace 0000000000000000 ]---\n | Kernel panic - not syncing: UBSAN: integer subtraction overflow: Fatal exception\nThis is due to shift_and_mask() using a signed immediate to construct\nthe mask and being called with a shift of 31 (WORK_OFFQ_POOL_SHIFT) so\nthat it ends up decrementing from INT_MIN.\nUse an unsigned constant '1U' to generate the mask in shift_and_mask().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/38f7e14519d39cf524ddc02d4caee9b337dad703"
          },
          {
            "url": "https://git.kernel.org/stable/c/90a6a844b2d9927d192758438a4ada33d8cd9de5"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44982",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:07.593",
        "lastModified": "2024-09-04T20:15:07.593",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/msm/dpu: cleanup FB if dpu_format_populate_layout fails\nIf the dpu_format_populate_layout() fails, then FB is prepared, but not\ncleaned up. This ends up leaking the pin_count on the GEM object and\ncauses a splat during DRM file closure:\nmsm_obj->pin_count\nWARNING: CPU: 2 PID: 569 at drivers/gpu/drm/msm/msm_gem.c:121 update_lru_locked+0xc4/0xcc\n[...]\nCall trace:\n update_lru_locked+0xc4/0xcc\n put_pages+0xac/0x100\n msm_gem_free_object+0x138/0x180\n drm_gem_object_free+0x1c/0x30\n drm_gem_object_handle_put_unlocked+0x108/0x10c\n drm_gem_object_release_handle+0x58/0x70\n idr_for_each+0x68/0xec\n drm_gem_release+0x28/0x40\n drm_file_free+0x174/0x234\n drm_release+0xb0/0x160\n __fput+0xc0/0x2c8\n __fput_sync+0x50/0x5c\n __arm64_sys_close+0x38/0x7c\n invoke_syscall+0x48/0x118\n el0_svc_common.constprop.0+0x40/0xe0\n do_el0_svc+0x1c/0x28\n el0_svc+0x4c/0x120\n el0t_64_sync_handler+0x100/0x12c\n el0t_64_sync+0x190/0x194\nirq event stamp: 129818\nhardirqs last  enabled at (129817): [<ffffa5f6d953fcc0>] console_unlock+0x118/0x124\nhardirqs last disabled at (129818): [<ffffa5f6da7dcf04>] el1_dbg+0x24/0x8c\nsoftirqs last  enabled at (129808): [<ffffa5f6d94afc18>] handle_softirqs+0x4c8/0x4e8\nsoftirqs last disabled at (129785): [<ffffa5f6d94105e4>] __do_softirq+0x14/0x20\nPatchwork: https://patchwork.freedesktop.org/patch/600714/",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/02193c70723118889281f75b88722b26b58bf4ae"
          },
          {
            "url": "https://git.kernel.org/stable/c/7ecf85542169012765e4c2817cd3be6c2e009962"
          },
          {
            "url": "https://git.kernel.org/stable/c/9b8b65211a880af8fe8330a101e1e239a2d4008f"
          },
          {
            "url": "https://git.kernel.org/stable/c/a3c5815b07f4ee19d0b7e2ddf91ff9f03ecbf27d"
          },
          {
            "url": "https://git.kernel.org/stable/c/bfa1a6283be390947d3649c482e5167186a37016"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44983",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:07.657",
        "lastModified": "2024-09-04T20:15:07.657",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnetfilter: flowtable: validate vlan header\nEnsure there is sufficient room to access the protocol field of the\nVLAN header, validate it once before the flowtable lookup.\n=====================================================\nBUG: KMSAN: uninit-value in nf_flow_offload_inet_hook+0x45a/0x5f0 net/netfilter/nf_flow_table_inet.c:32\n nf_flow_offload_inet_hook+0x45a/0x5f0 net/netfilter/nf_flow_table_inet.c:32\n nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline]\n nf_hook_slow+0xf4/0x400 net/netfilter/core.c:626\n nf_hook_ingress include/linux/netfilter_netdev.h:34 [inline]\n nf_ingress net/core/dev.c:5440 [inline]",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0279c35d242d037abeb73d60d06a6d1bb7f672d9"
          },
          {
            "url": "https://git.kernel.org/stable/c/043a18bb6cf16adaa2f8642acfde6e8956a9caaa"
          },
          {
            "url": "https://git.kernel.org/stable/c/6ea14ccb60c8ab829349979b22b58a941ec4a3ee"
          },
          {
            "url": "https://git.kernel.org/stable/c/c05155cc455785916164aa5e1b4605a2ae946537"
          },
          {
            "url": "https://git.kernel.org/stable/c/d9384ae7aec46036d248d1c2c2757e471ab486c3"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44984",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:07.717",
        "lastModified": "2024-09-04T20:15:07.717",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbnxt_en: Fix double DMA unmapping for XDP_REDIRECT\nRemove the dma_unmap_page_attrs() call in the driver's XDP_REDIRECT\ncode path.  This should have been removed when we let the page pool\nhandle the DMA mapping.  This bug causes the warning:\nWARNING: CPU: 7 PID: 59 at drivers/iommu/dma-iommu.c:1198 iommu_dma_unmap_page+0xd5/0x100\nCPU: 7 PID: 59 Comm: ksoftirqd/7 Tainted: G        W          6.8.0-1010-gcp #11-Ubuntu\nHardware name: Dell Inc. PowerEdge R7525/0PYVT1, BIOS 2.15.2 04/02/2024\nRIP: 0010:iommu_dma_unmap_page+0xd5/0x100\nCode: 89 ee 48 89 df e8 cb f2 69 ff 48 83 c4 08 5b 41 5c 41 5d 41 5e 41 5f 5d 31 c0 31 d2 31 c9 31 f6 31 ff 45 31 c0 e9 ab 17 71 00 <0f> 0b 48 83 c4 08 5b 41 5c 41 5d 41 5e 41 5f 5d 31 c0 31 d2 31 c9\nRSP: 0018:ffffab1fc0597a48 EFLAGS: 00010246\nRAX: 0000000000000000 RBX: ffff99ff838280c8 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000\nRBP: ffffab1fc0597a78 R08: 0000000000000002 R09: ffffab1fc0597c1c\nR10: ffffab1fc0597cd3 R11: ffff99ffe375acd8 R12: 00000000e65b9000\nR13: 0000000000000050 R14: 0000000000001000 R15: 0000000000000002\nFS:  0000000000000000(0000) GS:ffff9a06efb80000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000565c34c37210 CR3: 00000005c7e3e000 CR4: 0000000000350ef0\n? show_regs+0x6d/0x80\n? __warn+0x89/0x150\n? iommu_dma_unmap_page+0xd5/0x100\n? report_bug+0x16a/0x190\n? handle_bug+0x51/0xa0\n? exc_invalid_op+0x18/0x80\n? iommu_dma_unmap_page+0xd5/0x100\n? iommu_dma_unmap_page+0x35/0x100\ndma_unmap_page_attrs+0x55/0x220\n? bpf_prog_4d7e87c0d30db711_xdp_dispatcher+0x64/0x9f\nbnxt_rx_xdp+0x237/0x520 [bnxt_en]\nbnxt_rx_pkt+0x640/0xdd0 [bnxt_en]\n__bnxt_poll_work+0x1a1/0x3d0 [bnxt_en]\nbnxt_poll+0xaa/0x1e0 [bnxt_en]\n__napi_poll+0x33/0x1e0\nnet_rx_action+0x18a/0x2f0",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/8baeef7616d5194045c5a6b97fd1246b87c55b13"
          },
          {
            "url": "https://git.kernel.org/stable/c/95a305ba259b685780ed62ea2295aa2feb2d6c0c"
          },
          {
            "url": "https://git.kernel.org/stable/c/fa4e6ae38574d0fc5596272bee64727d8ab7052b"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44985",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:07.777",
        "lastModified": "2024-09-04T20:15:07.777",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nipv6: prevent possible UAF in ip6_xmit()\nIf skb_expand_head() returns NULL, skb has been freed\nand the associated dst/idev could also have been freed.\nWe must use rcu_read_lock() to prevent a possible UAF.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/124b428fe28064c809e4237b0b38e97200a8a4a8"
          },
          {
            "url": "https://git.kernel.org/stable/c/2d5ff7e339d04622d8282661df36151906d0e1c7"
          },
          {
            "url": "https://git.kernel.org/stable/c/38a21c026ed2cc7232414cb166efc1923f34af17"
          },
          {
            "url": "https://git.kernel.org/stable/c/975f764e96f71616b530e300c1bb2ac0ce0c2596"
          },
          {
            "url": "https://git.kernel.org/stable/c/fc88d6c1f2895a5775795d82ec581afdff7661d1"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44986",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:07.833",
        "lastModified": "2024-09-04T20:15:07.833",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nipv6: fix possible UAF in ip6_finish_output2()\nIf skb_expand_head() returns NULL, skb has been freed\nand associated dst/idev could also have been freed.\nWe need to hold rcu_read_lock() to make sure the dst and\nassociated idev are alive.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3574d28caf9a09756ae87ad1ea096c6f47b6101e"
          },
          {
            "url": "https://git.kernel.org/stable/c/56efc253196751ece1fc535a5b582be127b0578a"
          },
          {
            "url": "https://git.kernel.org/stable/c/6ab6bf731354a6fdbaa617d1ec194960db61cf3b"
          },
          {
            "url": "https://git.kernel.org/stable/c/da273b377ae0d9bd255281ed3c2adb228321687b"
          },
          {
            "url": "https://git.kernel.org/stable/c/e891b36de161fcd96f12ff83667473e5067b9037"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44987",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:07.890",
        "lastModified": "2024-09-04T20:15:07.890",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nipv6: prevent UAF in ip6_send_skb()\nsyzbot reported an UAF in ip6_send_skb() [1]\nAfter ip6_local_out() has returned, we no longer can safely\ndereference rt, unless we hold rcu_read_lock().\nA similar issue has been fixed in commit\na688caa34beb (\"ipv6: take rcu lock in rawv6_send_hdrinc()\")\nAnother potential issue in ip6_finish_output2() is handled in a\nseparate patch.\n[1]\n BUG: KASAN: slab-use-after-free in ip6_send_skb+0x18d/0x230 net/ipv6/ip6_output.c:1964\nRead of size 8 at addr ffff88806dde4858 by task syz.1.380/6530\nCPU: 1 UID: 0 PID: 6530 Comm: syz.1.380 Not tainted 6.11.0-rc3-syzkaller-00306-gdf6cbc62cc9b #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024\nCall Trace:\n <TASK>\n  __dump_stack lib/dump_stack.c:93 [inline]\n  dump_stack_lvl+0x241/0x360 lib/dump_stack.c:119\n  print_address_description mm/kasan/report.c:377 [inline]\n  print_report+0x169/0x550 mm/kasan/report.c:488\n  kasan_report+0x143/0x180 mm/kasan/report.c:601\n  ip6_send_skb+0x18d/0x230 net/ipv6/ip6_output.c:1964\n  rawv6_push_pending_frames+0x75c/0x9e0 net/ipv6/raw.c:588\n  rawv6_sendmsg+0x19c7/0x23c0 net/ipv6/raw.c:926\n  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x1a6/0x270 net/socket.c:745\n  sock_write_iter+0x2dd/0x400 net/socket.c:1160\n do_iter_readv_writev+0x60a/0x890\n  vfs_writev+0x37c/0xbb0 fs/read_write.c:971\n  do_writev+0x1b1/0x350 fs/read_write.c:1018\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f936bf79e79\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f936cd7f038 EFLAGS: 00000246 ORIG_RAX: 0000000000000014\nRAX: ffffffffffffffda RBX: 00007f936c115f80 RCX: 00007f936bf79e79\nRDX: 0000000000000001 RSI: 0000000020000040 RDI: 0000000000000004\nRBP: 00007f936bfe7916 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 0000000000000000 R14: 00007f936c115f80 R15: 00007fff2860a7a8\n </TASK>\nAllocated by task 6530:\n  kasan_save_stack mm/kasan/common.c:47 [inline]\n  kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n  unpoison_slab_object mm/kasan/common.c:312 [inline]\n  __kasan_slab_alloc+0x66/0x80 mm/kasan/common.c:338\n  kasan_slab_alloc include/linux/kasan.h:201 [inline]\n  slab_post_alloc_hook mm/slub.c:3988 [inline]\n  slab_alloc_node mm/slub.c:4037 [inline]\n  kmem_cache_alloc_noprof+0x135/0x2a0 mm/slub.c:4044\n  dst_alloc+0x12b/0x190 net/core/dst.c:89\n  ip6_blackhole_route+0x59/0x340 net/ipv6/route.c:2670\n  make_blackhole net/xfrm/xfrm_policy.c:3120 [inline]\n  xfrm_lookup_route+0xd1/0x1c0 net/xfrm/xfrm_policy.c:3313\n  ip6_dst_lookup_flow+0x13e/0x180 net/ipv6/ip6_output.c:1257\n  rawv6_sendmsg+0x1283/0x23c0 net/ipv6/raw.c:898\n  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x1a6/0x270 net/socket.c:745\n  ____sys_sendmsg+0x525/0x7d0 net/socket.c:2597\n  ___sys_sendmsg net/socket.c:2651 [inline]\n  __sys_sendmsg+0x2b0/0x3a0 net/socket.c:2680\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nFreed by task 45:\n  kasan_save_stack mm/kasan/common.c:47 [inline]\n  kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n  kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:579\n  poison_slab_object+0xe0/0x150 mm/kasan/common.c:240\n  __kasan_slab_free+0x37/0x60 mm/kasan/common.c:256\n  kasan_slab_free include/linux/kasan.h:184 [inline]\n  slab_free_hook mm/slub.c:2252 [inline]\n  slab_free mm/slub.c:4473 [inline]\n  kmem_cache_free+0x145/0x350 mm/slub.c:4548\n  dst_destroy+0x2ac/0x460 net/core/dst.c:124\n  rcu_do_batch kernel/rcu/tree.c:2569 [inline]\n  rcu_core+0xafd/0x1830 kernel/rcu/tree.\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/24e93695b1239fbe4c31e224372be77f82dab69a"
          },
          {
            "url": "https://git.kernel.org/stable/c/571567e0277008459750f0728f246086b2659429"
          },
          {
            "url": "https://git.kernel.org/stable/c/9a3e55afa95ed4ac9eda112d4f918af645d72f25"
          },
          {
            "url": "https://git.kernel.org/stable/c/af1dde074ee2ed7dd5bdca4e7e8ba17f44e7b011"
          },
          {
            "url": "https://git.kernel.org/stable/c/cb5880a0de12c7f618d2bdd84e2d985f1e06ed7e"
          },
          {
            "url": "https://git.kernel.org/stable/c/ce2f6cfab2c637d0bd9762104023a15d0ab7c0a8"
          },
          {
            "url": "https://git.kernel.org/stable/c/e44bd76dd072756e674f45c5be00153f4ded68b2"
          },
          {
            "url": "https://git.kernel.org/stable/c/faa389b2fbaaec7fd27a390b4896139f9da662e3"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44988",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:07.960",
        "lastModified": "2024-09-04T20:15:07.960",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: dsa: mv88e6xxx: Fix out-of-bound access\nIf an ATU violation was caused by a CPU Load operation, the SPID could\nbe larger than DSA_MAX_PORTS (the size of mv88e6xxx_chip.ports[] array).",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/050e7274ab2150cd212b2372595720e7b83a15bd"
          },
          {
            "url": "https://git.kernel.org/stable/c/18b2e833daf049223ab3c2efdf8cdee08854c484"
          },
          {
            "url": "https://git.kernel.org/stable/c/528876d867a23b5198022baf2e388052ca67c952"
          },
          {
            "url": "https://git.kernel.org/stable/c/a10d0337115a6d223a1563d853d4455f05d0b2e3"
          },
          {
            "url": "https://git.kernel.org/stable/c/d39f5be62f098fe367d672b4dd4bc4b2b80e08e7"
          },
          {
            "url": "https://git.kernel.org/stable/c/f7d8c2fabd39250cf2333fbf8eef67e837f90a5d"
          },
          {
            "url": "https://git.kernel.org/stable/c/f87ce03c652dba199aef15ac18ade3991db5477e"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44989",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:08.020",
        "lastModified": "2024-09-04T20:15:08.020",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbonding: fix xfrm real_dev null pointer dereference\nWe shouldn't set real_dev to NULL because packets can be in transit and\nxfrm might call xdo_dev_offload_ok() in parallel. All callbacks assume\nreal_dev is set.\n Example trace:\n kernel: BUG: unable to handle page fault for address: 0000000000001030\n kernel: bond0: (slave eni0np1): making interface the new active one\n kernel: #PF: supervisor write access in kernel mode\n kernel: #PF: error_code(0x0002) - not-present page\n kernel: PGD 0 P4D 0\n kernel: Oops: 0002 [#1] PREEMPT SMP\n kernel: CPU: 4 PID: 2237 Comm: ping Not tainted 6.7.7+ #12\n kernel: Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-2.fc40 04/01/2014\n kernel: RIP: 0010:nsim_ipsec_offload_ok+0xc/0x20 [netdevsim]\n kernel: bond0: (slave eni0np1): bond_ipsec_add_sa_all: failed to add SA\n kernel: Code: e0 0f 0b 48 83 7f 38 00 74 de 0f 0b 48 8b 47 08 48 8b 37 48 8b 78 40 e9 b2 e5 9a d7 66 90 0f 1f 44 00 00 48 8b 86 80 02 00 00 <83> 80 30 10 00 00 01 b8 01 00 00 00 c3 0f 1f 80 00 00 00 00 0f 1f\n kernel: bond0: (slave eni0np1): making interface the new active one\n kernel: RSP: 0018:ffffabde81553b98 EFLAGS: 00010246\n kernel: bond0: (slave eni0np1): bond_ipsec_add_sa_all: failed to add SA\n kernel:\n kernel: RAX: 0000000000000000 RBX: ffff9eb404e74900 RCX: ffff9eb403d97c60\n kernel: RDX: ffffffffc090de10 RSI: ffff9eb404e74900 RDI: ffff9eb3c5de9e00\n kernel: RBP: ffff9eb3c0a42000 R08: 0000000000000010 R09: 0000000000000014\n kernel: R10: 7974203030303030 R11: 3030303030303030 R12: 0000000000000000\n kernel: R13: ffff9eb3c5de9e00 R14: ffffabde81553cc8 R15: ffff9eb404c53000\n kernel: FS:  00007f2a77a3ad00(0000) GS:ffff9eb43bd00000(0000) knlGS:0000000000000000\n kernel: CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n kernel: CR2: 0000000000001030 CR3: 00000001122ab000 CR4: 0000000000350ef0\n kernel: bond0: (slave eni0np1): making interface the new active one\n kernel: Call Trace:\n kernel:  <TASK>\n kernel:  ? __die+0x1f/0x60\n kernel: bond0: (slave eni0np1): bond_ipsec_add_sa_all: failed to add SA\n kernel:  ? page_fault_oops+0x142/0x4c0\n kernel:  ? do_user_addr_fault+0x65/0x670\n kernel:  ? kvm_read_and_reset_apf_flags+0x3b/0x50\n kernel: bond0: (slave eni0np1): making interface the new active one\n kernel:  ? exc_page_fault+0x7b/0x180\n kernel:  ? asm_exc_page_fault+0x22/0x30\n kernel:  ? nsim_bpf_uninit+0x50/0x50 [netdevsim]\n kernel: bond0: (slave eni0np1): bond_ipsec_add_sa_all: failed to add SA\n kernel:  ? nsim_ipsec_offload_ok+0xc/0x20 [netdevsim]\n kernel: bond0: (slave eni0np1): making interface the new active one\n kernel:  bond_ipsec_offload_ok+0x7b/0x90 [bonding]\n kernel:  xfrm_output+0x61/0x3b0\n kernel: bond0: (slave eni0np1): bond_ipsec_add_sa_all: failed to add SA\n kernel:  ip_push_pending_frames+0x56/0x80",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/21816b696c172c19d53a30d45ee005cce246ed21"
          },
          {
            "url": "https://git.kernel.org/stable/c/2f72c6a66bcd7e0187ec085237fee5db27145294"
          },
          {
            "url": "https://git.kernel.org/stable/c/4582d4ff413a07d4ed8a4823c652dc5207760548"
          },
          {
            "url": "https://git.kernel.org/stable/c/7fa9243391ad2afe798ef4ea2e2851947b95754f"
          },
          {
            "url": "https://git.kernel.org/stable/c/89fc1dca79db5c3e7a2d589ecbf8a3661c65f436"
          },
          {
            "url": "https://git.kernel.org/stable/c/f8cde9805981c50d0c029063dc7d82821806fc44"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44990",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:08.087",
        "lastModified": "2024-09-04T20:15:08.087",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbonding: fix null pointer deref in bond_ipsec_offload_ok\nWe must check if there is an active slave before dereferencing the pointer.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0707260a18312bbcd2a5668584e3692d0a29e3f6"
          },
          {
            "url": "https://git.kernel.org/stable/c/2f5bdd68c1ce64bda6bef4d361a3de23b04ccd59"
          },
          {
            "url": "https://git.kernel.org/stable/c/32a0173600c63aadaf2103bf02f074982e8602ab"
          },
          {
            "url": "https://git.kernel.org/stable/c/81216b9352be43f8958092d379f6dec85443c309"
          },
          {
            "url": "https://git.kernel.org/stable/c/95c90e4ad89d493a7a14fa200082e466e2548f9d"
          },
          {
            "url": "https://git.kernel.org/stable/c/b70b0ddfed31fc92c8dc722d0afafc8e14cb550c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44991",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:08.150",
        "lastModified": "2024-09-04T20:15:08.150",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ntcp: prevent concurrent execution of tcp_sk_exit_batch\nIts possible that two threads call tcp_sk_exit_batch() concurrently,\nonce from the cleanup_net workqueue, once from a task that failed to clone\na new netns.  In the latter case, error unwinding calls the exit handlers\nin reverse order for the 'failed' netns.\ntcp_sk_exit_batch() calls tcp_twsk_purge().\nProblem is that since commit b099ce2602d8 (\"net: Batch inet_twsk_purge\"),\nthis function picks up twsk in any dying netns, not just the one passed\nin via exit_batch list.\nThis means that the error unwind of setup_net() can \"steal\" and destroy\ntimewait sockets belonging to the exiting netns.\nThis allows the netns exit worker to proceed to call\nWARN_ON_ONCE(!refcount_dec_and_test(&net->ipv4.tcp_death_row.tw_refcount));\nwithout the expected 1 -> 0 transition, which then splats.\nAt same time, error unwind path that is also running inet_twsk_purge()\nwill splat as well:\nWARNING: .. at lib/refcount.c:31 refcount_warn_saturate+0x1ed/0x210\n...\n refcount_dec include/linux/refcount.h:351 [inline]\n inet_twsk_kill+0x758/0x9c0 net/ipv4/inet_timewait_sock.c:70\n inet_twsk_deschedule_put net/ipv4/inet_timewait_sock.c:221\n inet_twsk_purge+0x725/0x890 net/ipv4/inet_timewait_sock.c:304\n tcp_sk_exit_batch+0x1c/0x170 net/ipv4/tcp_ipv4.c:3522\n ops_exit_list+0x128/0x180 net/core/net_namespace.c:178\n setup_net+0x714/0xb40 net/core/net_namespace.c:375\n copy_net_ns+0x2f0/0x670 net/core/net_namespace.c:508\n create_new_namespaces+0x3ea/0xb10 kernel/nsproxy.c:110\n... because refcount_dec() of tw_refcount unexpectedly dropped to 0.\nThis doesn't seem like an actual bug (no tw sockets got lost and I don't\nsee a use-after-free) but as erroneous trigger of debug check.\nAdd a mutex to force strict ordering: the task that calls tcp_twsk_purge()\nblocks other task from doing final _dec_and_test before mutex-owner has\nremoved all tw sockets of dying netns.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/565d121b69980637f040eb4d84289869cdaabedf"
          },
          {
            "url": "https://git.kernel.org/stable/c/99580ae890ec8bd98b21a2a9c6668f8f1555b62e"
          },
          {
            "url": "https://git.kernel.org/stable/c/e3d9de3742f4d5c47ae35f888d3023a5b54fcd2f"
          },
          {
            "url": "https://git.kernel.org/stable/c/f6fd2dbf584a4047ba88d1369ff91c9851261ec1"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44992",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:08.207",
        "lastModified": "2024-09-04T20:15:08.207",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nsmb/client: avoid possible NULL dereference in cifs_free_subrequest()\nClang static checker (scan-build) warning:\n\tcifsglob.h:line 890, column 3\n\tAccess to field 'ops' results in a dereference of a null pointer.\nCommit 519be989717c (\"cifs: Add a tracepoint to track credits involved in\nR/W requests\") adds a check for 'rdata->server', and let clang throw this\nwarning about NULL dereference.\nWhen 'rdata->credits.value != 0 && rdata->server == NULL' happens,\nadd_credits_and_wake_if() will call rdata->server->ops->add_credits().\nThis will cause NULL dereference problem. Add a check for 'rdata->server'\nto avoid NULL dereference.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/74c2ab6d653b4c2354df65a7f7f2df1925a40a51"
          },
          {
            "url": "https://git.kernel.org/stable/c/fead60a6d5f84b472b928502a42c419253afe6c1"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44993",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:08.257",
        "lastModified": "2024-09-04T20:15:08.257",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/v3d: Fix out-of-bounds read in `v3d_csd_job_run()`\nWhen enabling UBSAN on Raspberry Pi 5, we get the following warning:\n[  387.894977] UBSAN: array-index-out-of-bounds in drivers/gpu/drm/v3d/v3d_sched.c:320:3\n[  387.903868] index 7 is out of range for type '__u32 [7]'\n[  387.909692] CPU: 0 PID: 1207 Comm: kworker/u16:2 Tainted: G        WC         6.10.3-v8-16k-numa #151\n[  387.919166] Hardware name: Raspberry Pi 5 Model B Rev 1.0 (DT)\n[  387.925961] Workqueue: v3d_csd drm_sched_run_job_work [gpu_sched]\n[  387.932525] Call trace:\n[  387.935296]  dump_backtrace+0x170/0x1b8\n[  387.939403]  show_stack+0x20/0x38\n[  387.942907]  dump_stack_lvl+0x90/0xd0\n[  387.946785]  dump_stack+0x18/0x28\n[  387.950301]  __ubsan_handle_out_of_bounds+0x98/0xd0\n[  387.955383]  v3d_csd_job_run+0x3a8/0x438 [v3d]\n[  387.960707]  drm_sched_run_job_work+0x520/0x6d0 [gpu_sched]\n[  387.966862]  process_one_work+0x62c/0xb48\n[  387.971296]  worker_thread+0x468/0x5b0\n[  387.975317]  kthread+0x1c4/0x1e0\n[  387.978818]  ret_from_fork+0x10/0x20\n[  387.983014] ---[ end trace ]---\nThis happens because the UAPI provides only seven configuration\nregisters and we are reading the eighth position of this u32 array.\nTherefore, fix the out-of-bounds read in `v3d_csd_job_run()` by\naccessing only seven positions on the '__u32 [7]' array. The eighth\nregister exists indeed on V3D 7.1, but it isn't currently used. That\nbeing so, let's guarantee that it remains unused and add a note that it\ncould be set in a future patch.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/497d370a644d95a9f04271aa92cb96d32e84c770"
          },
          {
            "url": "https://git.kernel.org/stable/c/d656b82c4b30cf12715e6cd129d3df808fde24a7"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44994",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:08.307",
        "lastModified": "2024-09-04T20:15:08.307",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\niommu: Restore lost return in iommu_report_device_fault()\nWhen iommu_report_device_fault gets called with a partial fault it is\nsupposed to collect the fault into the group and then return.\nInstead the return was accidently deleted which results in trying to\nprocess the fault and an eventual crash.\nDeleting the return was a typo, put it back.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/cc6bc2ab1663ec9353636416af22452b078510e9"
          },
          {
            "url": "https://git.kernel.org/stable/c/fca5b78511e98bdff2cdd55c172b23200a7b3404"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44995",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:08.353",
        "lastModified": "2024-09-04T20:15:08.353",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: hns3: fix a deadlock problem when config TC during resetting\nWhen config TC during the reset process, may cause a deadlock, the flow is\nas below:\n                             pf reset start\n                                 │\n                                 ▼\n                              ......\nsetup tc                         │\n    │                            ▼\n    ▼                      DOWN: napi_disable()\nnapi_disable()(skip)             │\n    │                            │\n    ▼                            ▼\n  ......                      ......\n    │                            │\n    ▼                            │\nnapi_enable()                    │\n                                 ▼\n                           UINIT: netif_napi_del()\n                                 │\n                                 ▼\n                              ......\n                                 │\n                                 ▼\n                           INIT: netif_napi_add()\n                                 │\n                                 ▼\n                              ......                 global reset start\n                                 │                      │\n                                 ▼                      ▼\n                           UP: napi_enable()(skip)    ......\n                                 │                      │\n                                 ▼                      ▼\n                              ......                 napi_disable()\nIn reset process, the driver will DOWN the port and then UINIT, in this\ncase, the setup tc process will UP the port before UINIT, so cause the\nproblem. Adds a DOWN process in UINIT to fix it.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/195918217448a6bb7f929d6a2ffffce9f1ece1cc"
          },
          {
            "url": "https://git.kernel.org/stable/c/67492d4d105c0a6321b00c393eec96b9a7a97a16"
          },
          {
            "url": "https://git.kernel.org/stable/c/6ae2b7d63cd056f363045eb65409143e16f23ae8"
          },
          {
            "url": "https://git.kernel.org/stable/c/be5e816d00a506719e9dbb1a9c861c5ced30a109"
          },
          {
            "url": "https://git.kernel.org/stable/c/de37408d5c26fc4a296a28a0c96dcb814219bfa1"
          },
          {
            "url": "https://git.kernel.org/stable/c/fa1d4de7265c370e673583ac8d1bd17d21826cd9"
          },
          {
            "url": "https://git.kernel.org/stable/c/fc250eca15bde34c4c8f806b9d88f55bd56a992c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44996",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:08.413",
        "lastModified": "2024-09-04T20:15:08.413",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nvsock: fix recursive ->recvmsg calls\nAfter a vsock socket has been added to a BPF sockmap, its prot->recvmsg\nhas been replaced with vsock_bpf_recvmsg(). Thus the following\nrecursiion could happen:\nvsock_bpf_recvmsg()\n -> __vsock_recvmsg()\n  -> vsock_connectible_recvmsg()\n   -> prot->recvmsg()\n    -> vsock_bpf_recvmsg() again\nWe need to fix it by calling the original ->recvmsg() without any BPF\nsockmap logic in __vsock_recvmsg().",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/69139d2919dd4aa9a553c8245e7c63e82613e3fc"
          },
          {
            "url": "https://git.kernel.org/stable/c/921f1acf0c3cf6b1260ab57a8a6e8b3d5f3023d5"
          },
          {
            "url": "https://git.kernel.org/stable/c/b4ee8cf1acc5018ed1369150d7bb3e0d0f79e135"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44997",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:08.470",
        "lastModified": "2024-09-04T20:15:08.470",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: ethernet: mtk_wed: fix use-after-free panic in mtk_wed_setup_tc_block_cb()\nWhen there are multiple ap interfaces on one band and with WED on,\nturning the interface down will cause a kernel panic on MT798X.\nPreviously, cb_priv was freed in mtk_wed_setup_tc_block() without\nmarking NULL,and mtk_wed_setup_tc_block_cb() didn't check the value, too.\nAssign NULL after free cb_priv in mtk_wed_setup_tc_block() and check NULL\nin mtk_wed_setup_tc_block_cb().\n----------\nUnable to handle kernel paging request at virtual address 0072460bca32b4f5\nCall trace:\n mtk_wed_setup_tc_block_cb+0x4/0x38\n 0xffffffc0794084bc\n tcf_block_playback_offloads+0x70/0x1e8\n tcf_block_unbind+0x6c/0xc8\n...\n---------",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/326a89321f9d5fe399fe6f9ff7c0fc766582a6a0"
          },
          {
            "url": "https://git.kernel.org/stable/c/b453a4bbda03aa8741279c360ac82d1c3ac33548"
          },
          {
            "url": "https://git.kernel.org/stable/c/db1b4bedb9b97c6d34b03d03815147c04fffe8b4"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44998",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:08.520",
        "lastModified": "2024-09-04T20:15:08.520",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\natm: idt77252: prevent use after free in dequeue_rx()\nWe can't dereference \"skb\" after calling vcc->push() because the skb\nis released.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/09e086a5f72ea27c758b3f3b419a69000c32adc1"
          },
          {
            "url": "https://git.kernel.org/stable/c/1cece837e387c039225f19028df255df87a97c0d"
          },
          {
            "url": "https://git.kernel.org/stable/c/24cf390a5426aac9255205e9533cdd7b4235d518"
          },
          {
            "url": "https://git.kernel.org/stable/c/379a6a326514a3e2f71b674091dfb0e0e7522b55"
          },
          {
            "url": "https://git.kernel.org/stable/c/628ea82190a678a56d2ec38cda3addf3b3a6248d"
          },
          {
            "url": "https://git.kernel.org/stable/c/91b4850e7165a4b7180ef1e227733bcb41ccdf10"
          },
          {
            "url": "https://git.kernel.org/stable/c/a9a18e8f770c9b0703dab93580d0b02e199a4c79"
          },
          {
            "url": "https://git.kernel.org/stable/c/ef23c18ab88e33ce000d06a5c6aad0620f219bfd"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44999",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:08.590",
        "lastModified": "2024-09-04T20:15:08.590",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ngtp: pull network headers in gtp_dev_xmit()\nsyzbot/KMSAN reported use of uninit-value in get_dev_xmit() [1]\nWe must make sure the IPv4 or Ipv6 header is pulled in skb->head\nbefore accessing fields in them.\nUse pskb_inet_may_pull() to fix this issue.\n[1]\nBUG: KMSAN: uninit-value in ipv6_pdp_find drivers/net/gtp.c:220 [inline]\n BUG: KMSAN: uninit-value in gtp_build_skb_ip6 drivers/net/gtp.c:1229 [inline]\n BUG: KMSAN: uninit-value in gtp_dev_xmit+0x1424/0x2540 drivers/net/gtp.c:1281\n  ipv6_pdp_find drivers/net/gtp.c:220 [inline]\n  gtp_build_skb_ip6 drivers/net/gtp.c:1229 [inline]\n  gtp_dev_xmit+0x1424/0x2540 drivers/net/gtp.c:1281\n  __netdev_start_xmit include/linux/netdevice.h:4913 [inline]\n  netdev_start_xmit include/linux/netdevice.h:4922 [inline]\n  xmit_one net/core/dev.c:3580 [inline]\n  dev_hard_start_xmit+0x247/0xa20 net/core/dev.c:3596\n  __dev_queue_xmit+0x358c/0x5610 net/core/dev.c:4423\n  dev_queue_xmit include/linux/netdevice.h:3105 [inline]\n  packet_xmit+0x9c/0x6c0 net/packet/af_packet.c:276\n  packet_snd net/packet/af_packet.c:3145 [inline]\n  packet_sendmsg+0x90e3/0xa3a0 net/packet/af_packet.c:3177\n  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n  __sys_sendto+0x685/0x830 net/socket.c:2204\n  __do_sys_sendto net/socket.c:2216 [inline]\n  __se_sys_sendto net/socket.c:2212 [inline]\n  __x64_sys_sendto+0x125/0x1d0 net/socket.c:2212\n  x64_sys_call+0x3799/0x3c10 arch/x86/include/generated/asm/syscalls_64.h:45\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nUninit was created at:\n  slab_post_alloc_hook mm/slub.c:3994 [inline]\n  slab_alloc_node mm/slub.c:4037 [inline]\n  kmem_cache_alloc_node_noprof+0x6bf/0xb80 mm/slub.c:4080\n  kmalloc_reserve+0x13d/0x4a0 net/core/skbuff.c:583\n  __alloc_skb+0x363/0x7b0 net/core/skbuff.c:674\n  alloc_skb include/linux/skbuff.h:1320 [inline]\n  alloc_skb_with_frags+0xc8/0xbf0 net/core/skbuff.c:6526\n  sock_alloc_send_pskb+0xa81/0xbf0 net/core/sock.c:2815\n  packet_alloc_skb net/packet/af_packet.c:2994 [inline]\n  packet_snd net/packet/af_packet.c:3088 [inline]\n  packet_sendmsg+0x749c/0xa3a0 net/packet/af_packet.c:3177\n  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n  __sys_sendto+0x685/0x830 net/socket.c:2204\n  __do_sys_sendto net/socket.c:2216 [inline]\n  __se_sys_sendto net/socket.c:2212 [inline]\n  __x64_sys_sendto+0x125/0x1d0 net/socket.c:2212\n  x64_sys_call+0x3799/0x3c10 arch/x86/include/generated/asm/syscalls_64.h:45\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nCPU: 0 UID: 0 PID: 7115 Comm: syz.1.515 Not tainted 6.11.0-rc1-syzkaller-00043-g94ede2a3e913 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 06/27/2024",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/137d565ab89ce3584503b443bc9e00d44f482593"
          },
          {
            "url": "https://git.kernel.org/stable/c/1f6b62392453d8f36685d19b761307a8c5617ac1"
          },
          {
            "url": "https://git.kernel.org/stable/c/34ba4f29f3d9eb52dee37512059efb2afd7e966f"
          },
          {
            "url": "https://git.kernel.org/stable/c/3939d787139e359b77aaf9485d1e145d6713d7b9"
          },
          {
            "url": "https://git.kernel.org/stable/c/3a3be7ff9224f424e485287b54be00d2c6bd9c40"
          },
          {
            "url": "https://git.kernel.org/stable/c/3d89d0c4a1c6d4d2a755e826351b0a101dbc86f3"
          },
          {
            "url": "https://git.kernel.org/stable/c/cbb9a969fc190e85195d1b0f08038e7f6199044e"
          },
          {
            "url": "https://git.kernel.org/stable/c/f5dda8db382c5751c4e572afc7c99df7da1f83ca"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45000",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:08.657",
        "lastModified": "2024-09-04T20:15:08.657",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nfs/netfs/fscache_cookie: add missing \"n_accesses\" check\nThis fixes a NULL pointer dereference bug due to a data race which\nlooks like this:\n  BUG: kernel NULL pointer dereference, address: 0000000000000008\n  #PF: supervisor read access in kernel mode\n  #PF: error_code(0x0000) - not-present page\n  PGD 0 P4D 0\n  Oops: 0000 [#1] SMP PTI\n  CPU: 33 PID: 16573 Comm: kworker/u97:799 Not tainted 6.8.7-cm4all1-hp+ #43\n  Hardware name: HP ProLiant DL380 Gen9/ProLiant DL380 Gen9, BIOS P89 10/17/2018\n  Workqueue: events_unbound netfs_rreq_write_to_cache_work\n  RIP: 0010:cachefiles_prepare_write+0x30/0xa0\n  Code: 57 41 56 45 89 ce 41 55 49 89 cd 41 54 49 89 d4 55 53 48 89 fb 48 83 ec 08 48 8b 47 08 48 83 7f 10 00 48 89 34 24 48 8b 68 20 <48> 8b 45 08 4c 8b 38 74 45 49 8b 7f 50 e8 4e a9 b0 ff 48 8b 73 10\n  RSP: 0018:ffffb4e78113bde0 EFLAGS: 00010286\n  RAX: ffff976126be6d10 RBX: ffff97615cdb8438 RCX: 0000000000020000\n  RDX: ffff97605e6c4c68 RSI: ffff97605e6c4c60 RDI: ffff97615cdb8438\n  RBP: 0000000000000000 R08: 0000000000278333 R09: 0000000000000001\n  R10: ffff97605e6c4600 R11: 0000000000000001 R12: ffff97605e6c4c68\n  R13: 0000000000020000 R14: 0000000000000001 R15: ffff976064fe2c00\n  FS:  0000000000000000(0000) GS:ffff9776dfd40000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 0000000000000008 CR3: 000000005942c002 CR4: 00000000001706f0\n  Call Trace:\n   <TASK>\n   ? __die+0x1f/0x70\n   ? page_fault_oops+0x15d/0x440\n   ? search_module_extables+0xe/0x40\n   ? fixup_exception+0x22/0x2f0\n   ? exc_page_fault+0x5f/0x100\n   ? asm_exc_page_fault+0x22/0x30\n   ? cachefiles_prepare_write+0x30/0xa0\n   netfs_rreq_write_to_cache_work+0x135/0x2e0\n   process_one_work+0x137/0x2c0\n   worker_thread+0x2e9/0x400\n   ? __pfx_worker_thread+0x10/0x10\n   kthread+0xcc/0x100\n   ? __pfx_kthread+0x10/0x10\n   ret_from_fork+0x30/0x50\n   ? __pfx_kthread+0x10/0x10\n   ret_from_fork_asm+0x1b/0x30\n   </TASK>\n  Modules linked in:\n  CR2: 0000000000000008\n  ---[ end trace 0000000000000000 ]---\nThis happened because fscache_cookie_state_machine() was slow and was\nstill running while another process invoked fscache_unuse_cookie();\nthis led to a fscache_cookie_lru_do_one() call, setting the\nFSCACHE_COOKIE_DO_LRU_DISCARD flag, which was picked up by\nfscache_cookie_state_machine(), withdrawing the cookie via\ncachefiles_withdraw_cookie(), clearing cookie->cache_priv.\nAt the same time, yet another process invoked\ncachefiles_prepare_write(), which found a NULL pointer in this code\nline:\n  struct cachefiles_object *object = cachefiles_cres_object(cres);\nThe next line crashes, obviously:\n  struct cachefiles_cache *cache = object->volume->cache;\nDuring cachefiles_prepare_write(), the \"n_accesses\" counter is\nnon-zero (via fscache_begin_operation()).  The cookie must not be\nwithdrawn until it drops to zero.\nThe counter is checked by fscache_cookie_state_machine() before\nswitching to FSCACHE_COOKIE_STATE_RELINQUISHING and\nFSCACHE_COOKIE_STATE_WITHDRAWING (in \"case\nFSCACHE_COOKIE_STATE_FAILED\"), but not for\nFSCACHE_COOKIE_STATE_LRU_DISCARDING (\"case\nFSCACHE_COOKIE_STATE_ACTIVE\").\nThis patch adds the missing check.  With a non-zero access counter,\nthe function returns and the next fscache_end_cookie_access() call\nwill queue another fscache_cookie_state_machine() call to handle the\nstill-pending FSCACHE_COOKIE_DO_LRU_DISCARD.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0a4d41fa14b2a0efd40e350cfe8ec6a4c998ac1d"
          },
          {
            "url": "https://git.kernel.org/stable/c/b8a50877f68efdcc0be3fcc5116e00c31b90e45b"
          },
          {
            "url": "https://git.kernel.org/stable/c/dfaa39b05a6cf34a16c525a2759ee6ab26b5fef6"
          },
          {
            "url": "https://git.kernel.org/stable/c/f71aa06398aabc2e3eaac25acdf3d62e0094ba70"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45001",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:08.710",
        "lastModified": "2024-09-04T20:15:08.710",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: mana: Fix RX buf alloc_size alignment and atomic op panic\nThe MANA driver's RX buffer alloc_size is passed into napi_build_skb() to\ncreate SKB. skb_shinfo(skb) is located at the end of skb, and its alignment\nis affected by the alloc_size passed into napi_build_skb(). The size needs\nto be aligned properly for better performance and atomic operations.\nOtherwise, on ARM64 CPU, for certain MTU settings like 4000, atomic\noperations may panic on the skb_shinfo(skb)->dataref due to alignment fault.\nTo fix this bug, add proper alignment to the alloc_size calculation.\nSample panic info:\n[  253.298819] Unable to handle kernel paging request at virtual address ffff000129ba5cce\n[  253.300900] Mem abort info:\n[  253.301760]   ESR = 0x0000000096000021\n[  253.302825]   EC = 0x25: DABT (current EL), IL = 32 bits\n[  253.304268]   SET = 0, FnV = 0\n[  253.305172]   EA = 0, S1PTW = 0\n[  253.306103]   FSC = 0x21: alignment fault\nCall trace:\n __skb_clone+0xfc/0x198\n skb_clone+0x78/0xe0\n raw6_local_deliver+0xfc/0x228\n ip6_protocol_deliver_rcu+0x80/0x500\n ip6_input_finish+0x48/0x80\n ip6_input+0x48/0xc0\n ip6_sublist_rcv_finish+0x50/0x78\n ip6_sublist_rcv+0x1cc/0x2b8\n ipv6_list_rcv+0x100/0x150\n __netif_receive_skb_list_core+0x180/0x220\n netif_receive_skb_list_internal+0x198/0x2a8\n __napi_poll+0x138/0x250\n net_rx_action+0x148/0x330\n handle_softirqs+0x12c/0x3a0",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/32316f676b4ee87c0404d333d248ccf777f739bc"
          },
          {
            "url": "https://git.kernel.org/stable/c/65f20b174ec0172f2d6bcfd8533ab9c9e7e347fa"
          },
          {
            "url": "https://git.kernel.org/stable/c/e6bea6a45f8a401f3d5a430bc81814f0cc8848cf"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45002",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:08.763",
        "lastModified": "2024-09-04T20:15:08.763",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nrtla/osnoise: Prevent NULL dereference in error handling\nIf the \"tool->data\" allocation fails then there is no need to call\nosnoise_free_top() and, in fact, doing so will lead to a NULL dereference.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/753f1745146e03abd17eec8eee95faffc96d743d"
          },
          {
            "url": "https://git.kernel.org/stable/c/90574d2a675947858b47008df8d07f75ea50d0d0"
          },
          {
            "url": "https://git.kernel.org/stable/c/abdb9ddaaab476e62805e36cce7b4ef8413ffd01"
          },
          {
            "url": "https://git.kernel.org/stable/c/fc575212c6b75d538e1a0a74f4c7e2ac73bc46ac"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45003",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:08.823",
        "lastModified": "2024-09-04T20:15:08.823",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nvfs: Don't evict inode under the inode lru traversing context\nThe inode reclaiming process(See function prune_icache_sb) collects all\nreclaimable inodes and mark them with I_FREEING flag at first, at that\ntime, other processes will be stuck if they try getting these inodes\n(See function find_inode_fast), then the reclaiming process destroy the\ninodes by function dispose_list(). Some filesystems(eg. ext4 with\nea_inode feature, ubifs with xattr) may do inode lookup in the inode\nevicting callback function, if the inode lookup is operated under the\ninode lru traversing context, deadlock problems may happen.\nCase 1: In function ext4_evict_inode(), the ea inode lookup could happen\n        if ea_inode feature is enabled, the lookup process will be stuck\n\tunder the evicting context like this:\n 1. File A has inode i_reg and an ea inode i_ea\n 2. getfattr(A, xattr_buf) // i_ea is added into lru // lru->i_ea\n 3. Then, following three processes running like this:\n    PA                              PB\n echo 2 > /proc/sys/vm/drop_caches\n  shrink_slab\n   prune_dcache_sb\n   // i_reg is added into lru, lru->i_ea->i_reg\n   prune_icache_sb\n    list_lru_walk_one\n     inode_lru_isolate\n      i_ea->i_state |= I_FREEING // set inode state\n     inode_lru_isolate\n      __iget(i_reg)\n      spin_unlock(&i_reg->i_lock)\n      spin_unlock(lru_lock)\n                                     rm file A\n                                      i_reg->nlink = 0\n      iput(i_reg) // i_reg->nlink is 0, do evict\n       ext4_evict_inode\n        ext4_xattr_delete_inode\n         ext4_xattr_inode_dec_ref_all\n          ext4_xattr_inode_iget\n           ext4_iget(i_ea->i_ino)\n            iget_locked\n             find_inode_fast\n              __wait_on_freeing_inode(i_ea) ----→ AA deadlock\n    dispose_list // cannot be executed by prune_icache_sb\n     wake_up_bit(&i_ea->i_state)\nCase 2: In deleted inode writing function ubifs_jnl_write_inode(), file\n        deleting process holds BASEHD's wbuf->io_mutex while getting the\n\txattr inode, which could race with inode reclaiming process(The\n        reclaiming process could try locking BASEHD's wbuf->io_mutex in\n\tinode evicting function), then an ABBA deadlock problem would\n\thappen as following:\n 1. File A has inode ia and a xattr(with inode ixa), regular file B has\n    inode ib and a xattr.\n 2. getfattr(A, xattr_buf) // ixa is added into lru // lru->ixa\n 3. Then, following three processes running like this:\n        PA                PB                        PC\n                echo 2 > /proc/sys/vm/drop_caches\n                 shrink_slab\n                  prune_dcache_sb\n                  // ib and ia are added into lru, lru->ixa->ib->ia\n                  prune_icache_sb\n                   list_lru_walk_one\n                    inode_lru_isolate\n                     ixa->i_state |= I_FREEING // set inode state\n                    inode_lru_isolate\n                     __iget(ib)\n                     spin_unlock(&ib->i_lock)\n                     spin_unlock(lru_lock)\n                                                   rm file B\n                                                    ib->nlink = 0\n rm file A\n  iput(ia)\n   ubifs_evict_inode(ia)\n    ubifs_jnl_delete_inode(ia)\n     ubifs_jnl_write_inode(ia)\n      make_reservation(BASEHD) // Lock wbuf->io_mutex\n      ubifs_iget(ixa->i_ino)\n       iget_locked\n        find_inode_fast\n         __wait_on_freeing_inode(ixa)\n          |          iput(ib) // ib->nlink is 0, do evict\n          |           ubifs_evict_inode\n          |            ubifs_jnl_delete_inode(ib)\n          ↓             ubifs_jnl_write_inode\n     ABBA deadlock ←-----make_reservation(BASEHD)\n                   dispose_list // cannot be executed by prune_icache_sb\n                    wake_up_bit(&ixa->i_state)\nFix the possible deadlock by using new inode state flag I_LRU_ISOLATING\nto pin the inode in memory while inode_lru_isolate(\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/03880af02a78bc9a98b5a581f529cf709c88a9b8"
          },
          {
            "url": "https://git.kernel.org/stable/c/2a0629834cd82f05d424bbc193374f9a43d1f87d"
          },
          {
            "url": "https://git.kernel.org/stable/c/3525ad25240dfdd8c78f3470911ed10aa727aa72"
          },
          {
            "url": "https://git.kernel.org/stable/c/437741eba63bf4e437e2beb5583f8633556a2b98"
          },
          {
            "url": "https://git.kernel.org/stable/c/9063ab49c11e9518a3f2352434bb276cc8134c5f"
          },
          {
            "url": "https://git.kernel.org/stable/c/b9bda5f6012dd00372f3a06a82ed8971a4c57c32"
          },
          {
            "url": "https://git.kernel.org/stable/c/cda54ec82c0f9d05393242b20b13f69b083f7e88"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45004",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:08.890",
        "lastModified": "2024-09-04T20:15:08.890",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nKEYS: trusted: dcp: fix leak of blob encryption key\nTrusted keys unseal the key blob on load, but keep the sealed payload in\nthe blob field so that every subsequent read (export) will simply\nconvert this field to hex and send it to userspace.\nWith DCP-based trusted keys, we decrypt the blob encryption key (BEK)\nin the Kernel due hardware limitations and then decrypt the blob payload.\nBEK decryption is done in-place which means that the trusted key blob\nfield is modified and it consequently holds the BEK in plain text.\nEvery subsequent read of that key thus send the plain text BEK instead\nof the encrypted BEK to userspace.\nThis issue only occurs when importing a trusted DCP-based key and\nthen exporting it again. This should rarely happen as the common use cases\nare to either create a new trusted key and export it, or import a key\nblob and then just use it without exporting it again.\nFix this by performing BEK decryption and encryption in a dedicated\nbuffer. Further always wipe the plain text BEK buffer to prevent leaking\nthe key via uninitialized memory.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0e28bf61a5f9ab30be3f3b4eafb8d097e39446bb"
          },
          {
            "url": "https://git.kernel.org/stable/c/9e3b266afcfe4294e84496f50f006f029d3100db"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45005",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:08.940",
        "lastModified": "2024-09-04T20:15:08.940",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nKVM: s390: fix validity interception issue when gisa is switched off\nWe might run into a SIE validity if gisa has been disabled either via using\nkernel parameter \"kvm.use_gisa=0\" or by setting the related sysfs\nattribute to N (echo N >/sys/module/kvm/parameters/use_gisa).\nThe validity is caused by an invalid value in the SIE control block's\ngisa designation. That happens because we pass the uninitialized gisa\norigin to virt_to_phys() before writing it to the gisa designation.\nTo fix this we return 0 in kvm_s390_get_gisa_desc() if the origin is 0.\nkvm_s390_get_gisa_desc() is used to determine which gisa designation to\nset in the SIE control block. A value of 0 in the gisa designation disables\ngisa usage.\nThe issue surfaces in the host kernel with the following kernel message as\nsoon a new kvm guest start is attemted.\nkvm: unhandled validity intercept 0x1011\nWARNING: CPU: 0 PID: 781237 at arch/s390/kvm/intercept.c:101 kvm_handle_sie_intercept+0x42e/0x4d0 [kvm]\nModules linked in: vhost_net tap tun xt_CHECKSUM xt_MASQUERADE xt_conntrack ipt_REJECT xt_tcpudp nft_compat x_tables nf_nat_tftp nf_conntrack_tftp vfio_pci_core irqbypass vhost_vsock vmw_vsock_virtio_transport_common vsock vhost vhost_iotlb kvm nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables sunrpc mlx5_ib ib_uverbs ib_core mlx5_core uvdevice s390_trng eadm_sch vfio_ccw zcrypt_cex4 mdev vfio_iommu_type1 vfio sch_fq_codel drm i2c_core loop drm_panel_orientation_quirks configfs nfnetlink lcs ctcm fsm dm_service_time ghash_s390 prng chacha_s390 libchacha aes_s390 des_s390 libdes sha3_512_s390 sha3_256_s390 sha512_s390 sha256_s390 sha1_s390 sha_common dm_mirror dm_region_hash dm_log zfcp scsi_transport_fc scsi_dh_rdac scsi_dh_emc scsi_dh_alua pkey zcrypt dm_multipath rng_core autofs4 [last unloaded: vfio_pci]\nCPU: 0 PID: 781237 Comm: CPU 0/KVM Not tainted 6.10.0-08682-gcad9f11498ea #6\nHardware name: IBM 3931 A01 701 (LPAR)\nKrnl PSW : 0704c00180000000 000003d93deb0122 (kvm_handle_sie_intercept+0x432/0x4d0 [kvm])\n           R:0 T:1 IO:1 EX:1 Key:0 M:1 W:0 P:0 AS:3 CC:0 PM:0 RI:0 EA:3\nKrnl GPRS: 000003d900000027 000003d900000023 0000000000000028 000002cd00000000\n           000002d063a00900 00000359c6daf708 00000000000bebb5 0000000000001eff\n           000002cfd82e9000 000002cfd80bc000 0000000000001011 000003d93deda412\n           000003ff8962df98 000003d93de77ce0 000003d93deb011e 00000359c6daf960\nKrnl Code: 000003d93deb0112: c020fffe7259\tlarl\t%r2,000003d93de7e5c4\n           000003d93deb0118: c0e53fa8beac\tbrasl\t%r14,000003d9bd3c7e70\n          #000003d93deb011e: af000000\t\tmc\t0,0\n          >000003d93deb0122: a728ffea\t\tlhi\t%r2,-22\n           000003d93deb0126: a7f4fe24\t\tbrc\t15,000003d93deafd6e\n           000003d93deb012a: 9101f0b0\t\ttm\t176(%r15),1\n           000003d93deb012e: a774fe48\t\tbrc\t7,000003d93deafdbe\n           000003d93deb0132: 40a0f0ae\t\tsth\t%r10,174(%r15)\nCall Trace:\n [<000003d93deb0122>] kvm_handle_sie_intercept+0x432/0x4d0 [kvm]\n([<000003d93deb011e>] kvm_handle_sie_intercept+0x42e/0x4d0 [kvm])\n [<000003d93deacc10>] vcpu_post_run+0x1d0/0x3b0 [kvm]\n [<000003d93deaceda>] __vcpu_run+0xea/0x2d0 [kvm]\n [<000003d93dead9da>] kvm_arch_vcpu_ioctl_run+0x16a/0x430 [kvm]\n [<000003d93de93ee0>] kvm_vcpu_ioctl+0x190/0x7c0 [kvm]\n [<000003d9bd728b4e>] vfs_ioctl+0x2e/0x70\n [<000003d9bd72a092>] __s390x_sys_ioctl+0xc2/0xd0\n [<000003d9be0e9222>] __do_syscall+0x1f2/0x2e0\n [<000003d9be0f9a90>] system_call+0x70/0x98\nLast Breaking-Event-Address:\n [<000003d9bd3c7f58>] __warn_printk+0xe8/0xf0",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/027ac3c5092561bccce09b314a73a1c167117ef6"
          },
          {
            "url": "https://git.kernel.org/stable/c/051c0a558154174cfcea301a386e4c91ade83ce1"
          },
          {
            "url": "https://git.kernel.org/stable/c/5a44bb061d04b0306f2aa8add761d86d152b9377"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45006",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:08.997",
        "lastModified": "2024-09-04T20:15:08.997",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nxhci: Fix Panther point NULL pointer deref at full-speed re-enumeration\nre-enumerating full-speed devices after a failed address device command\ncan trigger a NULL pointer dereference.\nFull-speed devices may need to reconfigure the endpoint 0 Max Packet Size\nvalue during enumeration. Usb core calls usb_ep0_reinit() in this case,\nwhich ends up calling xhci_configure_endpoint().\nOn Panther point xHC the xhci_configure_endpoint() function will\nadditionally check and reserve bandwidth in software. Other hosts do\nthis in hardware\nIf xHC address device command fails then a new xhci_virt_device structure\nis allocated as part of re-enabling the slot, but the bandwidth table\npointers are not set up properly here.\nThis triggers the NULL pointer dereference the next time usb_ep0_reinit()\nis called and xhci_configure_endpoint() tries to check and reserve\nbandwidth\n[46710.713538] usb 3-1: new full-speed USB device number 5 using xhci_hcd\n[46710.713699] usb 3-1: Device not responding to setup address.\n[46710.917684] usb 3-1: Device not responding to setup address.\n[46711.125536] usb 3-1: device not accepting address 5, error -71\n[46711.125594] BUG: kernel NULL pointer dereference, address: 0000000000000008\n[46711.125600] #PF: supervisor read access in kernel mode\n[46711.125603] #PF: error_code(0x0000) - not-present page\n[46711.125606] PGD 0 P4D 0\n[46711.125610] Oops: Oops: 0000 [#1] PREEMPT SMP PTI\n[46711.125615] CPU: 1 PID: 25760 Comm: kworker/1:2 Not tainted 6.10.3_2 #1\n[46711.125620] Hardware name: Gigabyte Technology Co., Ltd.\n[46711.125623] Workqueue: usb_hub_wq hub_event [usbcore]\n[46711.125668] RIP: 0010:xhci_reserve_bandwidth (drivers/usb/host/xhci.c\nFix this by making sure bandwidth table pointers are set up correctly\nafter a failed address device command, and additionally by avoiding\nchecking for bandwidth in cases like this where no actual endpoints are\nadded or removed, i.e. only context for default control endpoint 0 is\nevaluated.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0f0654318e25b2c185e245ba4a591e42fabb5e59"
          },
          {
            "url": "https://git.kernel.org/stable/c/365ef7c4277fdd781a695c3553fa157d622d805d"
          },
          {
            "url": "https://git.kernel.org/stable/c/5ad898ae82412f8a689d59829804bff2999dd0ea"
          },
          {
            "url": "https://git.kernel.org/stable/c/6b99de301d78e1f5249e57ef2c32e1dec3df2bb1"
          },
          {
            "url": "https://git.kernel.org/stable/c/8fb9d412ebe2f245f13481e4624b40e651570cbd"
          },
          {
            "url": "https://git.kernel.org/stable/c/a57b0ebabe6862dce0a2e0f13e17941ad72fc56b"
          },
          {
            "url": "https://git.kernel.org/stable/c/af8e119f52e9c13e556be9e03f27957554a84656"
          },
          {
            "url": "https://git.kernel.org/stable/c/ef0a0e616b2789bb804a0ce5e161db03170a85b6"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45007",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:09.053",
        "lastModified": "2024-09-04T20:15:09.053",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nchar: xillybus: Don't destroy workqueue from work item running on it\nTriggered by a kref decrement, destroy_workqueue() may be called from\nwithin a work item for destroying its own workqueue. This illegal\nsituation is averted by adding a module-global workqueue for exclusive\nuse of the offending work item. Other work items continue to be queued\non per-device workqueues to ensure performance.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/409b495f8e3300d5fba08bc817fa8825dae48cc9"
          },
          {
            "url": "https://git.kernel.org/stable/c/5d3567caff2a1d678aa40cc74a54e1318941fad3"
          },
          {
            "url": "https://git.kernel.org/stable/c/a7ad105b12256ec7fb6d6d1a0e2e60f00b7da157"
          },
          {
            "url": "https://git.kernel.org/stable/c/aa1a19724fa2c31e97a9be48baedd4692b265157"
          },
          {
            "url": "https://git.kernel.org/stable/c/ccbde4b128ef9c73d14d0d7817d68ef795f6d131"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45008",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T20:15:09.107",
        "lastModified": "2024-09-04T20:15:09.107",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nInput: MT - limit max slots\nsyzbot is reporting too large allocation at input_mt_init_slots(), for\nnum_slots is supplied from userspace using ioctl(UI_DEV_CREATE).\nSince nobody knows possible max slots, this patch chose 1024.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/05dd9aabd04f9b5eb04dab9bb83d8c3e982d7549"
          },
          {
            "url": "https://git.kernel.org/stable/c/2829c80614890624456337e47320289112785f3e"
          },
          {
            "url": "https://git.kernel.org/stable/c/87f610a1a7fbdb1f2e3d90b54c955bd3b8a0c322"
          },
          {
            "url": "https://git.kernel.org/stable/c/8f04edd554d191834e9e1349ef030318ea6b11ba"
          },
          {
            "url": "https://git.kernel.org/stable/c/94736334b8a25e4fae8daa6934e54a31f099be43"
          },
          {
            "url": "https://git.kernel.org/stable/c/95f73d01f547dfc67fda3022c51e377a0454b505"
          },
          {
            "url": "https://git.kernel.org/stable/c/99d3bf5f7377d42f8be60a6b9cb60fb0be34dceb"
          },
          {
            "url": "https://git.kernel.org/stable/c/cd19f1799c32ba7b874474b1b968815ce5364f73"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45172",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-09-04T20:15:09.167",
        "lastModified": "2024-09-04T20:35:20.010",
        "baseScore": 6.8,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 0.9,
        "impactScore": 5.9,
        "description": "An issue was discovered in za-internet C-MOR Video Surveillance 5.2401 and 6.00PL01. Due to missing protection mechanisms, the C-MOR web interface is vulnerable to cross-site request forgery (CSRF) attacks. The C-MOR web interface offers no protection against cross-site request forgery (CSRF) attacks.",
        "cweIds": [
          {
            "id": "CWE-352",
            "description": "Cross-Site Request Forgery (CSRF)"
          }
        ],
        "references": [
          {
            "url": "https://www.syss.de/fileadmin/dokumente/Publikationen/Advisories/SYSS-2024-022.txt"
          },
          {
            "url": "https://www.syss.de/pentest-blog/mehrere-sicherheitsschwachstellen-in-videoueberwachungssoftware-c-mor-syss-2024-020-bis-030"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45399",
        "sourceIdentifier": "security-advisories@github.com",
        "published": "2024-09-04T20:15:09.257",
        "lastModified": "2024-09-04T20:15:09.257",
        "baseScore": 4.3,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 2.8,
        "impactScore": 1.4,
        "description": "Indico is an event management system that uses Flask-Multipass, a multi-backend authentication system for Flask. In Indico prior to version 3.3.4, corresponding to Flask-Multipass prior to version 0.5.5, there is a Cross-Site-Scripting vulnerability during account creation when redirecting to the `next` URL. Exploitation requires initiating the account creation process with a maliciously crafted link, and then finalizing the signup process. Because of this, it can only target newly created (and thus unprivileged) Indico users. Indico 3.3.4 upgrades the dependency on Flask-Multipass to version 0.5.5, which fixes the issue. Those who build the Indico package themselves and cannot upgrade can update the `flask-multipass` dependency to `>=0.5.5` which fixes the vulnerability. Otherwise one could configure one's web server to disallow requests containing a query string with a `next` parameter that starts with `javascript:`.",
        "cweIds": [
          {
            "id": "CWE-79",
            "description": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
          }
        ],
        "references": [
          {
            "url": "https://github.com/indico/flask-multipass/commit/0bdcf656d469e5f675cb56fd644d82fea3a97c2a"
          },
          {
            "url": "https://github.com/indico/indico/commit/7dcb573837b9fd09d95f74d1baeae225b164cc8f"
          },
          {
            "url": "https://github.com/indico/indico/releases/tag/v3.3.4"
          },
          {
            "url": "https://github.com/indico/indico/security/advisories/GHSA-rrqf-w74j-24ff"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-45395",
        "sourceIdentifier": "security-advisories@github.com",
        "published": "2024-09-04T21:15:14.237",
        "lastModified": "2024-09-04T21:15:14.237",
        "baseScore": 3.1,
        "baseSeverity": "LOW",
        "exploitabilityScore": 1.6,
        "impactScore": 1.4,
        "description": "sigstore-go, a Go library for Sigstore signing and verification, is susceptible to a denial of service attack in versions prior to 0.6.1 when a verifier is provided a maliciously crafted Sigstore Bundle containing large amounts of verifiable data, in the form of signed transparency log entries, RFC 3161 timestamps, and attestation subjects. The verification of these data structures is computationally expensive. This can be used to consume excessive CPU resources, leading to a denial of service attack. TUF's security model labels this type of vulnerability an \"Endless data attack,\" and can lead to verification failing to complete and disrupting services that rely on sigstore-go for verification. This vulnerability is addressed with sigstore-go 0.6.1, which adds hard limits to the number of verifiable data structures that can be processed in a bundle. Verification will fail if a bundle has data that exceeds these limits. The limits are 32 signed transparency log entries, 32 RFC 3161 timestamps, 1024 attestation subjects, and 32 digests per attestation subject. These limits are intended to be high enough to accommodate the vast majority of use cases, while preventing the verification of maliciously crafted bundles that contain large amounts of verifiable data. Users who are vulnerable but unable to quickly upgrade may consider adding manual bundle validation to enforce limits similar to those in the referenced patch prior to calling sigstore-go's verification functions.",
        "cweIds": [
          {
            "id": "CWE-835",
            "description": "Loop with Unreachable Exit Condition ('Infinite Loop')"
          }
        ],
        "references": [
          {
            "url": "https://github.com/sigstore/sigstore-go/blob/725e508ed4933e6f5b5206e32af4bbe76f587b54/pkg/verify/signature.go#L183-L193"
          },
          {
            "url": "https://github.com/sigstore/sigstore-go/blob/725e508ed4933e6f5b5206e32af4bbe76f587b54/pkg/verify/tlog.go#L74-L178"
          },
          {
            "url": "https://github.com/sigstore/sigstore-go/blob/725e508ed4933e6f5b5206e32af4bbe76f587b54/pkg/verify/tsa.go#L59-L68"
          },
          {
            "url": "https://github.com/sigstore/sigstore-go/commit/01e70e89e58226286d7977b4dba43b6be472b12c"
          },
          {
            "url": "https://github.com/sigstore/sigstore-go/security/advisories/GHSA-cq38-jh5f-37mq"
          }
        ]
      }
    }
  ]
}