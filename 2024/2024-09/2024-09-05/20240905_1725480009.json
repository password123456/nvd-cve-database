{
  "totalResults": 29,
  "datePublished": "2024-09-05T05:00:09.118280Z",
  "vulnerabilities": [
    {
      "cve": {
        "id": "CVE-2024-45177",
        "sourceIdentifier": "cve@mitre.org",
        "published": "2024-09-04T18:15:05.270",
        "lastModified": "2024-09-04T19:35:16.267",
        "baseScore": 5.4,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 2.3,
        "impactScore": 2.7,
        "description": "An issue was discovered in za-internet C-MOR Video Surveillance 5.2401 and 6.00PL01. Due to improper input validation, the C-MOR web interface is vulnerable to persistent cross-site scripting (XSS) attacks. It was found out that the camera configuration is vulnerable to a persistent cross-site scripting attack due to insufficient user input validation.",
        "cweIds": [
          {
            "id": "CWE-79",
            "description": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
          }
        ],
        "references": [
          {
            "url": "https://www.syss.de/fileadmin/dokumente/Publikationen/Advisories/SYSS-2024-021.txt"
          },
          {
            "url": "https://www.syss.de/pentest-blog/mehrere-sicherheitsschwachstellen-in-videoueberwachungssoftware-c-mor-syss-2024-020-bis-030"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-8416",
        "sourceIdentifier": "cna@vuldb.com",
        "published": "2024-09-04T18:15:05.980",
        "lastModified": "2024-09-04T18:15:05.980",
        "baseScore": 6.3,
        "baseSeverity": "MEDIUM",
        "exploitabilityScore": 2.8,
        "impactScore": 3.4,
        "description": "A vulnerability was found in SourceCodester Food Ordering Management System 1.0. It has been classified as critical. This affects an unknown part of the file /routers/ticket-status.php. The manipulation of the argument ticket_id leads to sql injection. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used.",
        "cweIds": [
          {
            "id": "CWE-89",
            "description": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
          }
        ],
        "references": [
          {
            "url": "https://github.com/SherlockMA0/cve/blob/main/sql2.md"
          },
          {
            "url": "https://vuldb.com/?ctiid.276495"
          },
          {
            "url": "https://vuldb.com/?id.276495"
          },
          {
            "url": "https://vuldb.com/?submit.402369"
          },
          {
            "url": "https://www.sourcecodester.com/"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-8417",
        "sourceIdentifier": "cna@vuldb.com",
        "published": "2024-09-04T18:15:06.273",
        "lastModified": "2024-09-04T18:15:06.273",
        "baseScore": 3.1,
        "baseSeverity": "LOW",
        "exploitabilityScore": 1.6,
        "impactScore": 1.4,
        "description": "A vulnerability was found in 云课网络科技有限公司 Yunke Online School System up to 1.5.5. It has been declared as problematic. This vulnerability affects unknown code of the file /admin/educloud/videobind.html. The manipulation leads to inclusion of sensitive information in source code. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 1.5.6 is able to address this issue. It is recommended to upgrade the affected component.",
        "cweIds": [
          {
            "id": "CWE-540",
            "description": "Inclusion of Sensitive Information in Source Code"
          }
        ],
        "references": [
          {
            "url": "https://vuldb.com/?ctiid.276496"
          },
          {
            "url": "https://vuldb.com/?id.276496"
          },
          {
            "url": "https://vuldb.com/?submit.402376"
          },
          {
            "url": "https://wiki.shikangsi.com/post/share/d31fefa1-ca08-48d7-a671-727d63bfaf65"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44948",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:29.950",
        "lastModified": "2024-09-04T19:15:29.950",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nx86/mtrr: Check if fixed MTRRs exist before saving them\nMTRRs have an obsolete fixed variant for fine grained caching control\nof the 640K-1MB region that uses separate MSRs. This fixed variant has\na separate capability bit in the MTRR capability MSR.\nSo far all x86 CPUs which support MTRR have this separate bit set, so it\nwent unnoticed that mtrr_save_state() does not check the capability bit\nbefore accessing the fixed MTRR MSRs.\nThough on a CPU that does not support the fixed MTRR capability this\nresults in a #GP.  The #GP itself is harmless because the RDMSR fault is\nhandled gracefully, but results in a WARN_ON().\nAdd the missing capability check to prevent this.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/06c1de44d378ec5439db17bf476507d68589bfe9"
          },
          {
            "url": "https://git.kernel.org/stable/c/34f36e6ee5bd7eff8b2adcd9fcaef369f752d82e"
          },
          {
            "url": "https://git.kernel.org/stable/c/388f1c954019f253a8383f7eb733f38d541e10b6"
          },
          {
            "url": "https://git.kernel.org/stable/c/450b6b22acdaac67a18eaf5ed498421ffcf10051"
          },
          {
            "url": "https://git.kernel.org/stable/c/8a90d3fc7c24608548d3a750671f9dac21d1a462"
          },
          {
            "url": "https://git.kernel.org/stable/c/8aa79dfb216b865e96ff890bc4ea71650f9bc8d7"
          },
          {
            "url": "https://git.kernel.org/stable/c/919f18f961c03d6694aa726c514184f2311a4614"
          },
          {
            "url": "https://git.kernel.org/stable/c/ca7d00c5656d1791e28369919e3e10febe9c3b16"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44949",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:30.040",
        "lastModified": "2024-09-04T19:15:30.040",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nparisc: fix a possible DMA corruption\nARCH_DMA_MINALIGN was defined as 16 - this is too small - it may be\npossible that two unrelated 16-byte allocations share a cache line. If\none of these allocations is written using DMA and the other is written\nusing cached write, the value that was written with DMA may be\ncorrupted.\nThis commit changes ARCH_DMA_MINALIGN to be 128 on PA20 and 32 on PA1.1 -\nthat's the largest possible cache line size.\nAs different parisc microarchitectures have different cache line size, we\ndefine arch_slab_minalign(), cache_line_size() and\ndma_get_cache_alignment() so that the kernel may tune slab cache\nparameters dynamically, based on the detected cache line size.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/533de2f470baac40d3bf622fe631f15231a03c9f"
          },
          {
            "url": "https://git.kernel.org/stable/c/642a0b7453daff0295310774016fcb56d1f5bc7f"
          },
          {
            "url": "https://git.kernel.org/stable/c/7ae04ba36b381bffe2471eff3a93edced843240f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44950",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:30.100",
        "lastModified": "2024-09-04T19:15:30.100",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nserial: sc16is7xx: fix invalid FIFO access with special register set\nWhen enabling access to the special register set, Receiver time-out and\nRHR interrupts can happen. In this case, the IRQ handler will try to read\nfrom the FIFO thru the RHR register at address 0x00, but address 0x00 is\nmapped to DLL register, resulting in erroneous FIFO reading.\nCall graph example:\n    sc16is7xx_startup(): entry\n    sc16is7xx_ms_proc(): entry\n    sc16is7xx_set_termios(): entry\n    sc16is7xx_set_baud(): DLH/DLL = $009C --> access special register set\n    sc16is7xx_port_irq() entry            --> IIR is 0x0C\n    sc16is7xx_handle_rx() entry\n    sc16is7xx_fifo_read(): --> unable to access FIFO (RHR) because it is\n                               mapped to DLL (LCR=LCR_CONF_MODE_A)\n    sc16is7xx_set_baud(): exit --> Restore access to general register set\nFix the problem by claiming the efr_lock mutex when accessing the Special\nregister set.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/6a6730812220a9a5ce4003eb347da1ee5abd06b0"
          },
          {
            "url": "https://git.kernel.org/stable/c/7d3b793faaab1305994ce568b59d61927235f57b"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44951",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:30.153",
        "lastModified": "2024-09-04T19:15:30.153",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nserial: sc16is7xx: fix TX fifo corruption\nSometimes, when a packet is received on channel A at almost the same time\nas a packet is about to be transmitted on channel B, we observe with a\nlogic analyzer that the received packet on channel A is transmitted on\nchannel B. In other words, the Tx buffer data on channel B is corrupted\nwith data from channel A.\nThe problem appeared since commit 4409df5866b7 (\"serial: sc16is7xx: change\nEFR lock to operate on each channels\"), which changed the EFR locking to\noperate on each channel instead of chip-wise.\nThis commit has introduced a regression, because the EFR lock is used not\nonly to protect the EFR registers access, but also, in a very obscure and\nundocumented way, to protect access to the data buffer, which is shared by\nthe Tx and Rx handlers, but also by each channel of the IC.\nFix this regression first by switching to kfifo_out_linear_ptr() in\nsc16is7xx_handle_tx() to eliminate the need for a shared Rx/Tx buffer.\nSecondly, replace the chip-wise Rx buffer with a separate Rx buffer for\neach channel.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/09cfe05e9907f3276887a20e267cc40e202f4fdd"
          },
          {
            "url": "https://git.kernel.org/stable/c/133f4c00b8b2bfcacead9b81e7e8edfceb4b06c4"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44952",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:30.213",
        "lastModified": "2024-09-04T19:15:30.213",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndriver core: Fix uevent_show() vs driver detach race\nuevent_show() wants to de-reference dev->driver->name. There is no clean\nway for a device attribute to de-reference dev->driver unless that\nattribute is defined via (struct device_driver).dev_groups. Instead, the\nanti-pattern of taking the device_lock() in the attribute handler risks\ndeadlocks with code paths that remove device attributes while holding\nthe lock.\nThis deadlock is typically invisible to lockdep given the device_lock()\nis marked lockdep_set_novalidate_class(), but some subsystems allocate a\nlocal lockdep key for @dev->mutex to reveal reports of the form:\n ======================================================\n WARNING: possible circular locking dependency detected\n 6.10.0-rc7+ #275 Tainted: G           OE    N\n ------------------------------------------------------\n modprobe/2374 is trying to acquire lock:\n ffff8c2270070de0 (kn->active#6){++++}-{0:0}, at: __kernfs_remove+0xde/0x220\n but task is already holding lock:\n ffff8c22016e88f8 (&cxl_root_key){+.+.}-{3:3}, at: device_release_driver_internal+0x39/0x210\n which lock already depends on the new lock.\n the existing dependency chain (in reverse order) is:\n -> #1 (&cxl_root_key){+.+.}-{3:3}:\n        __mutex_lock+0x99/0xc30\n        uevent_show+0xac/0x130\n        dev_attr_show+0x18/0x40\n        sysfs_kf_seq_show+0xac/0xf0\n        seq_read_iter+0x110/0x450\n        vfs_read+0x25b/0x340\n        ksys_read+0x67/0xf0\n        do_syscall_64+0x75/0x190\n        entry_SYSCALL_64_after_hwframe+0x76/0x7e\n -> #0 (kn->active#6){++++}-{0:0}:\n        __lock_acquire+0x121a/0x1fa0\n        lock_acquire+0xd6/0x2e0\n        kernfs_drain+0x1e9/0x200\n        __kernfs_remove+0xde/0x220\n        kernfs_remove_by_name_ns+0x5e/0xa0\n        device_del+0x168/0x410\n        device_unregister+0x13/0x60\n        devres_release_all+0xb8/0x110\n        device_unbind_cleanup+0xe/0x70\n        device_release_driver_internal+0x1c7/0x210\n        driver_detach+0x47/0x90\n        bus_remove_driver+0x6c/0xf0\n        cxl_acpi_exit+0xc/0x11 [cxl_acpi]\n        __do_sys_delete_module.isra.0+0x181/0x260\n        do_syscall_64+0x75/0x190\n        entry_SYSCALL_64_after_hwframe+0x76/0x7e\nThe observation though is that driver objects are typically much longer\nlived than device objects. It is reasonable to perform lockless\nde-reference of a @driver pointer even if it is racing detach from a\ndevice. Given the infrequency of driver unregistration, use\nsynchronize_rcu() in module_remove_driver() to close any potential\nraces.  It is potentially overkill to suffer synchronize_rcu() just to\nhandle the rare module removal racing uevent_show() event.\nThanks to Tetsuo Handa for the debug analysis of the syzbot report [1].",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/15fffc6a5624b13b428bb1c6e9088e32a55eb82c"
          },
          {
            "url": "https://git.kernel.org/stable/c/49ea4e0d862632d51667da5e7a9c88a560e9c5a1"
          },
          {
            "url": "https://git.kernel.org/stable/c/4a7c2a8387524942171037e70b80e969c3b5c05b"
          },
          {
            "url": "https://git.kernel.org/stable/c/4d035c743c3e391728a6f81cbf0f7f9ca700cf62"
          },
          {
            "url": "https://git.kernel.org/stable/c/9c23fc327d6ec67629b4ad323bd64d3834c0417d"
          },
          {
            "url": "https://git.kernel.org/stable/c/cd490a247ddf325325fd0de8898659400c9237ef"
          },
          {
            "url": "https://git.kernel.org/stable/c/dd98c9630b7ee273da87e9a244f94ddf947161e2"
          },
          {
            "url": "https://git.kernel.org/stable/c/f098e8fc7227166206256c18d56ab622039108b1"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44953",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:30.297",
        "lastModified": "2024-09-04T19:15:30.297",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nscsi: ufs: core: Fix deadlock during RTC update\nThere is a deadlock when runtime suspend waits for the flush of RTC work,\nand the RTC work calls ufshcd_rpm_get_sync() to wait for runtime resume.\nHere is deadlock backtrace:\nkworker/0:1     D 4892.876354 10 10971 4859 0x4208060 0x8 10 0 120 670730152367\nptr            f0ffff80c2e40000 0 1 0x00000001 0x000000ff 0x000000ff 0x000000ff\n<ffffffee5e71ddb0> __switch_to+0x1a8/0x2d4\n<ffffffee5e71e604> __schedule+0x684/0xa98\n<ffffffee5e71ea60> schedule+0x48/0xc8\n<ffffffee5e725f78> schedule_timeout+0x48/0x170\n<ffffffee5e71fb74> do_wait_for_common+0x108/0x1b0\n<ffffffee5e71efe0> wait_for_completion+0x44/0x60\n<ffffffee5d6de968> __flush_work+0x39c/0x424\n<ffffffee5d6decc0> __cancel_work_sync+0xd8/0x208\n<ffffffee5d6dee2c> cancel_delayed_work_sync+0x14/0x28\n<ffffffee5e2551b8> __ufshcd_wl_suspend+0x19c/0x480\n<ffffffee5e255fb8> ufshcd_wl_runtime_suspend+0x3c/0x1d4\n<ffffffee5dffd80c> scsi_runtime_suspend+0x78/0xc8\n<ffffffee5df93580> __rpm_callback+0x94/0x3e0\n<ffffffee5df90b0c> rpm_suspend+0x2d4/0x65c\n<ffffffee5df91448> __pm_runtime_suspend+0x80/0x114\n<ffffffee5dffd95c> scsi_runtime_idle+0x38/0x6c\n<ffffffee5df912f4> rpm_idle+0x264/0x338\n<ffffffee5df90f14> __pm_runtime_idle+0x80/0x110\n<ffffffee5e24ce44> ufshcd_rtc_work+0x128/0x1e4\n<ffffffee5d6e3a40> process_one_work+0x26c/0x650\n<ffffffee5d6e65c8> worker_thread+0x260/0x3d8\n<ffffffee5d6edec8> kthread+0x110/0x134\n<ffffffee5d616b18> ret_from_fork+0x10/0x20\nSkip updating RTC if RPM state is not RPM_ACTIVE.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3911af778f208e5f49d43ce739332b91e26bc48e"
          },
          {
            "url": "https://git.kernel.org/stable/c/f13f1858a28c68b7fc0d72c2008d5c1f80d2e8d5"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44954",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:30.353",
        "lastModified": "2024-09-04T19:15:30.353",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nALSA: line6: Fix racy access to midibuf\nThere can be concurrent accesses to line6 midibuf from both the URB\ncompletion callback and the rawmidi API access.  This could be a cause\nof KMSAN warning triggered by syzkaller below (so put as reported-by\nhere).\nThis patch protects the midibuf call of the former code path with a\nspinlock for avoiding the possible races.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/15b7a03205b31bc5623378c190d22b7ff60026f1"
          },
          {
            "url": "https://git.kernel.org/stable/c/40f3d5cb0e0cbf7fa697913a27d5d361373bdcf5"
          },
          {
            "url": "https://git.kernel.org/stable/c/51d87f11dd199bbc6a85982b088ff27bde53b48a"
          },
          {
            "url": "https://git.kernel.org/stable/c/535df7f896a568a8a1564114eaea49d002cb1747"
          },
          {
            "url": "https://git.kernel.org/stable/c/643293b68fbb6c03f5e907736498da17d43f0d81"
          },
          {
            "url": "https://git.kernel.org/stable/c/a54da4b787dcac60b598da69c9c0072812b8282d"
          },
          {
            "url": "https://git.kernel.org/stable/c/c80f454a805443c274394b1db0d1ebf477abd94e"
          },
          {
            "url": "https://git.kernel.org/stable/c/e7e7d2b180d8f297cea6db43ea72402fd33e1a29"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44955",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:30.423",
        "lastModified": "2024-09-04T19:15:30.423",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/amd/display: Don't refer to dc_sink in is_dsc_need_re_compute\n[Why]\nWhen unplug one of monitors connected after mst hub, encounter null pointer dereference.\nIt's due to dc_sink get released immediately in early_unregister() or detect_ctx(). When\ncommit new state which directly referring to info stored in dc_sink will cause null pointer\ndereference.\n[how]\nRemove redundant checking condition. Relevant condition should already be covered by checking\nif dsc_aux is null or not. Also reset dsc_aux to NULL when the connector is disconnected.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/39b217193729aa45eded8de24d9245468a0c0263"
          },
          {
            "url": "https://git.kernel.org/stable/c/fcf6a49d79923a234844b8efe830a61f3f0584e4"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44956",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:30.480",
        "lastModified": "2024-09-04T19:15:30.480",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/xe/preempt_fence: enlarge the fence critical section\nIt is really easy to introduce subtle deadlocks in\npreempt_fence_work_func() since we operate on single global ordered-wq\nfor signalling our preempt fences behind the scenes, so even though we\nsignal a particular fence, everything in the callback should be in the\nfence critical section, since blocking in the callback will prevent\nother published fences from signalling. If we enlarge the fence critical\nsection to cover the entire callback, then lockdep should be able to\nunderstand this better, and complain if we grab a sensitive lock like\nvm->lock, which is also held when waiting on preempt fences.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3cd1585e57908b6efcd967465ef7685f40b2a294"
          },
          {
            "url": "https://git.kernel.org/stable/c/458bb83119dfee5d14c677f7846dd9363817006f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44957",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:30.523",
        "lastModified": "2024-09-04T19:15:30.523",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nxen: privcmd: Switch from mutex to spinlock for irqfds\nirqfd_wakeup() gets EPOLLHUP, when it is called by\neventfd_release() by way of wake_up_poll(&ctx->wqh, EPOLLHUP), which\ngets called under spin_lock_irqsave(). We can't use a mutex here as it\nwill lead to a deadlock.\nFix it by switching over to a spin lock.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1c682593096a487fd9aebc079a307ff7a6d054a3"
          },
          {
            "url": "https://git.kernel.org/stable/c/49f2a5da6785b2dbde93e291cae037662440346e"
          },
          {
            "url": "https://git.kernel.org/stable/c/c2775ae4d9227729f8ca9ee2a068f62a00d5ea9c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44958",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:30.580",
        "lastModified": "2024-09-04T19:15:30.580",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nsched/smt: Fix unbalance sched_smt_present dec/inc\nI got the following warn report while doing stress test:\njump label: negative count!\nWARNING: CPU: 3 PID: 38 at kernel/jump_label.c:263 static_key_slow_try_dec+0x9d/0xb0\nCall Trace:\n <TASK>\n __static_key_slow_dec_cpuslocked+0x16/0x70\n sched_cpu_deactivate+0x26e/0x2a0\n cpuhp_invoke_callback+0x3ad/0x10d0\n cpuhp_thread_fun+0x3f5/0x680\n smpboot_thread_fn+0x56d/0x8d0\n kthread+0x309/0x400\n ret_from_fork+0x41/0x70\n ret_from_fork_asm+0x1b/0x30\n </TASK>\nBecause when cpuset_cpu_inactive() fails in sched_cpu_deactivate(),\nthe cpu offline failed, but sched_smt_present is decremented before\ncalling sched_cpu_deactivate(), it leads to unbalanced dec/inc, so\nfix it by incrementing sched_smt_present in the error path.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/2a3548c7ef2e135aee40e7e5e44e7d11b893e7c4"
          },
          {
            "url": "https://git.kernel.org/stable/c/2cf7665efe451e48d27953e6b5bc627d518c902b"
          },
          {
            "url": "https://git.kernel.org/stable/c/65727331b60197b742089855ac09464c22b96f66"
          },
          {
            "url": "https://git.kernel.org/stable/c/d0c87a3c6be10a57aa3463c32c3fc6b2a47c3dab"
          },
          {
            "url": "https://git.kernel.org/stable/c/e22f910a26cc2a3ac9c66b8e935ef2a7dd881117"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44959",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:30.637",
        "lastModified": "2024-09-04T19:15:30.637",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ntracefs: Use generic inode RCU for synchronizing freeing\nWith structure layout randomization enabled for 'struct inode' we need to\navoid overlapping any of the RCU-used / initialized-only-once members,\ne.g. i_lru or i_sb_list to not corrupt related list traversals when making\nuse of the rcu_head.\nFor an unlucky structure layout of 'struct inode' we may end up with the\nfollowing splat when running the ftrace selftests:\n[<...>] list_del corruption, ffff888103ee2cb0->next (tracefs_inode_cache+0x0/0x4e0 [slab object]) is NULL (prev is tracefs_inode_cache+0x78/0x4e0 [slab object])\n[<...>] ------------[ cut here ]------------\n[<...>] kernel BUG at lib/list_debug.c:54!\n[<...>] invalid opcode: 0000 [#1] PREEMPT SMP KASAN\n[<...>] CPU: 3 PID: 2550 Comm: mount Tainted: G                 N  6.8.12-grsec+ #122 ed2f536ca62f28b087b90e3cc906a8d25b3ddc65\n[<...>] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014\n[<...>] RIP: 0010:[<ffffffff84656018>] __list_del_entry_valid_or_report+0x138/0x3e0\n[<...>] Code: 48 b8 99 fb 65 f2 ff ff ff ff e9 03 5c d9 fc cc 48 b8 99 fb 65 f2 ff ff ff ff e9 33 5a d9 fc cc 48 b8 99 fb 65 f2 ff ff ff ff <0f> 0b 4c 89 e9 48 89 ea 48 89 ee 48 c7 c7 60 8f dd 89 31 c0 e8 2f\n[<...>] RSP: 0018:fffffe80416afaf0 EFLAGS: 00010283\n[<...>] RAX: 0000000000000098 RBX: ffff888103ee2cb0 RCX: 0000000000000000\n[<...>] RDX: ffffffff84655fe8 RSI: ffffffff89dd8b60 RDI: 0000000000000001\n[<...>] RBP: ffff888103ee2cb0 R08: 0000000000000001 R09: fffffbd0082d5f25\n[<...>] R10: fffffe80416af92f R11: 0000000000000001 R12: fdf99c16731d9b6d\n[<...>] R13: 0000000000000000 R14: ffff88819ad4b8b8 R15: 0000000000000000\n[<...>] RBX: tracefs_inode_cache+0x0/0x4e0 [slab object]\n[<...>] RDX: __list_del_entry_valid_or_report+0x108/0x3e0\n[<...>] RSI: __func__.47+0x4340/0x4400\n[<...>] RBP: tracefs_inode_cache+0x0/0x4e0 [slab object]\n[<...>] RSP: process kstack fffffe80416afaf0+0x7af0/0x8000 [mount 2550 2550]\n[<...>] R09: kasan shadow of process kstack fffffe80416af928+0x7928/0x8000 [mount 2550 2550]\n[<...>] R10: process kstack fffffe80416af92f+0x792f/0x8000 [mount 2550 2550]\n[<...>] R14: tracefs_inode_cache+0x78/0x4e0 [slab object]\n[<...>] FS:  00006dcb380c1840(0000) GS:ffff8881e0600000(0000) knlGS:0000000000000000\n[<...>] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[<...>] CR2: 000076ab72b30e84 CR3: 000000000b088004 CR4: 0000000000360ef0 shadow CR4: 0000000000360ef0\n[<...>] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[<...>] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[<...>] ASID: 0003\n[<...>] Stack:\n[<...>]  ffffffff818a2315 00000000f5c856ee ffffffff896f1840 ffff888103ee2cb0\n[<...>]  ffff88812b6b9750 0000000079d714b6 fffffbfff1e9280b ffffffff8f49405f\n[<...>]  0000000000000001 0000000000000000 ffff888104457280 ffffffff8248b392\n[<...>] Call Trace:\n[<...>]  <TASK>\n[<...>]  [<ffffffff818a2315>] ? lock_release+0x175/0x380 fffffe80416afaf0\n[<...>]  [<ffffffff8248b392>] list_lru_del+0x152/0x740 fffffe80416afb48\n[<...>]  [<ffffffff8248ba93>] list_lru_del_obj+0x113/0x280 fffffe80416afb88\n[<...>]  [<ffffffff8940fd19>] ? _atomic_dec_and_lock+0x119/0x200 fffffe80416afb90\n[<...>]  [<ffffffff8295b244>] iput_final+0x1c4/0x9a0 fffffe80416afbb8\n[<...>]  [<ffffffff8293a52b>] dentry_unlink_inode+0x44b/0xaa0 fffffe80416afbf8\n[<...>]  [<ffffffff8293fefc>] __dentry_kill+0x23c/0xf00 fffffe80416afc40\n[<...>]  [<ffffffff8953a85f>] ? __this_cpu_preempt_check+0x1f/0xa0 fffffe80416afc48\n[<...>]  [<ffffffff82949ce5>] ? shrink_dentry_list+0x1c5/0x760 fffffe80416afc70\n[<...>]  [<ffffffff82949b71>] ? shrink_dentry_list+0x51/0x760 fffffe80416afc78\n[<...>]  [<ffffffff82949da8>] shrink_dentry_list+0x288/0x760 fffffe80416afc80\n[<...>]  [<ffffffff8294ae75>] shrink_dcache_sb+0x155/0x420 fffffe80416afcc8\n[<...>]  [<ffffffff8953a7c3>] ? debug_smp_processor_id+0x23/0xa0 fffffe80416afce0\n[<...>]  [<ffffffff8294ad20>] ? do_one_tre\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/061da60716ce0cde99f62f31937b81e1c03acef6"
          },
          {
            "url": "https://git.kernel.org/stable/c/0b6743bd60a56a701070b89fb80c327a44b7b3e2"
          },
          {
            "url": "https://git.kernel.org/stable/c/726f4c241e17be75a9cf6870d80cd7479dc89e8f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44960",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:30.700",
        "lastModified": "2024-09-04T19:15:30.700",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nusb: gadget: core: Check for unset descriptor\nMake sure the descriptor has been set before looking at maxpacket.\nThis fixes a null pointer panic in this case.\nThis may happen if the gadget doesn't properly set up the endpoint\nfor the current speed, or the gadget descriptors are malformed and\nthe descriptor for the speed/endpoint are not found.\nNo current gadget driver is known to have this problem, but this\nmay cause a hard-to-find bug during development of new gadgets.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1a9df57d57452b104c46c918569143cf21d7ebf1"
          },
          {
            "url": "https://git.kernel.org/stable/c/50c5248b0ea8aae0529fdf28dac42a41312d3b62"
          },
          {
            "url": "https://git.kernel.org/stable/c/716cba46f73a92645cf13eded8d257ed48afc2a4"
          },
          {
            "url": "https://git.kernel.org/stable/c/7cc9ebcfe58be22f18056ad8bc6272d120bdcb3e"
          },
          {
            "url": "https://git.kernel.org/stable/c/973a57891608a98e894db2887f278777f564de18"
          },
          {
            "url": "https://git.kernel.org/stable/c/a0362cd6e503278add954123957fd47990e8d9bf"
          },
          {
            "url": "https://git.kernel.org/stable/c/ba15815dd24cc5ec0d23e2170dc58c7db1e03b4a"
          },
          {
            "url": "https://git.kernel.org/stable/c/df8e734ae5e605348aa0ca2498aedb73e815f244"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44961",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:30.770",
        "lastModified": "2024-09-04T19:15:30.770",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/amdgpu: Forward soft recovery errors to userspace\nAs we discussed before[1], soft recovery should be\nforwarded to userspace, or we can get into a really\nbad state where apps will keep submitting hanging\ncommand buffers cascading us to a hard reset.\n1: https://lore.kernel.org/all/bf23d5ed-9a6b-43e7-84ee-8cbfd0d60f18@froggi.es/\n(cherry picked from commit 434967aadbbbe3ad9103cc29e9a327de20fdba01)",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0da0b06165d83a8ecbb6582d9d5a135f9d38a52a"
          },
          {
            "url": "https://git.kernel.org/stable/c/829798c789f567ef6ba4b084c15b7b5f3bd98d51"
          },
          {
            "url": "https://git.kernel.org/stable/c/c28d207edfc5679585f4e96acb67000076ce90be"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44962",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:30.827",
        "lastModified": "2024-09-04T19:15:30.827",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nBluetooth: btnxpuart: Shutdown timer and prevent rearming when driver unloading\nWhen unload the btnxpuart driver, its associated timer will be deleted.\nIf the timer happens to be modified at this moment, it leads to the\nkernel call this timer even after the driver unloaded, resulting in\nkernel panic.\nUse timer_shutdown_sync() instead of del_timer_sync() to prevent rearming.\npanic log:\n  Internal error: Oops: 0000000086000007 [#1] PREEMPT SMP\n  Modules linked in: algif_hash algif_skcipher af_alg moal(O) mlan(O) crct10dif_ce polyval_ce polyval_generic   snd_soc_imx_card snd_soc_fsl_asoc_card snd_soc_imx_audmux mxc_jpeg_encdec v4l2_jpeg snd_soc_wm8962 snd_soc_fsl_micfil   snd_soc_fsl_sai flexcan snd_soc_fsl_utils ap130x rpmsg_ctrl imx_pcm_dma can_dev rpmsg_char pwm_fan fuse [last unloaded:   btnxpuart]\n  CPU: 5 PID: 723 Comm: memtester Tainted: G           O       6.6.23-lts-next-06207-g4aef2658ac28 #1\n  Hardware name: NXP i.MX95 19X19 board (DT)\n  pstate: 20400009 (nzCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n  pc : 0xffff80007a2cf464\n  lr : call_timer_fn.isra.0+0x24/0x80\n...\n  Call trace:\n   0xffff80007a2cf464\n   __run_timers+0x234/0x280\n   run_timer_softirq+0x20/0x40\n   __do_softirq+0x100/0x26c\n   ____do_softirq+0x10/0x1c\n   call_on_irq_stack+0x24/0x4c\n   do_softirq_own_stack+0x1c/0x2c\n   irq_exit_rcu+0xc0/0xdc\n   el0_interrupt+0x54/0xd8\n   __el0_irq_handler_common+0x18/0x24\n   el0t_64_irq_handler+0x10/0x1c\n   el0t_64_irq+0x190/0x194\n  Code: ???????? ???????? ???????? ???????? (????????)\n  ---[ end trace 0000000000000000 ]---\n  Kernel panic - not syncing: Oops: Fatal exception in interrupt\n  SMP: stopping secondary CPUs\n  Kernel Offset: disabled\n  CPU features: 0x0,c0000000,40028143,1000721b\n  Memory Limit: none\n  ---[ end Kernel panic - not syncing: Oops: Fatal exception in interrupt ]---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/0d0df1e750bac0fdaa77940e711c1625cff08d33"
          },
          {
            "url": "https://git.kernel.org/stable/c/28bbb5011a9723700006da67bdb57ab6a914452b"
          },
          {
            "url": "https://git.kernel.org/stable/c/4d9adcb94d55e9be8a3e464d9f2ff7d27e2ed016"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44963",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:30.883",
        "lastModified": "2024-09-04T19:15:30.883",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbtrfs: do not BUG_ON() when freeing tree block after error\nWhen freeing a tree block, at btrfs_free_tree_block(), if we fail to\ncreate a delayed reference we don't deal with the error and just do a\nBUG_ON(). The error most likely to happen is -ENOMEM, and we have a\ncomment mentioning that only -ENOMEM can happen, but that is not true,\nbecause in case qgroups are enabled any error returned from\nbtrfs_qgroup_trace_extent_post() (can be -EUCLEAN or anything returned\nfrom btrfs_search_slot() for example) can be propagated back to\nbtrfs_free_tree_block().\nSo stop doing a BUG_ON() and return the error to the callers and make\nthem abort the transaction to prevent leaking space. Syzbot was\ntriggering this, likely due to memory allocation failure injection.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/98251cd60b4d702a8a81de442ab621e83a3fb24f"
          },
          {
            "url": "https://git.kernel.org/stable/c/bb3868033a4cccff7be57e9145f2117cbdc91c11"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44964",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:30.940",
        "lastModified": "2024-09-04T19:15:30.940",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nidpf: fix memory leaks and crashes while performing a soft reset\nThe second tagged commit introduced a UAF, as it removed restoring\nq_vector->vport pointers after reinitializating the structures.\nThis is due to that all queue allocation functions are performed here\nwith the new temporary vport structure and those functions rewrite\nthe backpointers to the vport. Then, this new struct is freed and\nthe pointers start leading to nowhere.\nBut generally speaking, the current logic is very fragile. It claims\nto be more reliable when the system is low on memory, but in fact, it\nconsumes two times more memory as at the moment of running this\nfunction, there are two vports allocated with their queues and vectors.\nMoreover, it claims to prevent the driver from running into \"bad state\",\nbut in fact, any error during the rebuild leaves the old vport in the\npartially allocated state.\nFinally, if the interface is down when the function is called, it always\nallocates a new queue set, but when the user decides to enable the\ninterface later on, vport_open() allocates them once again, IOW there's\na clear memory leak here.\nJust don't allocate a new queue set when performing a reset, that solves\ncrashes and memory leaks. Readd the old queue number and reopen the\ninterface on rollback - that solves limbo states when the device is left\ndisabled and/or without HW queues enabled.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/6b289f8d91537ec1e4f9c7b38b31b90d93b1419b"
          },
          {
            "url": "https://git.kernel.org/stable/c/f01032a2ca099ec8d619aaa916c3762aa62495df"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44965",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:30.990",
        "lastModified": "2024-09-04T19:15:30.990",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nx86/mm: Fix pti_clone_pgtable() alignment assumption\nGuenter reported dodgy crashes on an i386-nosmp build using GCC-11\nthat had the form of endless traps until entry stack exhaust and then\n#DF from the stack guard.\nIt turned out that pti_clone_pgtable() had alignment assumptions on\nthe start address, notably it hard assumes start is PMD aligned. This\nis true on x86_64, but very much not true on i386.\nThese assumptions can cause the end condition to malfunction, leading\nto a 'short' clone. Guess what happens when the user mapping has a\nshort copy of the entry text?\nUse the correct increment form for addr to avoid alignment\nassumptions.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/18da1b27ce16a14a9b636af9232acb4fb24f4c9e"
          },
          {
            "url": "https://git.kernel.org/stable/c/25a727233a40a9b33370eec9f0cad67d8fd312f8"
          },
          {
            "url": "https://git.kernel.org/stable/c/41e71dbb0e0a0fe214545fe64af031303a08524c"
          },
          {
            "url": "https://git.kernel.org/stable/c/4d143ae782009b43b4f366402e5c37f59d4e4346"
          },
          {
            "url": "https://git.kernel.org/stable/c/5c580c1050bcbc15c3e78090859d798dcf8c9763"
          },
          {
            "url": "https://git.kernel.org/stable/c/ca07aab70dd3b5e7fddb62d7a6ecd7a7d6d0b2ed"
          },
          {
            "url": "https://git.kernel.org/stable/c/d00c9b4bbc442d99e1dafbdfdab848bc1ead73f6"
          },
          {
            "url": "https://git.kernel.org/stable/c/df3eecb5496f87263d171b254ca6e2758ab3c35c"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44966",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:31.060",
        "lastModified": "2024-09-04T19:15:31.060",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbinfmt_flat: Fix corruption when not offsetting data start\nCommit 04d82a6d0881 (\"binfmt_flat: allow not offsetting data start\")\nintroduced a RISC-V specific variant of the FLAT format which does\nnot allocate any space for the (obsolete) array of shared library\npointers. However, it did not disable the code which initializes the\narray, resulting in the corruption of sizeof(long) bytes before the DATA\nsegment, generally the end of the TEXT segment.\nIntroduce MAX_SHARED_LIBS_UPDATE which depends on the state of\nCONFIG_BINFMT_FLAT_NO_DATA_START_OFFSET to guard the initialization of\nthe shared library pointer region so that it will only be initialized\nif space is reserved for it.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/3a684499261d0f7ed5ee72793025c88c2276809c"
          },
          {
            "url": "https://git.kernel.org/stable/c/3eb3cd5992f7a0c37edc8d05b4c38c98758d8671"
          },
          {
            "url": "https://git.kernel.org/stable/c/49df34d2b7da9e57c839555a2f7877291ce45ad1"
          },
          {
            "url": "https://git.kernel.org/stable/c/9350ba06ee61db392c486716ac68ecc20e030f7c"
          },
          {
            "url": "https://git.kernel.org/stable/c/af65d5383854cc3f172a7d0843b628758bf462c8"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44967",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:31.117",
        "lastModified": "2024-09-04T19:15:31.117",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ndrm/mgag200: Bind I2C lifetime to DRM device\nManaged cleanup with devm_add_action_or_reset() will release the I2C\nadapter when the underlying Linux device goes away. But the connector\nstill refers to it, so this cleanup leaves behind a stale pointer\nin struct drm_connector.ddc.\nBind the lifetime of the I2C adapter to the connector's lifetime by\nusing DRM's managed release. When the DRM device goes away (after\nthe Linux device) DRM will first clean up the connector and then\nclean up the I2C adapter.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/55a6916db77102765b22855d3a0add4751988b7c"
          },
          {
            "url": "https://git.kernel.org/stable/c/81d34df843620e902dd04aa9205c875833d61c17"
          },
          {
            "url": "https://git.kernel.org/stable/c/9d96b91e03cba9dfcb4ac370c93af4dbc47d5191"
          },
          {
            "url": "https://git.kernel.org/stable/c/eb1ae34e48a09b7a1179c579aed042b032e408f4"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44968",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:31.173",
        "lastModified": "2024-09-04T19:15:31.173",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ntick/broadcast: Move per CPU pointer access into the atomic section\nThe recent fix for making the take over of the broadcast timer more\nreliable retrieves a per CPU pointer in preemptible context.\nThis went unnoticed as compilers hoist the access into the non-preemptible\nregion where the pointer is actually used. But of course it's valid that\nthe compiler keeps it at the place where the code puts it which rightfully\ntriggers:\n  BUG: using smp_processor_id() in preemptible [00000000] code:\n       caller is hotplug_cpu__broadcast_tick_pull+0x1c/0xc0\nMove it to the actual usage site which is in a non-preemptible region.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/541a900d245536d4809cb1aa322c3fcc2cdb58a6"
          },
          {
            "url": "https://git.kernel.org/stable/c/668c6c4a7e9e9f081c06b70f30104fb7013437ed"
          },
          {
            "url": "https://git.kernel.org/stable/c/6881e75237a84093d0986f56223db3724619f26e"
          },
          {
            "url": "https://git.kernel.org/stable/c/7b3ec186ba93e333e9efe7254e7e31c1828e5d2d"
          },
          {
            "url": "https://git.kernel.org/stable/c/7dd12f85f150010ef7518201c63fa7e395f5c3e9"
          },
          {
            "url": "https://git.kernel.org/stable/c/b9d604933d5fd72dd37f24e1dc35f778297d745a"
          },
          {
            "url": "https://git.kernel.org/stable/c/f54abf332a2bc0413cfa8bd6a8511f7aa99faea0"
          },
          {
            "url": "https://git.kernel.org/stable/c/f91fb47ecacc178a83a77eeebd25cbaec18c01d6"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44969",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:31.240",
        "lastModified": "2024-09-04T19:15:31.240",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\ns390/sclp: Prevent release of buffer in I/O\nWhen a task waiting for completion of a Store Data operation is\ninterrupted, an attempt is made to halt this operation. If this attempt\nfails due to a hardware or firmware problem, there is a chance that the\nSCLP facility might store data into buffers referenced by the original\noperation at a later time.\nHandle this situation by not releasing the referenced data buffers if\nthe halt attempt fails. For current use cases, this might result in a\nleak of few pages of memory in case of a rare hardware/firmware\nmalfunction.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/1e8b7fb427af6b2ddd54eff66a6b428a81c96633"
          },
          {
            "url": "https://git.kernel.org/stable/c/1ec5ea9e25f582fd6999393e2f2c3bf56f234e05"
          },
          {
            "url": "https://git.kernel.org/stable/c/2429ea3b4330e3653b72b210a0d5f2a717359506"
          },
          {
            "url": "https://git.kernel.org/stable/c/46f67233b011385d53cf14d272431755de3a7c79"
          },
          {
            "url": "https://git.kernel.org/stable/c/7a7e60ed23d471a07dbbe72565d2992ee8244bbe"
          },
          {
            "url": "https://git.kernel.org/stable/c/a3e52a4c22c846858a6875e1c280030a3849e148"
          },
          {
            "url": "https://git.kernel.org/stable/c/a88a49473c94ccfd8dce1e766aacf3c627278463"
          },
          {
            "url": "https://git.kernel.org/stable/c/bf365071ea92b9579d5a272679b74052a5643e35"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44970",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:31.307",
        "lastModified": "2024-09-04T19:15:31.307",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet/mlx5e: SHAMPO, Fix invalid WQ linked list unlink\nWhen all the strides in a WQE have been consumed, the WQE is unlinked\nfrom the WQ linked list (mlx5_wq_ll_pop()). For SHAMPO, it is possible\nto receive CQEs with 0 consumed strides for the same WQE even after the\nWQE is fully consumed and unlinked. This triggers an additional unlink\nfor the same wqe which corrupts the linked list.\nFix this scenario by accepting 0 sized consumed strides without\nunlinking the WQE again.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/50d8009a0ac02c3311b23a0066511f8337bd88d9"
          },
          {
            "url": "https://git.kernel.org/stable/c/650e24748e1e0a7ff91d5c72b72a2f2a452b5b76"
          },
          {
            "url": "https://git.kernel.org/stable/c/7b379353e9144e1f7460ff15f39862012c9d0d78"
          },
          {
            "url": "https://git.kernel.org/stable/c/fba8334721e266f92079632598e46e5f89082f30"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44971",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:31.367",
        "lastModified": "2024-09-04T19:15:31.367",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nnet: dsa: bcm_sf2: Fix a possible memory leak in bcm_sf2_mdio_register()\nbcm_sf2_mdio_register() calls of_phy_find_device() and then\nphy_device_remove() in a loop to remove existing PHY devices.\nof_phy_find_device() eventually calls bus_find_device(), which calls\nget_device() on the returned struct device * to increment the refcount.\nThe current implementation does not decrement the refcount, which causes\nmemory leak.\nThis commit adds the missing phy_device_free() call to decrement the\nrefcount via put_device() to balance the refcount.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/7feef10768ea71d468d9bbc1e0d14c461876768c"
          },
          {
            "url": "https://git.kernel.org/stable/c/a7d2808d67570e6acae45c2a96e0d59986888e4c"
          },
          {
            "url": "https://git.kernel.org/stable/c/b7b8d9f5e679af60c94251fd6728dde34be69a71"
          },
          {
            "url": "https://git.kernel.org/stable/c/c05516c072903f6fb9134b8e7e1ad4bffcdc4819"
          },
          {
            "url": "https://git.kernel.org/stable/c/e3862093ee93fcfbdadcb7957f5f8974fffa806a"
          },
          {
            "url": "https://git.kernel.org/stable/c/f3d5efe18a11f94150fee8b3fda9d62079af640a"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44972",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:31.430",
        "lastModified": "2024-09-04T19:15:31.430",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nbtrfs: do not clear page dirty inside extent_write_locked_range()\n[BUG]\nFor subpage + zoned case, the following workload can lead to rsv data\nleak at unmount time:\n  # mkfs.btrfs -f -s 4k $dev\n  # mount $dev $mnt\n  # fsstress -w -n 8 -d $mnt -s 1709539240\n  0/0: fiemap - no filename\n  0/1: copyrange read - no filename\n  0/2: write - no filename\n  0/3: rename - no source filename\n  0/4: creat f0 x:0 0 0\n  0/4: creat add id=0,parent=-1\n  0/5: writev f0[259 1 0 0 0 0] [778052,113,965] 0\n  0/6: ioctl(FIEMAP) f0[259 1 0 0 224 887097] [1294220,2291618343991484791,0x10000] -1\n  0/7: dwrite - xfsctl(XFS_IOC_DIOINFO) f0[259 1 0 0 224 887097] return 25, fallback to stat()\n  0/7: dwrite f0[259 1 0 0 224 887097] [696320,102400] 0\n  # umount $mnt\nThe dmesg includes the following rsv leak detection warning (all call\ntrace skipped):\n  ------------[ cut here ]------------\n  WARNING: CPU: 2 PID: 4528 at fs/btrfs/inode.c:8653 btrfs_destroy_inode+0x1e0/0x200 [btrfs]\n  ---[ end trace 0000000000000000 ]---\n  ------------[ cut here ]------------\n  WARNING: CPU: 2 PID: 4528 at fs/btrfs/inode.c:8654 btrfs_destroy_inode+0x1a8/0x200 [btrfs]\n  ---[ end trace 0000000000000000 ]---\n  ------------[ cut here ]------------\n  WARNING: CPU: 2 PID: 4528 at fs/btrfs/inode.c:8660 btrfs_destroy_inode+0x1a0/0x200 [btrfs]\n  ---[ end trace 0000000000000000 ]---\n  BTRFS info (device sda): last unmount of filesystem 1b4abba9-de34-4f07-9e7f-157cf12a18d6\n  ------------[ cut here ]------------\n  WARNING: CPU: 3 PID: 4528 at fs/btrfs/block-group.c:4434 btrfs_free_block_groups+0x338/0x500 [btrfs]\n  ---[ end trace 0000000000000000 ]---\n  BTRFS info (device sda): space_info DATA has 268218368 free, is not full\n  BTRFS info (device sda): space_info total=268435456, used=204800, pinned=0, reserved=0, may_use=12288, readonly=0 zone_unusable=0\n  BTRFS info (device sda): global_block_rsv: size 0 reserved 0\n  BTRFS info (device sda): trans_block_rsv: size 0 reserved 0\n  BTRFS info (device sda): chunk_block_rsv: size 0 reserved 0\n  BTRFS info (device sda): delayed_block_rsv: size 0 reserved 0\n  BTRFS info (device sda): delayed_refs_rsv: size 0 reserved 0\n  ------------[ cut here ]------------\n  WARNING: CPU: 3 PID: 4528 at fs/btrfs/block-group.c:4434 btrfs_free_block_groups+0x338/0x500 [btrfs]\n  ---[ end trace 0000000000000000 ]---\n  BTRFS info (device sda): space_info METADATA has 267796480 free, is not full\n  BTRFS info (device sda): space_info total=268435456, used=131072, pinned=0, reserved=0, may_use=262144, readonly=0 zone_unusable=245760\n  BTRFS info (device sda): global_block_rsv: size 0 reserved 0\n  BTRFS info (device sda): trans_block_rsv: size 0 reserved 0\n  BTRFS info (device sda): chunk_block_rsv: size 0 reserved 0\n  BTRFS info (device sda): delayed_block_rsv: size 0 reserved 0\n  BTRFS info (device sda): delayed_refs_rsv: size 0 reserved 0\nAbove $dev is a tcmu-runner emulated zoned HDD, which has a max zone\nappend size of 64K, and the system has 64K page size.\n[CAUSE]\nI have added several trace_printk() to show the events (header skipped):\n  > btrfs_dirty_pages: r/i=5/259 dirty start=774144 len=114688\n  > btrfs_dirty_pages: r/i=5/259 dirty part of page=720896 off_in_page=53248 len_in_page=12288\n  > btrfs_dirty_pages: r/i=5/259 dirty part of page=786432 off_in_page=0 len_in_page=65536\n  > btrfs_dirty_pages: r/i=5/259 dirty part of page=851968 off_in_page=0 len_in_page=36864\nThe above lines show our buffered write has dirtied 3 pages of inode\n259 of root 5:\n  704K             768K              832K              896K\n  I           |////I/////////////////I///////////|     I\n              756K                               868K\n  |///| is the dirtied range using subpage bitmaps. and 'I' is the page\n  boundary.\n  Meanwhile all three pages (704K, 768K, 832K) have their PageDirty\n  flag set.\n  > btrfs_direct_write: r/i=5/259 start dio filepos=696320 len=102400\nThen direct IO writ\n---truncated---",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/97713b1a2ced1e4a2a6c40045903797ebd44d7e0"
          },
          {
            "url": "https://git.kernel.org/stable/c/ba4dedb71356638d8284e34724daca944be70368"
          },
          {
            "url": "https://git.kernel.org/stable/c/d3b403209f767e5857c1b9fda66726e6e6ffc99f"
          }
        ]
      }
    },
    {
      "cve": {
        "id": "CVE-2024-44973",
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "published": "2024-09-04T19:15:31.487",
        "lastModified": "2024-09-04T19:15:31.487",
        "baseScore": null,
        "baseSeverity": null,
        "exploitabilityScore": null,
        "impactScore": null,
        "description": "In the Linux kernel, the following vulnerability has been resolved:\nmm, slub: do not call do_slab_free for kfence object\nIn 782f8906f805 the freeing of kfence objects was moved from deep\ninside do_slab_free to the wrapper functions outside. This is a nice\nchange, but unfortunately it missed one spot in __kmem_cache_free_bulk.\nThis results in a crash like this:\nBUG skbuff_head_cache (Tainted: G S  B       E     ): Padding overwritten. 0xffff88907fea0f00-0xffff88907fea0fff @offset=3840\nslab_err (mm/slub.c:1129)\nfree_to_partial_list (mm/slub.c:? mm/slub.c:4036)\nslab_pad_check (mm/slub.c:864 mm/slub.c:1290)\ncheck_slab (mm/slub.c:?)\nfree_to_partial_list (mm/slub.c:3171 mm/slub.c:4036)\nkmem_cache_alloc_bulk (mm/slub.c:? mm/slub.c:4495 mm/slub.c:4586 mm/slub.c:4635)\nnapi_build_skb (net/core/skbuff.c:348 net/core/skbuff.c:527 net/core/skbuff.c:549)\nAll the other callers to do_slab_free appear to be ok.\nAdd a kfence_free check in __kmem_cache_free_bulk to avoid the crash.",
        "cweIds": null,
        "references": [
          {
            "url": "https://git.kernel.org/stable/c/a371d558e6f3aed977a8a7346350557de5d25190"
          },
          {
            "url": "https://git.kernel.org/stable/c/b35cd7f1e969aaa63e6716d82480f6b8a3230949"
          }
        ]
      }
    }
  ]
}